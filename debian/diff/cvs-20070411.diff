diff -urNxCVS -xdebian ../../dietlibc/.cvsignore ./.cvsignore
--- ../../dietlibc/.cvsignore	2003-09-13 08:46:42.000000000 +0000
+++ ./.cvsignore	2006-10-30 15:28:32.000000000 +0000
@@ -26,4 +26,5 @@
 pic-sparc64
 bin-ia64
 bin-x86_64
+pic-x86_64
 cycles
diff -urNxCVS -xdebian ../../dietlibc/CHANGES ./CHANGES
--- ../../dietlibc/CHANGES	2006-06-18 18:32:26.000000000 +0000
+++ ./CHANGES	2007-04-11 08:09:12.000000000 +0000
@@ -1,3 +1,61 @@
+0.31:
+  getopt_long and getopt_long_only now refuse ambiguous abbreviations
+  fix printf %u/%x on 64-bit platforms
+  fix fd leak in if_nameindex (Florian Westphal)
+  fix printf %g (well, get closer)
+  fix sparc64 longjmp (Rene Rebe)
+  add dn_skipname
+  add pthread prototypes that are needed to compile libgcc when
+    compiling a cross compiler gcc
+  fix ftw64
+  fixes for some corner cases from Ilja van Sprundel:
+    - tempnam
+    - strsignal
+    - strftime
+    - sunrpc code
+  faster qsort
+  support %j in printf (Gernot Tenchio)
+  do omit the frame pointer on x86_64
+  fix pthread_cond_timedwait (Gernot Tenchio)
+  fix getcwd, ftw, ftw64, dirname (Ilja van Sprundel)
+    Some fd leaks in error conditions.
+  fix stackguard to be .quad instead of .long (cause subtle memory
+    corruption, which in most cases caused DNS lookups to fail on 64-bit
+    platforms)
+  fix dynamic build
+  do the magic required for -fstack-protector in gcc 4.1.1 to actually
+    work (which includes setting up thread local storage), so far on
+    i386 and amd64
+  add ctime_r (for c-icap, Gernot Tenchio)
+  fix strptime return value (Gernot Tenchio)
+  fix R_386_32, R_ARM_ABS32, R_X86_64_64 in libdl (Gernot Tenchio)
+  Olaf: Added DT_GNU_HASH symbol resolver.
+  fix security bug in librpc.  You know, librpc, that stinking Sun code
+    full of problems?  Just adding that code was a bad mistake, I think.
+    I tried auditing it, but I nearly got a brain tumor when I opened
+    those files.  Thanks to Ilja van Sprundel for finding this bug (with
+    Google codesearch, no less! :-) )
+  accept mDNS packets with set recursion desired bit
+  add const to cfgetispeed and cfgetospeed arguments
+  fix off-by-one in getdelim (reported by Ilja van Sprundel)
+  prevent integer overflows in printf (return -1, like Solaris)
+  fix putenv (Nikola Vladov)
+  use time_t in struct stat for the time values
+  support LLMNR in dnsd (no idea if it works, apparently only Vista
+    supports it)
+  fix ftell (Jens Laas)
+  fix getaddrinfo (return more than just the first IP) (Gernot Tenchio)
+  make sure to declare __dietlibc__ during compilation of the lib
+    itself, so we can have more portable code in the libc code behind
+    #ifndef __dietlibc__ (see ftw64 for an example)
+  fix off-by-one in iconv
+  add missing brackets in dn_skipname
+  strptime also fills in tm_wday and tm_yday (Gernot Tenchio)
+  x86-64 getpriority has bias 20 (Rene Rebe)
+  fix typo in fstatfs64 (Gernot Tenchio)
+  fix infinite loop in getaddrinfo (Nikola Vladov)
+  don't include sys/stat.h in stdio.h and unistd.h (Gernot Tenchio)
+
 0.30:
   put exception handling frames in read-only section on AMD64 and S/390
   make sys/stat.h ILP64 compatible
@@ -51,7 +109,7 @@
   fix unlockpt (Gernot Tenchio)
   Olaf: fixing putenv for the situation that environ is NULL
     (situation after a clearenv)
-  HP-PA fixes (Micah Anderson, Hubert Poetzl)
+  HP-PA fixes (Micah Anderson, Herbert Poetzl)
   syscall() for ppc/64
   make __kernel_size_t more like the real thing (Rene Rebe)
   fix __exec_shell (execv and execvp) (Gernot Tenchio)
diff -urNxCVS -xdebian ../../dietlibc/FAQ ./FAQ
--- ../../dietlibc/FAQ	2005-04-23 11:59:07.000000000 +0000
+++ ./FAQ	2007-04-11 08:09:12.000000000 +0000
@@ -300,7 +300,7 @@
 
 
 Q: I get an error message at link time, that "main" can not be found.
-A: Disable WANT_STACKGAP in dietfeautres.h or try upgrading your binutils.
+A: Disable WANT_STACKGAP in dietfeatures.h or try upgrading your binutils.
 
 
 Q: I want to have a gcc that uses the diet libc by default.
@@ -315,3 +315,19 @@
    %{shared:dyn_so_start.o%s}%{!shared:%{static:start.o%s dyn_start.o%s}%{!static:dstart.o%s dyn_dstart.o%s}}
 
 
+Q: Dynamically linked binaries don't work on Fedora 6!
+A: Fedora 6 ships with binutils that can create non-standard ELF
+   binaries, and they hacked their gcc to generate them by default.  You
+   can see whether your gcc also does this with
+
+     gcc -dumpspecs|grep "hash-style=gnu"
+
+   and you can see if a shared library was build with this flag with
+
+     readelf -S libname.so|grep GNU_HASH
+
+   You can override this behavior like this:
+
+     diet-dyn gcc -Wl,--hash-style=sysv -shared -o libx.so x.c
+                  ^^^^^^^^^^^^^^^^^^^^^
+
diff -urNxCVS -xdebian ../../dietlibc/Makefile ./Makefile
--- ../../dietlibc/Makefile	2007-04-11 08:10:34.000000000 +0000
+++ ./Makefile	2007-04-11 08:09:12.000000000 +0000
@@ -186,6 +186,8 @@
 SAFER_CFLAGS=$(CFLAGS)
 endif
 
+CC+=-D__dietlibc__
+
 $(OBJDIR)/crypt.o: libcrypt/crypt.c
 	$(CROSS)$(CC) $(INC) $(SAFER_CFLAGS) -c $< -o $@
 
@@ -227,9 +229,6 @@
 
 LD_UNSET = env -u LD_RUN_PATH
 
-$(OBJDIR)/libdietc.so: $(OBJDIR)/dietlibc.a
-	$(LD_UNSET) $(CROSS)ld -whole-archive -shared -o $@ $^
-
 dyn: dyn_lib
 
 # added dynamic linker
@@ -512,3 +511,6 @@
 
 # WANT_SSP
 $(OBJDIR)/stackgap.o: dietfeatures.h
+
+# WANT_MALLOC_ZERO
+$(OBJDIR)/strndup.o: dietfeatures.h
diff -urNxCVS -xdebian ../../dietlibc/TODO ./TODO
--- ../../dietlibc/TODO	2004-10-01 10:09:11.000000000 +0000
+++ ./TODO	2006-08-07 14:19:04.000000000 +0000
@@ -29,3 +29,6 @@
 implement AI_V4MAPPED in getaddrinfo (not in man page, only susv3)
 
 Also: AF_UNSPEC, AI_ADDRCONFIG
+set_thread_area -> set up TLD, for stack guard
+
+lsearch, lfind, hsearch, tsearch
diff -urNxCVS -xdebian ../../dietlibc/arm/syscalls.h ./arm/syscalls.h
--- ../../dietlibc/arm/syscalls.h	2006-07-06 11:20:58.000000000 +0000
+++ ./arm/syscalls.h	2006-10-04 15:30:10.000000000 +0000
@@ -290,7 +290,19 @@
 #define __NR_inotify_init		(__NR_SYSCALL_BASE+316)
 #define __NR_inotify_add_watch		(__NR_SYSCALL_BASE+317)
 #define __NR_inotify_rm_watch		(__NR_SYSCALL_BASE+318)
+#define __NR_mbind			(__NR_SYSCALL_BASE+319)
+#define __NR_get_mempolicy		(__NR_SYSCALL_BASE+320)
+#define __NR_set_mempolicy		(__NR_SYSCALL_BASE+321)
 
+/*
+ * The following SWIs are ARM private.
+ */
+#define __ARM_NR_BASE			(__NR_SYSCALL_BASE+0x0f0000)
+#define __ARM_NR_breakpoint		(__ARM_NR_BASE+1)
+#define __ARM_NR_cacheflush		(__ARM_NR_BASE+2)
+#define __ARM_NR_usr26			(__ARM_NR_BASE+3)
+#define __ARM_NR_usr32			(__ARM_NR_BASE+4)
+#define __ARM_NR_set_tls		(__ARM_NR_BASE+5)
 
 /* ok the next few values are for the optimization of the unified syscalls
  * on arm.
diff -urNxCVS -xdebian ../../dietlibc/contrib/dnsd.c ./contrib/dnsd.c
--- ../../dietlibc/contrib/dnsd.c	2005-05-13 16:30:20.000000000 +0000
+++ ./contrib/dnsd.c	2007-02-01 08:31:53.000000000 +0000
@@ -18,20 +18,23 @@
 int namelen;
 struct sockaddr* peer;
 socklen_t sl;
+/* zeroconf/bonjour */
 int s6,s4;
+/* llmnr */
+int ls6,ls4;
 char ifname[10];
 
 struct sockaddr_in mysa4;
 struct sockaddr_in6 mysa6;
 
-static void handle(int s,char* buf,int len,int interface) {
+static void handle(int s,char* buf,int len,int interface,int llmnr) {
   int q;
   char* obuf=buf;
   char* after;
   int olen=len;
   if (len<8*2) return;			/* too short */
   buf[len]=0;
-  if ((buf[2]&0xf8) != 0) return;		/* not query */
+  if ((buf[2]&(llmnr?0xfd:0xf8)) != 0) return;		/* not query */
   q=(((unsigned int)(buf[4])) << 8) | buf[5];
   if (q!=1) return;			/* cannot handle more than 1 query */
   if (buf[6] || buf[7]) return;		/* answer count must be 0 */
@@ -101,7 +104,7 @@
 
 struct sockaddr_in sa4;
 struct sockaddr_in6 sa6;
-struct pollfd pfd[2];
+struct pollfd pfd[4];
 
 struct msghdr mh;
 struct iovec iv;
@@ -174,13 +177,13 @@
   return 0;
 }
 
-static void recv4() {
+static void recv4(int s) {
   int len;
   int interface;
 
   mh.msg_name=&sa4;
   mh.msg_namelen=sizeof(sa4);
-  if ((len=recvmsg(s4,&mh,0))==-1) {
+  if ((len=recvmsg(s,&mh,0))==-1) {
     perror("recvmsg");
     exit(3);
   }
@@ -190,15 +193,15 @@
   interface=v4if();
   getip(interface);
 
-  handle(s4,buf,len,interface);
+  handle(s,buf,len,interface,s==ls4);
 }
 
-static void recv6() {
+static void recv6(int s) {
   int len,interface;
 
   mh.msg_name=&sa6;
   mh.msg_namelen=sizeof(sa6);
-  if ((len=recvmsg(s6,&mh,0))==-1) {
+  if ((len=recvmsg(s,&mh,0))==-1) {
     perror("recvmsg");
     exit(3);
   }
@@ -212,34 +215,22 @@
 
   getip(interface);
 
-  handle(s6,buf,len,interface);
+  handle(s,buf,len,interface,s==ls6);
 }
 
-int main() {
-  mh.msg_name=&sa4;
-  mh.msg_namelen=sizeof(sa4);
-  mh.msg_iov=&iv;
-  mh.msg_iovlen=1;
-  iv.iov_base=buf;
-  iv.iov_len=PKGSIZE;
-  mh.msg_control=abuf;
-  mh.msg_controllen=sizeof(abuf);
-
-  if (gethostname(myhostname,64)==-1) {
-    perror("gethostname");
-    return 1;
-  }
-  namelen=strlen(myhostname);
+static void init_sockets(int* sock6,int* sock4,int port,char* v6ip,char* v4ip) {
+  int s4,s6;
+  *sock6=-1; *sock4=-1;
   s6=socket(PF_INET6,SOCK_DGRAM,IPPROTO_UDP);
   s4=socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);
   if (s4==-1 && s6==-1) {
     perror("socket");
-    return 2;
+    return;
   }
   if (s6!=-1) {
     memset(&sa6,0,sizeof(sa6));
     sa6.sin6_family=PF_INET6;
-    sa6.sin6_port=htons(5353);
+    sa6.sin6_port=htons(port);
     if (bind(s6,(struct sockaddr*)&sa6,sizeof(struct sockaddr_in6))==-1) {
       perror("bind IPv6");
       close(s6);
@@ -249,7 +240,7 @@
   if (s4!=-1) {
     memset(&sa4,0,sizeof(sa4));
     sa4.sin_family=PF_INET;
-    sa4.sin_port=htons(5353);
+    sa4.sin_port=htons(port);
     if (bind(s4,(struct sockaddr*)&sa4,sizeof(struct sockaddr_in))==-1) {
       if (errno!=EADDRINUSE || s6==-1)
 	perror("bind IPv4");
@@ -257,7 +248,7 @@
       s4=-1;
     }
   }
-  if (s4==-1 && s6==-1) return 2;
+  if (s4==-1 && s6==-1) return;
 
   {
     int val=255;
@@ -266,7 +257,7 @@
       struct ipv6_mreq opt;
       setsockopt(s6,IPPROTO_IPV6,IPV6_UNICAST_HOPS,&val,sizeof(val));
       setsockopt(s6,IPPROTO_IPV6,IPV6_MULTICAST_LOOP,&one,sizeof(one));
-      memcpy(&opt.ipv6mr_multiaddr,"\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfb",16);
+      memcpy(&opt.ipv6mr_multiaddr,v6ip,16);
       opt.ipv6mr_interface=0;
       setsockopt(s6,IPPROTO_IPV6,IPV6_ADD_MEMBERSHIP,&opt,sizeof opt);
 //      setsockopt(s6,IPPROTO_IPV6,IPV6_PKTINFO,&one,sizeof one);
@@ -275,95 +266,61 @@
       struct ip_mreq opt;
       int s=(s4==-1?s6:s4);
       setsockopt(s,SOL_IP,IP_TTL,&val,sizeof(val));
-      memcpy(&opt.imr_multiaddr.s_addr,"\xe0\x00\x00\xfb",4);
+      memcpy(&opt.imr_multiaddr.s_addr,v4ip,4);
       opt.imr_interface.s_addr=0;
       setsockopt(s,IPPROTO_IP,IP_ADD_MEMBERSHIP,&opt,sizeof(opt));
       setsockopt(s,SOL_IP,IP_PKTINFO,&one,sizeof one);
     }
   }
 
-  for (;;) {
-    /* 1500 is the MTU for UDP, I figure we won't longer packets */
-    /* add 1 to be able to add \0 */
-    int len;
-    int interface=0;
-    if (s4!=-1 && s6!=-1) {
-      if (s4!=-1) {
-	recv4();
-#if 0
-	if ((len=recvmsg(s4,&mh,0))==-1) {
-	  perror("recvmsg");
-	  return 3;
-	}
-	peer=(struct sockaddr*)&sa4;
-	sl=sizeof(sa4);
+  *sock4=s4;
+  *sock6=s6;
+}
 
-	for (x=CMSG_FIRSTHDR(&mh); x; x=CMSG_NXTHDR(&mh,x))
-	  if (x->cmsg_level==SOL_IP && x->cmsg_type==IP_PKTINFO) {
-	    struct in_pktinfo* y=(struct in_pktinfo*)(CMSG_DATA(x));
-	    interface=y->ipi_ifindex;
-	    break;
-	  }
-
-	handle(s4,buf,len,interface);
-#endif
-      } else {
-	recv6();
-#if 0
-	sl=sizeof(sa6);
-	if ((len=recvfrom(s6,buf,PKGSIZE,0,(struct sockaddr*)&sa6,&sl))==-1) {
-	  perror("recvfrom");
-	  return 3;
-	}
-	peer=(struct sockaddr*)&sa6;
+int main() {
+  int n=-1;
+  mh.msg_name=&sa4;
+  mh.msg_namelen=sizeof(sa4);
+  mh.msg_iov=&iv;
+  mh.msg_iovlen=1;
+  iv.iov_base=buf;
+  iv.iov_len=PKGSIZE;
+  mh.msg_control=abuf;
+  mh.msg_controllen=sizeof(abuf);
 
-	handle(s6,buf,len,sa6.sin6_scope_id);
-#endif
-      }
-    } else {
-      pfd[0].fd=s4; pfd[0].events=POLLIN;
-      pfd[1].fd=s6; pfd[1].events=POLLIN;
-      switch (poll(pfd,2,5*1000)) {
-      case -1:
-	if (errno==EINTR) continue;
-	perror("poll");
-	return 1;
-      case 0:
-	continue;
-      }
-      if (pfd[0].revents & POLLIN) {
-	recv4();
-#if 0
-	if ((len=recvmsg(s4,&mh,0))==-1) {
-	  perror("recvmsg");
-	  return 3;
-	}
-	peer=(struct sockaddr*)&sa4;
-	sl=sizeof(sa4);
+  if (gethostname(myhostname,64)==-1) {
+    perror("gethostname");
+    return 1;
+  }
+  namelen=strlen(myhostname);
 
-	for (x=CMSG_FIRSTHDR(&mh); x; x=CMSG_NXTHDR(&mh,x))
-	  if (x->cmsg_level==SOL_IP && x->cmsg_type==IP_PKTINFO) {
-	    struct in_pktinfo* y=(struct in_pktinfo*)(CMSG_DATA(x));
-	    interface=y->ipi_ifindex;
-	    break;
-	  }
+  init_sockets(&s6,&s4,5353,"\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfb","\xe0\x00\x00\xfb");
+  init_sockets(&ls6,&ls4,5355,"\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x03","\xe0\x00\x00\xfc");
 
-	handle(s4,buf,len,interface);
-#endif
-      }
-      if (pfd[1].revents & POLLIN) {
-	recv6();
-#if 0
-	sl=sizeof(sa6);
-	if ((len=recvfrom(s6,buf,sizeof(buf),0,(struct sockaddr*)&sa6,&sl))==-1) {
-	  perror("recvfrom");
-	  return 3;
-	}
-	peer=(struct sockaddr*)&sa6;
-	handle(s6,buf,len,sa6.sin6_scope_id);
-#endif
-      }
+  pfd[0].events=pfd[1].events=pfd[2].events=pfd[3].events=POLLIN;
+  if (s6!=-1) pfd[++n].fd=s6;
+  if (s4!=-1) pfd[++n].fd=s4;
+  if (ls6!=-1) pfd[++n].fd=ls6;
+  if (ls4!=-1) pfd[++n].fd=ls4;
+  if (!++n)
+    return 2;
+  for (;;) {
+    int i;
+    switch (poll(pfd,n,5*1000)) {
+    case -1:
+      if (errno==EINTR) continue;
+      perror("poll");
+      return 1;
+    case 0:
+      continue;
     }
+    for (i=0; i<n; ++i)
+      if (pfd[i].revents & POLLIN) {
+	if (pfd[i].fd==s6 || pfd[i].fd==ls6)
+	  recv6(pfd[i].fd);
+	else
+	  recv4(pfd[i].fd);
+      }
   }
   return 0;
 }
diff -urNxCVS -xdebian ../../dietlibc/diet.c ./diet.c
--- ../../dietlibc/diet.c	2007-04-11 08:10:34.000000000 +0000
+++ ./diet.c	2006-10-04 15:30:10.000000000 +0000
@@ -28,7 +28,7 @@
   "i386","-Os","-mpreferred-stack-boundary=2",
 	 "-falign-functions=1","-falign-jumps=1",
 	 "-falign-loops=1","-fomit-frame-pointer",0,
-  "x86_64","-Os","-fno-omit-frame-pointer",0,
+  "x86_64","-Os",0,
   "sparc","-Os","-mcpu=supersparc",0,
   "sparc64","-Os","-m64","-mhard-quad-float",0,
   "alpha","-Os","-fomit-frame-pointer",0,
diff -urNxCVS -xdebian ../../dietlibc/dynlinker/ldso_start.S ./dynlinker/ldso_start.S
--- ../../dietlibc/dynlinker/ldso_start.S	2001-07-09 19:49:52.000000000 +0000
+++ ./dynlinker/ldso_start.S	2006-10-30 15:28:32.000000000 +0000
@@ -1,3 +1,5 @@
+#include <endian.h>
+
 .text
 .globl ldso_start
 ldso_start:
@@ -68,7 +70,21 @@
 environ:
 .global __environ
 __environ:
+#if __WORDSIZE == 64
+	.quad 0
+#else
 	.long 0
+#endif
+
+.global environ
+environ:
+.global __environ
+__environ:
+#if __WORDSIZE == 64
+	.quad 0
+#else
+	.long 0
+#endif
 
 .global fini_entry
 fini_entry:
diff -urNxCVS -xdebian ../../dietlibc/i386/dyn_syscalls.S ./i386/dyn_syscalls.S
--- ../../dietlibc/i386/dyn_syscalls.S	2005-10-08 21:11:32.000000000 +0000
+++ ./i386/dyn_syscalls.S	2006-10-30 15:28:32.000000000 +0000
@@ -388,3 +388,5 @@
 
 #include "__longjmp.S"
 #include "setjmp.S"
+
+#include "syscalls.s/__guard.S"
diff -urNxCVS -xdebian ../../dietlibc/i386/syscalls.h ./i386/syscalls.h
--- ../../dietlibc/i386/syscalls.h	2005-09-21 07:33:08.000000000 +0000
+++ ./i386/syscalls.h	2007-01-12 11:55:00.000000000 +0000
@@ -292,6 +292,32 @@
 #define __NR_inotify_init	291
 #define __NR_inotify_add_watch	292
 #define __NR_inotify_rm_watch	293
+#define __NR_migrate_pages	294
+#define __NR_openat		295
+#define __NR_mkdirat		296
+#define __NR_mknodat		297
+#define __NR_fchownat		298
+#define __NR_futimesat		299
+#define __NR_fstatat64		300
+#define __NR_unlinkat		301
+#define __NR_renameat		302
+#define __NR_linkat		303
+#define __NR_symlinkat		304
+#define __NR_readlinkat		305
+#define __NR_fchmodat		306
+#define __NR_faccessat		307
+#define __NR_pselect6		308
+#define __NR_ppoll		309
+#define __NR_unshare		310
+#define __NR_set_robust_list	311
+#define __NR_get_robust_list	312
+#define __NR_splice		313
+#define __NR_sync_file_range	314
+#define __NR_tee		315
+#define __NR_vmsplice		316
+#define __NR_move_pages		317
+#define __NR_getcpu		318
+#define __NR_epoll_pwait	319
 
 
 #define syscall_weak(name,wsym,sym) \
diff -urNxCVS -xdebian ../../dietlibc/ia64/syscalls.h ./ia64/syscalls.h
--- ../../dietlibc/ia64/syscalls.h	2005-09-21 07:33:08.000000000 +0000
+++ ./ia64/syscalls.h	2006-10-04 15:30:10.000000000 +0000
@@ -257,6 +257,28 @@
 #define __NR_inotify_init		1277
 #define __NR_inotify_add_watch		1278
 #define __NR_inotify_rm_watch		1279
+#define __NR_migrate_pages		1280
+#define __NR_openat			1281
+#define __NR_mkdirat			1282
+#define __NR_mknodat			1283
+#define __NR_fchownat			1284
+#define __NR_futimesat			1285
+#define __NR_newfstatat			1286
+#define __NR_unlinkat			1287
+#define __NR_renameat			1288
+#define __NR_linkat			1289
+#define __NR_symlinkat			1290
+#define __NR_readlinkat			1291
+#define __NR_fchmodat			1292
+#define __NR_faccessat			1293
+/* 1294, 1295 reserved for pselect/ppoll */
+#define __NR_unshare			1296
+#define __NR_splice			1297
+#define __NR_set_robust_list		1298
+#define __NR_get_robust_list		1299
+#define __NR_sync_file_range		1300
+#define __NR_tee			1301
+#define __NR_vmsplice			1302
 
 
 #define syscall(name, sym) \
diff -urNxCVS -xdebian ../../dietlibc/include/elf.h ./include/elf.h
--- ../../dietlibc/include/elf.h	2005-04-22 13:28:06.000000000 +0000
+++ ./include/elf.h	2006-11-23 09:49:56.000000000 +0000
@@ -670,6 +670,9 @@
    If any adjustment is made to the ELF object after it has been
    built these entries will need to be adjusted.  */
 #define DT_ADDRRNGLO	0x6ffffe00
+#define DT_GNU_HASH	0x6ffffe05
+#define DT_TLSDESC_PLT	0x6ffffe06
+#define DT_TLSDESC_GOT	0x6ffffe07
 #define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
 #define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
 #define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
diff -urNxCVS -xdebian ../../dietlibc/include/pthread.h ./include/pthread.h
--- ../../dietlibc/include/pthread.h	2005-03-15 08:51:22.000000000 +0000
+++ ./include/pthread.h	2006-08-07 14:19:04.000000000 +0000
@@ -252,6 +252,10 @@
 
 int pthread_sigmask(int how,const sigset_t*newset,sigset_t*oldset);
 
+/* these two aren't actually supported right now */
+int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr, int *restrict type);
+int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
+
 __END_DECLS
 
 #endif
diff -urNxCVS -xdebian ../../dietlibc/include/resolv.h ./include/resolv.h
--- ../../dietlibc/include/resolv.h	2006-02-14 07:00:05.000000000 +0000
+++ ./include/resolv.h	2006-07-05 07:50:21.000000000 +0000
@@ -125,6 +125,8 @@
 
 void res_close(void) __THROW __attribute_dontuse__;
 
+int dn_skipname(const unsigned char* cur,const unsigned char* eom) __THROW;
+
 __END_DECLS
 
 #endif
diff -urNxCVS -xdebian ../../dietlibc/include/stdio.h ./include/stdio.h
--- ../../dietlibc/include/stdio.h	2005-03-15 08:51:22.000000000 +0000
+++ ./include/stdio.h	2007-04-11 08:09:12.000000000 +0000
@@ -3,8 +3,8 @@
 
 #include <sys/cdefs.h>
 #include <sys/types.h>
-#include <sys/stat.h>
 #include <stdarg.h>
+#include <endian.h>
 
 __BEGIN_DECLS
 
@@ -89,7 +89,7 @@
 off_t ftello(FILE *stream) __THROW;
 off_t ftello_unlocked(FILE *stream) __THROW;
 
-#ifndef __NO_STAT64
+#if __WORDSIZE == 32
 int fseeko64(FILE *stream, loff_t offset, int whence) __THROW;
 int fseeko64_unlocked(FILE *stream, loff_t offset, int whence) __THROW;
 loff_t ftello64(FILE *stream) __THROW;
diff -urNxCVS -xdebian ../../dietlibc/include/stdlib.h ./include/stdlib.h
--- ../../dietlibc/include/stdlib.h	2005-09-21 07:33:08.000000000 +0000
+++ ./include/stdlib.h	2006-07-04 08:54:14.000000000 +0000
@@ -29,7 +29,7 @@
 unsigned long int strtoul(const char *nptr, char **endptr, int base) __THROW;
 
 extern int __ltostr(char *s, unsigned int size, unsigned long i, unsigned int base, int UpCase) __THROW;
-extern int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2) __THROW;
+extern int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2,int g) __THROW;
 
 #if !defined(__STRICT_ANSI__) || __STDC_VERSION__ + 0 >= 199900L
 __extension__ long long int strtoll(const char *nptr, char **endptr, int base) __THROW;
diff -urNxCVS -xdebian ../../dietlibc/include/sys/prctl.h ./include/sys/prctl.h
--- ../../dietlibc/include/sys/prctl.h	2003-08-19 16:58:18.000000000 +0000
+++ ./include/sys/prctl.h	2007-04-11 08:09:12.000000000 +0000
@@ -3,9 +3,68 @@
 
 #include <sys/cdefs.h>
 
+/* Values to pass as first argument to prctl() */
+
+#define PR_SET_PDEATHSIG  1  /* Second arg is a signal */
+#define PR_GET_PDEATHSIG  2  /* Second arg is a ptr to return the signal */
+
+/* Get/set current->mm->dumpable */
+#define PR_GET_DUMPABLE   3
+#define PR_SET_DUMPABLE   4
+
+/* Get/set unaligned access control bits (if meaningful) */
+#define PR_GET_UNALIGN	  5
+#define PR_SET_UNALIGN	  6
+# define PR_UNALIGN_NOPRINT	1	/* silently fix up unaligned user accesses */
+# define PR_UNALIGN_SIGBUS	2	/* generate SIGBUS on unaligned user access */
+
+/* Get/set whether or not to drop capabilities on setuid() away from uid 0 */
+#define PR_GET_KEEPCAPS   7
+#define PR_SET_KEEPCAPS   8
+
+/* Get/set floating-point emulation control bits (if meaningful) */
+#define PR_GET_FPEMU  9
+#define PR_SET_FPEMU 10
+# define PR_FPEMU_NOPRINT	1	/* silently emulate fp operations accesses */
+# define PR_FPEMU_SIGFPE	2	/* don't emulate fp operations, send SIGFPE instead */
+
+/* Get/set floating-point exception mode (if meaningful) */
+#define PR_GET_FPEXC	11
+#define PR_SET_FPEXC	12
+# define PR_FP_EXC_SW_ENABLE	0x80	/* Use FPEXC for FP exception enables */
+# define PR_FP_EXC_DIV		0x010000	/* floating point divide by zero */
+# define PR_FP_EXC_OVF		0x020000	/* floating point overflow */
+# define PR_FP_EXC_UND		0x040000	/* floating point underflow */
+# define PR_FP_EXC_RES		0x080000	/* floating point inexact result */
+# define PR_FP_EXC_INV		0x100000	/* floating point invalid operation */
+# define PR_FP_EXC_DISABLED	0	/* FP exceptions disabled */
+# define PR_FP_EXC_NONRECOV	1	/* async non-recoverable exc. mode */
+# define PR_FP_EXC_ASYNC	2	/* async recoverable exception mode */
+# define PR_FP_EXC_PRECISE	3	/* precise exception mode */
+
+/* Get/set whether we use statistical process timing or accurate timestamp
+ * based process timing */
+#define PR_GET_TIMING   13
+#define PR_SET_TIMING   14
+# define PR_TIMING_STATISTICAL  0       /* Normal, traditional,
+                                                   statistical process timing */
+# define PR_TIMING_TIMESTAMP    1       /* Accurate timestamp based
+                                                   process timing */
+
+#define PR_SET_NAME    15		/* Set process name */
+#define PR_GET_NAME    16		/* Get process name */
+
+/* Get/set process endian */
+#define PR_GET_ENDIAN	19
+#define PR_SET_ENDIAN	20
+# define PR_ENDIAN_BIG		0
+# define PR_ENDIAN_LITTLE	1	/* True little endian mode */
+# define PR_ENDIAN_PPC_LITTLE	2	/* "PowerPC" pseudo little endian */
+
+
 __BEGIN_DECLS
 
-int prctl(int option, unsigned long arg2, unsigned long arg3 , unsigned long arg4, unsigned long arg5) __THROW;
+int prctl(int option, unsigned long arg2, ...) __THROW;
 
 __END_DECLS
 
diff -urNxCVS -xdebian ../../dietlibc/include/sys/stat.h ./include/sys/stat.h
--- ../../dietlibc/include/sys/stat.h	2005-09-21 07:33:08.000000000 +0000
+++ ./include/sys/stat.h	2007-02-01 08:31:53.000000000 +0000
@@ -21,11 +21,11 @@
 	unsigned long	st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	  signed long	st_atime;
+	time_t		st_atime;
 	unsigned long	__unused1;
-	  signed long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	  signed long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	unsigned long	__unused4;
 	unsigned long	__unused5;
@@ -53,13 +53,13 @@
 	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
 	unsigned long	__pad4;		/* future possible st_blocks high bits */
 
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	__pad5;
 
-	  signed long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__pad6;
 
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__pad7;		/* will be high 32 bits of ctime someday */
 
 __extension__	unsigned long long	st_ino __attribute__((__packed__));
@@ -104,13 +104,13 @@
 	unsigned char	__pad4[8];
 	uint32_t	st_blocks;
 
-	uint32_t	st_atime;
+	time_t		st_atime;
 	uint32_t	st_atime_nsec;
 
-	uint32_t	st_mtime;
+	time_t		st_mtime;
 	uint32_t	st_mtime_nsec;
 
-	uint32_t	st_ctime;
+	time_t		st_ctime;
 	uint32_t	st_ctime_nsec;
 
 	uint32_t	__unused4;
@@ -118,6 +118,7 @@
 };
 
 #elif defined(__sparc__)
+
 struct stat {
 	uint16_t	st_dev;
 	unsigned long	st_ino;
@@ -127,11 +128,11 @@
 	uint16_t	st_gid;
 	uint16_t	st_rdev;
 	long		st_size;
-	long		st_atime;
+	time_t		st_atime;
 	unsigned long	__unused1;
-	long		st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	long		st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	long		st_blksize;
 	long		st_blocks;
@@ -161,19 +162,21 @@
 	unsigned char	__pad4[8];
 	uint32_t	st_blocks;
 
-	 int32_t	st_atime;
+	time_t		st_atime;
 	uint32_t	__unused1;
 
-	 int32_t	st_mtime;
+	time_t		st_mtime;
 	uint32_t	__unused2;
 
-	 int32_t	st_ctime;
+	time_t		st_ctime;
 	uint32_t	__unused3;
 
 	uint32_t	__unused4;
 	uint32_t	__unused5;
 };
+
 #elif defined(__alpha__)
+
 struct stat {
 	uint32_t	st_dev;
 	uint32_t	st_ino;
@@ -183,15 +186,17 @@
 	uint32_t	st_gid;
 	uint32_t	st_rdev;
 	signed long	st_size;
-	signed long	st_atime;
-	signed long	st_mtime;
-	signed long	st_ctime;
+	time_t		st_atime;
+	time_t		st_mtime;
+	time_t		st_ctime;
 	uint32_t	st_blksize;
 	int32_t		st_blocks;
 	uint32_t	st_flags;
 	uint32_t	st_gen;
 };
+
 #elif defined(__mips__)
+
 struct stat {
 	uint32_t	st_dev;
 	long		st_pad1[3];		/* Reserved for network id */
@@ -249,6 +254,7 @@
 __extension__ long long	st_blocks;
 };
 #elif defined(__powerpc__) || defined(__powerpc64__)
+
 #if defined(__powerpc__) && !defined(__powerpc64__)
 struct stat {
 	dev_t		st_dev;
@@ -261,11 +267,11 @@
 	off_t		st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	  signed long	st_atime;
+	time_t		st_atime;
 	unsigned long	__unused1;
-	  signed long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	  signed long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	unsigned long	__unused4;
 	unsigned long	__unused5;
@@ -282,11 +288,11 @@
 	off_t		st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	st_atime_nsec;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	st_mtime_nsec;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	st_ctime_nsec;
 	unsigned long	__unused4;
 	unsigned long	__unused5;
@@ -309,11 +315,11 @@
 	long st_blksize;		/* Optimal block size for I/O.  */
 
 __extension__	long long st_blocks;		/* Number 512-byte blocks allocated. */
-	long st_atime;			/* Time of last access.  */
+	time_t st_atime;			/* Time of last access.  */
 	unsigned long int __unused1;
-	long st_mtime;			/* Time of last modification.  */
+	time_t st_mtime;			/* Time of last modification.  */
 	unsigned long int __unused2;
-	long st_ctime;			/* Time of last status change.  */
+	time_t st_ctime;			/* Time of last status change.  */
 	unsigned long int __unused3;
 	unsigned long int __unused4;
 	unsigned long int __unused5;
@@ -332,11 +338,11 @@
 	unsigned long	st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	  signed long	st_atime;
+	time_t		st_atime;
 	unsigned long	__unused1;
-	  signed long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	  signed long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	unsigned long	__unused4;
 	unsigned long	__unused5;
@@ -371,13 +377,13 @@
 	unsigned long	__pad4;		/* future possible st_blocks high bits */
 #endif
 
-	  signed long	st_atime;
+	time_t		st_atime;
 	unsigned long	__pad5;
 
-	  signed long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__pad6;
 
-	  signed long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__pad7;		/* will be high 32 bits of ctime someday */
 
 __extension__	unsigned long long	st_ino;
@@ -394,11 +400,11 @@
         uint32_t	__pad1;
         unsigned long	st_rdev;
         unsigned long	st_size;
-        unsigned long	st_atime;
+        time_t		st_atime;
         unsigned long	__reserved0;    /* reserved for atime.nanoseconds */
-        unsigned long	st_mtime;
+        time_t		st_mtime;
         unsigned long	__reserved1;    /* reserved for mtime.nanoseconds */
-        unsigned long	st_ctime;
+        time_t		st_ctime;
         unsigned long	__reserved2;    /* reserved for ctime.nanoseconds */
         unsigned long	st_blksize;
         long		st_blocks;
@@ -418,11 +424,11 @@
 	unsigned long	st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	__unused1;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	unsigned long	__unused4;
 	unsigned long	__unused5;
@@ -446,11 +452,11 @@
 	unsigned char	__pad4[4];
 	unsigned long	__pad5; 	/* future possible st_blocks high bits */
 	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	__pad6;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__pad7;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__pad8; 	/* will be high 32 bits of ctime someday */
 __extension__	unsigned long long	st_ino;
 };
@@ -466,11 +472,11 @@
        uint16_t		st_reserved2;   /* old st_gid */
        unsigned long	st_rdev;
        unsigned long	st_size;
-       unsigned long	st_atime;
+       time_t		st_atime;
        unsigned long	st_spare1;
-       unsigned long	st_mtime;
+       time_t		st_mtime;
        unsigned long	st_spare2;
-       unsigned long	st_ctime;
+       time_t		st_ctime;
        unsigned long	st_spare3;
        long		st_blksize;
        long		st_blocks;
@@ -503,16 +509,17 @@
 	unsigned long	st_blksize;
 
 	unsigned long long st_blocks;
- 	unsigned long	st_atime;
+ 	time_t		st_atime;
 	unsigned long	__unused1;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	unsigned long long st_ino;
 };
 
 #elif defined(__x86_64__)
+
 struct stat {
 	unsigned long	st_dev;
 	unsigned long	st_ino;
@@ -525,11 +532,11 @@
 	unsigned long	st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	__reserved0;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__reserved1;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__reserved2;
 	long		__unused[3];
 };
@@ -546,11 +553,11 @@
 	uint32_t	__pad;
 	unsigned long	st_rdev;
 	unsigned long	st_size;
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	reserved;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	reserved2;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	reserved3;
 	unsigned long	st_blksize;
 	long		st_blocks;
diff -urNxCVS -xdebian ../../dietlibc/include/sys/tls.h ./include/sys/tls.h
--- ../../dietlibc/include/sys/tls.h	1970-01-01 00:00:00.000000000 +0000
+++ ./include/sys/tls.h	2006-10-13 23:59:50.000000000 +0000
@@ -0,0 +1,62 @@
+#ifndef _SYS_TLS_H
+#define _SYS_TLS_H
+
+#include <inttypes.h>
+#include <stddef.h>
+#include <stdbool.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+typedef struct
+{
+  void *tcb;            /* Pointer to the TCB.  Not necessary the
+                           thread descriptor used by libpthread.  */
+  dtv_t *dtv;
+  void *self;           /* Pointer to the thread descriptor.  */
+  int multiple_threads;
+  uintptr_t sysinfo;
+  uintptr_t stack_guard;
+  uintptr_t pointer_guard;
+} tcbhead_t;
+
+#if defined(__i386__)
+
+struct user_desc {
+	unsigned int  entry_number;
+	unsigned long base_addr;
+	unsigned int  limit;
+	unsigned int  seg_32bit:1;
+	unsigned int  contents:2;
+	unsigned int  read_exec_only:1;
+	unsigned int  limit_in_pages:1;
+	unsigned int  seg_not_present:1;
+	unsigned int  useable:1;
+};
+
+int set_thread_area(struct user_desc* uinfo);
+
+#elif defined(__x86_64__)
+
+#define ARCH_SET_GS 0x1001
+#define ARCH_SET_FS 0x1002
+#define ARCH_GET_FS 0x1003
+#define ARCH_GET_GS 0x1004
+
+int arch_prctl(unsigned int what, void* where);
+
+#else
+
+#warning "need proper sys/tls.h for this platform"
+
+#endif
+
+#endif
diff -urNxCVS -xdebian ../../dietlibc/include/termios.h ./include/termios.h
--- ../../dietlibc/include/termios.h	2006-06-18 18:32:35.000000000 +0000
+++ ./include/termios.h	2006-12-20 10:37:45.000000000 +0000
@@ -390,9 +390,9 @@
 
 int tcgetattr(int fd, struct termios *termios_p) __THROW;
 int tcsetattr(int fd, int optional_actions, struct termios *termios_p) __THROW;
-speed_t cfgetospeed(struct termios *termios_p) __THROW;
+speed_t cfgetospeed(const struct termios *termios_p) __THROW;
 int cfsetospeed(struct termios *termios_p, speed_t speed) __THROW;
-speed_t cfgetispeed(struct termios *termios_p) __THROW;
+speed_t cfgetispeed(const struct termios *termios_p) __THROW;
 int cfsetispeed(struct termios *termios_p, speed_t speed) __THROW;
 void cfmakeraw(struct termios *t) __THROW;
 
diff -urNxCVS -xdebian ../../dietlibc/include/time.h ./include/time.h
--- ../../dietlibc/include/time.h	2005-10-04 17:47:03.000000000 +0000
+++ ./include/time.h	2006-10-30 15:28:32.000000000 +0000
@@ -38,6 +38,7 @@
 char *asctime_r(const struct tm *timeptr, char *buf) __THROW;
 
 char *ctime(const time_t *timep) __THROW;
+char *ctime_r(const time_t *timep, char* buf) __THROW;
 
 size_t strftime(char *s, size_t max, const char *format, const struct tm *tm) __THROW __attribute__((__format__(__strftime__,3,0)));
 time_t time(time_t *t) __THROW;
diff -urNxCVS -xdebian ../../dietlibc/include/unistd.h ./include/unistd.h
--- ../../dietlibc/include/unistd.h	2005-10-04 17:47:03.000000000 +0000
+++ ./include/unistd.h	2007-04-11 08:09:12.000000000 +0000
@@ -3,7 +3,7 @@
 
 #include <sys/cdefs.h>
 #include <sys/types.h>
-#include <sys/stat.h>
+#include <endian.h>
 #include <sys/fsuid.h>
 #include <sys/select.h>
 
@@ -34,7 +34,7 @@
 #define STDERR_FILENO  2
 
 off_t lseek(int fildes, off_t offset, int whence) __THROW;
-#ifndef __NO_STAT64
+#if __WORDSIZE == 32
 loff_t lseek64(int fildes, loff_t offset, int whence) __THROW;
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
 #define lseek(fildes,offset,whence) lseek64(fildes,offset,whence)
@@ -145,7 +145,7 @@
 
 int truncate(const char *path, off_t length) __THROW;
 int ftruncate(int fd, off_t length) __THROW;
-#ifndef __NO_STAT64
+#if __WORDSIZE == 32
 int truncate64(const char *path, loff_t length) __THROW;
 int ftruncate64(int fd, loff_t length) __THROW;
 #endif
@@ -243,7 +243,7 @@
 
 extern char **__environ;
 
-#ifndef __NO_STAT64
+#if __WORDSIZE == 32
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
 #define open open64
 #define creat creat64
diff -urNxCVS -xdebian ../../dietlibc/lib/__dtostr.c ./lib/__dtostr.c
--- ../../dietlibc/lib/__dtostr.c	2003-12-05 18:52:26.000000000 +0000
+++ ./lib/__dtostr.c	2006-07-04 08:54:14.000000000 +0000
@@ -11,7 +11,7 @@
   return i;
 }
 
-int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2) {
+int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2,int g) {
 #if 1
   union {
     unsigned long long l;
@@ -85,7 +85,7 @@
 	*buf=digit+'0'; ++buf;
 	if (!maxlen) {
 	  /* use scientific notation */
-	  int len=__dtostr(backup/tmp,oldbuf,maxlen,prec,prec2);
+	  int len=__dtostr(backup/tmp,oldbuf,maxlen,prec,prec2,0);
 	  int initial=1;
 	  if (len==0) return 0;
 	  maxlen-=len; buf+=len;
@@ -126,8 +126,13 @@
   if (prec2 || prec>(unsigned int)(buf-oldbuf)+1) {	/* more digits wanted */
     if (!maxlen) return 0; --maxlen;
     *buf='.'; ++buf;
-    prec-=buf-oldbuf-1;
-    if (prec2) prec=prec2;
+    if (g) {
+      if (prec2) prec=prec2;
+      prec-=buf-oldbuf-1;
+    } else {
+      prec-=buf-oldbuf-1;
+      if (prec2) prec=prec2;
+    }
     if (prec>maxlen) return 0;
     while (prec>0) {
       char digit;
diff -urNxCVS -xdebian ../../dietlibc/lib/__fstatfs64.c ./lib/__fstatfs64.c
--- ../../dietlibc/lib/__fstatfs64.c	2005-10-04 17:48:30.000000000 +0000
+++ ./lib/__fstatfs64.c	2007-04-11 08:09:12.000000000 +0000
@@ -17,7 +17,7 @@
   }
   return 0;
 #else
-  return __dietlibc_fstatfs64(fd,sizeof(*__buf),buf);
+  return __dietlibc_fstatfs64(fd,sizeof(*__buf),__buf);
 #endif
 }
 #endif
diff -urNxCVS -xdebian ../../dietlibc/lib/__getcwd.c ./lib/__getcwd.c
--- ../../dietlibc/lib/__getcwd.c	2001-08-14 16:56:49.000000000 +0000
+++ ./lib/__getcwd.c	2006-10-04 15:30:11.000000000 +0000
@@ -1,11 +1,17 @@
 #include <unistd.h>
 #include <stdlib.h>
+#include <errno.h>
 
 extern int __syscall_getcwd(char* buf, size_t size);
 
 char *getcwd(char *buf, size_t size) {
-  int tmp;
-  if ((tmp=__syscall_getcwd(buf,size))<0) return 0;
-  buf[tmp]=0;
+  if (__unlikely(!size)) {
+    errno=EINVAL;
+    buf=0;
+  } else {
+    int tmp;
+    if ((tmp=__syscall_getcwd(buf,size-1))<0) return 0;
+    buf[tmp]=0;
+  }
   return buf;
 }
diff -urNxCVS -xdebian ../../dietlibc/lib/__v_printf.c ./lib/__v_printf.c
--- ../../dietlibc/lib/__v_printf.c	2005-04-10 13:59:32.000000000 +0000
+++ ./lib/__v_printf.c	2007-01-12 11:55:00.000000000 +0000
@@ -7,24 +7,29 @@
 #include "dietstdio.h"
 #include "dietwarning.h"
 
-static inline unsigned int skip_to(const char *format) {
-  unsigned int nr;
+#define MAX_WIDTH 10*1024
+
+static inline unsigned long skip_to(const char *format) {
+  unsigned long nr;
   for (nr=0; format[nr] && (format[nr]!='%'); ++nr);
   return nr;
 }
 
 #define A_WRITE(fn,buf,sz)	((fn)->put((void*)(buf),(sz),(fn)->data))
+#define B_WRITE(fn,buf,sz)	{ if ((unsigned long)(sz) > (((unsigned long)(int)(-1))>>1) || len+(int)(sz)<len) return -1; A_WRITE(fn,buf,sz); } while (0)
 
 static const char pad_line[2][16]= { "                ", "0000000000000000", };
-static inline int write_pad(struct arg_printf* fn, int len, int padwith) {
+static int write_pad(int* dlen,struct arg_printf* fn, int len, int padwith) {
   int nr=0;
+  if (len<0 || *dlen+len<len) return -1;
   for (;len>15;len-=16,nr+=16) {
     A_WRITE(fn,pad_line[(padwith=='0')?1:0],16);
   }
   if (len>0) {
     A_WRITE(fn,pad_line[(padwith=='0')?1:0],(unsigned int)len); nr+=len;
   }
-  return nr;
+  *dlen += nr;
+  return 0;
 }
 
 int __v_printf(struct arg_printf* fn, const char *format, va_list arg_ptr)
@@ -35,9 +40,9 @@
 #endif
 
   while (*format) {
-    unsigned int sz = skip_to(format);
+    unsigned long sz = skip_to(format);
     if (sz) {
-      A_WRITE(fn,format,sz); len+=sz;
+      B_WRITE(fn,format,sz); len+=sz;
       format+=sz;
     }
     if (*format=='%') {
@@ -81,9 +86,15 @@
       case 'h':
 	--flag_long;
 	goto inn_printf;
+#if __WORDSIZE != 64
+      case 'j':
+#endif
       case 'q':		/* BSD ... */
       case 'L':
 	++flag_long; /* fall through */
+#if __WORDSIZE == 64
+      case 'j':
+#endif
       case 'l':
 	++flag_long;
 	goto inn_printf;
@@ -112,12 +123,14 @@
       case '9':
 	if(flag_dot) return -1;
 	width=strtoul(format-1,(char**)&s,10);
+	if (width>MAX_WIDTH) return -1;
 	if (ch=='0' && !flag_left) padwith='0';
 	format=s;
 	goto inn_printf;
 
       case '*':
 	width=va_arg(arg_ptr,int);
+	if (width>MAX_WIDTH) return -1; /* width is unsiged, so this catches <0, too */
 	goto inn_printf;
 
       case '.':
@@ -131,13 +144,14 @@
 	  preci=tmp<0?0:tmp;
 	  format=s;
 	}
+	if (preci>MAX_WIDTH) return -1;
 	goto inn_printf;
 
       /* print a char or % */
       case 'c':
 	ch=(char)va_arg(arg_ptr,int);
       case '%':
-	A_WRITE(fn,&ch,1); ++len;
+	B_WRITE(fn,&ch,1); ++len;
 	break;
 
 #ifdef WANT_ERROR_PRINTF
@@ -145,7 +159,7 @@
       case 'm':
 	s=strerror(_errno);
 	sz=strlen(s);
-	A_WRITE(fn,s,sz); len+=sz;
+	B_WRITE(fn,s,sz); len+=sz;
 	break;
 #endif
       /* print a string */
@@ -167,7 +181,7 @@
 	int vs;
 	
 	if (! (width||preci) ) {
-	  A_WRITE(fn,s,sz); len+=sz;
+	  B_WRITE(fn,s,sz); len+=sz;
 	  break;
 	}
 	
@@ -182,35 +196,41 @@
 	if (!flag_left) {
 	  if (flag_dot) {
 	    vs=preci>sz?preci:sz;
-	    len+=write_pad(fn,(signed int)width-(signed int)vs,' ');
+	    if (write_pad(&len,fn,(signed int)width-(signed int)vs,' '))
+	      return -1;
 	    if (todo) {
-	      A_WRITE(fn,sign,todo);
+	      B_WRITE(fn,sign,todo);
 	      len+=todo;
 	    }
-	    len+=write_pad(fn,(signed int)preci-(signed int)sz,'0');
+	    if (write_pad(&len,fn,(signed int)preci-(signed int)sz,'0'))
+	      return -1;
 	  } else {
 	    if (todo && padwith=='0') {
-	      A_WRITE(fn,sign,todo);
+	      B_WRITE(fn,sign,todo);
 	      len+=todo; todo=0;
 	    }
-	    len+=write_pad(fn,(signed int)width-(signed int)sz, padwith);
+	    if (write_pad(&len,fn,(signed int)width-(signed int)sz, padwith))
+	      return -1;
 	    if (todo) {
-	      A_WRITE(fn,sign,todo);
+	      B_WRITE(fn,sign,todo);
 	      len+=todo;
 	    }
 	  }
-	  A_WRITE(fn,s,sz); len+=sz;
+	  B_WRITE(fn,s,sz); len+=sz;
 	} else if (flag_left) {
 	  if (todo) {
-	    A_WRITE(fn,sign,todo);
+	    B_WRITE(fn,sign,todo);
 	    len+=todo;
 	  }
-	  len+=write_pad(fn,(signed int)preci-(signed int)sz, '0');
-	  A_WRITE(fn,s,sz); len+=sz;
+	  if (write_pad(&len,fn,(signed int)preci-(signed int)sz, '0'))
+	    return -1;
+	  B_WRITE(fn,s,sz); len+=sz;
 	  vs=preci>sz?preci:sz;
-	  len+=write_pad(fn,(signed int)width-(signed int)vs, ' ');
+	  if ((signed int)width-(signed int)vs<0) return -1;
+	  if (write_pad(&len,fn,(signed int)width-(signed int)vs, ' '))
+	    return -1;
 	} else {
-	  A_WRITE(fn,s,sz); len+=sz;
+	  B_WRITE(fn,s,sz); len+=sz;
 	}
 	break;
       }
@@ -264,8 +284,11 @@
 #endif
 	    number=va_arg(arg_ptr,long);
 	}
-	else
+	else {
 	  number=va_arg(arg_ptr,int);
+	  if (sizeof(int) != sizeof(long) && !flag_in_sign)
+	    number&=((unsigned int)-1);
+	}
 
 	if (flag_in_sign) {
 #ifdef WANT_LONGLONG_PRINTF
@@ -317,9 +340,9 @@
 	  if (width==0) width=1;
 	  if (!flag_dot) preci=6;
 	  if (flag_sign || d < +0.0) flag_in_sign=1;
-	  
-	  sz=__dtostr(d,s,sizeof(buf)-1,width,preci);
-	  
+
+	  sz=__dtostr(d,s,sizeof(buf)-1,width,preci,g);
+
 	  if (flag_dot) {
 	    char *tmp;
 	    if ((tmp=strchr(s,'.'))) {
@@ -366,4 +389,3 @@
 }
 
 link_warning("__v_printf","warning: the printf functions add several kilobytes of bloat.")
-
diff -urNxCVS -xdebian ../../dietlibc/lib/cfgetospeed.c ./lib/cfgetospeed.c
--- ../../dietlibc/lib/cfgetospeed.c	2002-01-29 01:40:15.000000000 +0000
+++ ./lib/cfgetospeed.c	2006-12-20 10:37:45.000000000 +0000
@@ -1,8 +1,8 @@
 #include <termios.h>
 #include <sys/types.h>
 
-speed_t cfgetospeed(struct termios *termios_p) {
+speed_t cfgetospeed(const struct termios *termios_p) {
   return ((termios_p->c_cflag & (CBAUD|CBAUDEX)));
 }
 
-speed_t cfgetispeed(struct termios *termios_p)	__attribute__((weak,alias("cfgetospeed")));
+speed_t cfgetispeed(const struct termios *termios_p)	__attribute__((weak,alias("cfgetospeed")));
diff -urNxCVS -xdebian ../../dietlibc/lib/ftw.c ./lib/ftw.c
--- ../../dietlibc/lib/ftw.c	2006-06-18 18:32:35.000000000 +0000
+++ ./lib/ftw.c	2006-10-04 15:30:11.000000000 +0000
@@ -30,7 +30,10 @@
 #endif
   if (chdir(dir)) return-1;
   cd=alloca(PATH_MAX+1);
-  if (!getcwd(cd,PATH_MAX) || !(d=opendir("."))) return -1;
+  if (!getcwd(cd,PATH_MAX) || !(d=opendir("."))) {
+    close(previous);
+    return -1;
+  }
   cd[PATH_MAX]='\0';
   cdl=strlen(cd);
 #if !defined(__dietlibc__) && !defined(__MINGW32__)
diff -urNxCVS -xdebian ../../dietlibc/lib/ftw64.c ./lib/ftw64.c
--- ../../dietlibc/lib/ftw64.c	2005-03-15 08:51:22.000000000 +0000
+++ ./lib/ftw64.c	2007-04-11 08:09:12.000000000 +0000
@@ -6,7 +6,15 @@
 #include <dirent.h>
 #include <string.h>
 #include <stdlib.h>
+#include <fcntl.h>
+
+#ifdef __dietlibc__
 #include "dietdirent.h"
+#endif
+
+#ifndef O_DIRECTORY
+#define O_DIRECTORY 0
+#endif
 
 #ifdef __NO_STAT64
 int ftw64(const char*dir,int(*f)(const char*file,const struct stat* sb,int flag),int dpth) __THROW;
@@ -21,12 +29,23 @@
   int r;
   unsigned int oldlen=0;
   char* filename = NULL;
-  if(chdir(dir))return-1;
+  int previous=open(".",O_RDONLY|O_DIRECTORY);
+#if !defined(__dietlibc__) && !defined(__MINGW32__)
+  int thisdir;
+#endif
+  if (chdir(dir)) return -1;
   cd=alloca(PATH_MAX+1);
-  if(!getcwd(cd,PATH_MAX))return-1;
+  if (!getcwd(cd,PATH_MAX) || !(d=opendir("."))) {
+    close(previous);
+    return -1;
+  }
   cd[PATH_MAX]='\0';
   cdl=strlen(cd);
-  if(!(d=opendir(".")))return-1;
+#if !defined(__dietlibc__) && !defined(__MINGW32__)
+  if ((thisdir=open(".",O_RDONLY|O_DIRECTORY))==-1) {
+    closedir(d); return -1;
+  }
+#endif
   while((de=readdir(d))){
     int flg;
     size_t nl;
@@ -41,12 +60,34 @@
       if(S_ISLNK(sb.st_mode))flg=FTW_SL;else if(S_ISDIR(sb.st_mode))flg=FTW_D;else flg=FTW_F;
     }else flg=FTW_NS;
     r=f(filename,&sb,flg);
-    if(r){closedir(d);return r;}
+    if(r){
+err:
+#if !defined(__dietlibc__) && !defined(__MINGW32__)
+      close(thisdir);
+#endif
+      closedir(d);
+      fchdir(previous);
+      close(previous);
+      return r;
+    }
     if(flg==FTW_D&&dpth){
       r=ftw(filename,f,dpth-1);
+#ifndef __dietlibc__
+#ifdef __MINGW32__
+      chdir("..");
+#else
+      fchdir(thisdir);
+#endif
+#else
       fchdir(d->fd);
-      if (r){closedir(d);return r;}
+#endif
+      if (r) goto err;
     }
   }
+  fchdir(previous);
+  close(previous);
+#if !defined(__dietlibc__) && !defined(__MINGW32__)
+  close(thisdir);
+#endif
   return closedir(d);
 }
diff -urNxCVS -xdebian ../../dietlibc/lib/if_nameindex.c ./lib/if_nameindex.c
--- ../../dietlibc/lib/if_nameindex.c	2001-11-04 23:37:25.000000000 +0000
+++ ./lib/if_nameindex.c	2006-07-04 08:54:14.000000000 +0000
@@ -8,17 +8,13 @@
 struct if_nameindex* if_nameindex(void) {
   struct ifconf ic;
   int fd,len,i;
-  struct if_nameindex* x,* y;
+  struct if_nameindex* x=0,* y;
   char *dest;
   fd=socket(AF_INET6,SOCK_DGRAM,0);
   if (fd<0) fd=socket(AF_INET,SOCK_DGRAM,0);
   ic.ifc_buf=0;
   ic.ifc_len=0;
-  if (ioctl(fd,SIOCGIFCONF,&ic)<0) {
-b0rken:
-    close(fd);
-    return 0;
-  }
+  if (ioctl(fd,SIOCGIFCONF,&ic)<0) goto b0rken;
   ic.ifc_buf=alloca((size_t)ic.ifc_len);
   if (ioctl(fd,SIOCGIFCONF,&ic)<0) goto b0rken;
   len=(ic.ifc_len/sizeof(struct ifreq));
@@ -36,5 +32,7 @@
     ++y;
   }
   y->if_name=0; y->if_index=0;
+b0rken:
+  close(fd);
   return x;
 }
diff -urNxCVS -xdebian ../../dietlibc/lib/if_nametoindex.c ./lib/if_nametoindex.c
--- ../../dietlibc/lib/if_nametoindex.c	2001-06-15 16:14:50.000000000 +0000
+++ ./lib/if_nametoindex.c	2006-07-04 08:54:14.000000000 +0000
@@ -10,6 +10,7 @@
 unsigned int if_nametoindex(const char* blub) {
   struct ifreq ifr;
   int fd;
+  int ret=0;
   char *tmp;
   int len=sizeof(ifr.ifr_name);
   fd=socket(AF_INET6,SOCK_DGRAM,0);
@@ -17,10 +18,8 @@
   for (tmp=ifr.ifr_name; len>0; --len) {
     if ((*tmp++=*blub++)==0) break;
   }
-  if (ioctl(fd,SIOCGIFINDEX,&ifr)==0) {
-    close(fd);
-    return ifr.ifr_ifindex;
-  }
+  if (ioctl(fd,SIOCGIFINDEX,&ifr)==0)
+    ret=ifr.ifr_ifindex;
   close(fd);
-  return 0;
+  return ret;
 }
diff -urNxCVS -xdebian ../../dietlibc/lib/putenv.c ./lib/putenv.c
--- ../../dietlibc/lib/putenv.c	2006-02-19 15:38:28.000000000 +0000
+++ ./lib/putenv.c	2007-01-22 16:32:44.000000000 +0000
@@ -15,9 +15,11 @@
     len=strlen(string);
     remove=1;
   } else
-    len=tmp-string+1;
+    len=tmp-string;
   for (envc=0, ep=(const char**)environ; (ep && *ep); ++ep) {
-    if (*string == **ep && !memcmp(string,*ep,len)) {
+    if (*string == **ep &&
+	!memcmp(string,*ep,len) &&
+	(*ep)[len]=='=') {
       if (remove) {
 	for (; ep[1]; ++ep) ep[0]=ep[1];
 	ep[0]=0;
diff -urNxCVS -xdebian ../../dietlibc/lib/qsort.c ./lib/qsort.c
--- ../../dietlibc/lib/qsort.c	2004-06-03 11:36:47.000000000 +0000
+++ ./lib/qsort.c	2006-08-21 14:15:15.000000000 +0000
@@ -1,164 +1,50 @@
 #include <sys/cdefs.h>
 #include <stdlib.h>
-#include <assert.h>
 
-/* comments:
-     1. insertion sort sofort, nicht nachträglich
-     2. threshold = 16
- */
-
-static inline void iswap(void *a,void *b,size_t size) {
-  register char *x=a;
-  register char *y=b;
-  register char *z=x+size;
-  while (x<z) {
-    register char tmp=*x;
+static void exch(char* base,size_t size,size_t a,size_t b) {
+  char* x=base+a*size;
+  char* y=base+b*size;
+  while (size) {
+    char z=*x;
     *x=*y;
-    *y=tmp;
-    ++x; ++y;
-  }
-}
-
-static inline void swap(void *base,size_t size,size_t a,size_t b) {
-  iswap((char*)base+a*size,(char*)base+b*size,size);
-}
-
-#if 0
-extern int array[];
-
-void dumparray() {
-  printf("array now {%d,%d,%d,%d,%d}\n",array[0],array[1],array[2],array[3],array[4]);
-}
-#endif
-
-void isort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
-void isort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)) {
-  size_t i;
-  while (__likely(nmemb>1)) {
-    char *min=base;
-    char *tmp=min+size;
-    for (i=1; i<nmemb; ++i) {
-      if (__unlikely(compar(tmp,min)<0))
-	min=tmp;
-      tmp+=size;
-    }
-    iswap(min,base,size);
-    base=(void*)((char*)base+size);
-    nmemb-=1;
+    *y=z;
+    --size; ++x; ++y;
   }
 }
 
-#if OLD_AND_SLOW_FOR_MAKE
-void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)) {
-#ifdef DEBUG
-  char *dbase=base;
-  char *dmax=base+(nmemb-1)*size;
-  char dmemb=nmemb;
-#endif
-//  static int level=0;
-  char* v;	/* pivot */
-  char* mid, *max, *min;
-  size_t lmemb;
-
-#if 0
-  int left,right;
-  left=(int*)base-array;
-  right=left+nmemb-1;
-  ++level;
-  { int i; for (i=0; i<level; ++i) printf("  "); }
-  printf("qsort: level %d; base=%p, %dx%d; array[%d..%d]\n",level,base,nmemb,size,left,right);
-  assert(left>=0 && right<=1000);
-#endif
-  if (nmemb<=8) {
-//    --level;
-    return isort(base,nmemb,size,compar);
-  }
-  {
-    mid=(char*)base+(nmemb/2)*size;
-    max=(char*)base+(nmemb-1)*size;
-
-    if (compar(base,max)<0)	/* a[left] < a[right] */
-      if (compar(base,mid)<0)	/* a[left] < a[med] */
-	if (compar(max,mid)<0)	/* a[left] < a[right] < a[med] */
-	  v=max;
-	else			/* a[left] < a[med] < a[right] */
-	  v=mid;
-      else			/* a[med] < a[left] < a[right] */
-	v=base;
-    else			/* a[right] < a[left] */
-      if (compar(base,mid)<0)	/* a[right] < a[left] < a[med] */
-	v=base;
-      else			/* a[right] < a[left] && a[med] < a[left] */
-	if (compar(max,mid)<0)	/* a[right] < a[med] < a[left] */
-	  v=mid;
-	else
-	  v=max;
-//    printf("%d %d %d -> median %d\n",*(int*)base,*(int*)mid,*(int*)max,*(int*)v);
-  }
-  if (v != max)
-    iswap(v,max,size);
-  v=max;
-  min=base; lmemb=0;
+/* Quicksort with 3-way partitioning, ala Sedgewick */
+/* Blame him for the scary variable names */
+/* http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf */
+static void quicksort(char* base,size_t size,ssize_t l,ssize_t r,
+		      int (*compar)(const void*,const void*)) {
+  ssize_t i=l-1, j=r, p=l-1, q=r, k;
+  char* v=base+r*size;
+  if (r<=l) return;
   for (;;) {
-    while (__likely(compar(min,v)<0)) { min+=size; ++lmemb; }
-    while (__likely(compar(max-=size,v)>0)) ;
-    if (min>=max) break;
-    iswap(min,max,size);
+    while (compar(base+(++i)*size,v)<0) ;
+    while (compar(v,base+(--j)*size)<0) if (j == l) break;
+    if (i >= j) break;
+    exch(base,size,i,j);
+    if (compar(base+i*size,v)==0) exch(base,size,++p,i);
+    if (compar(v,base+j*size)==0) exch(base,size,j,--q);
+  }
+  exch(base,size,i,r); j = i-1; ++i;
+  for (k=l; k<p; k++, j--) exch(base,size,k,j);
+  for (k=r-1; k>q; k--, i++) exch(base,size,i,k);
+  quicksort(base,size,l,j,compar);
+  quicksort(base,size,i,r,compar);
+}
+
+void qsort(void* base,size_t nmemb,size_t size,int (*compar)(const void*,const void*)) {
+  /* check for integer overflows */
+  if (nmemb >= (((size_t)-1)>>1) ||
+      size >= (((size_t)-1)>>1)) return;
+#if 0
+  if (sizeof(size_t) < sizeof(unsigned long long)) {
+    if ((unsigned long long)size * nmemb > (size_t)-1) return;
+  } else {
+    if (size*nmemb/nmemb != size) return;
   }
-  iswap(min,v,size);
-#ifdef DEBUG
-//    { int i; for (i=0; i<level; ++i) printf("  "); }
-//    printf("-=< base=%p, min=%p, nmemb=%d, lmemb=%d (%d)\n",base,min,nmemb,lmemb,(min-(char*)base)/size);
-    assert(lmemb==((min-(char*)base)/size));
-#endif
-  if (min>(char*)base+size) {
-#ifdef DEBUG
-    assert(base==dbase);
 #endif
-//    { int i; for (i=0; i<level; ++i) printf("  "); }
-//    printf("+-left %d [%d..%d] of [%d..%d]\n",level+1,left,left+lmemb,left,right);
-    qsort(base,lmemb,size,compar);
-  }
-  if (nmemb>lmemb+1) {
-//    { int i; for (i=0; i<level; ++i) printf("  "); }
-//    printf("+-right %d [%d..%d] of [%d..%d]\n",level+1,left+lmemb,right,left,right);
-    qsort(min+size,nmemb-lmemb-1,size,compar);
-  }
-//  --level;
-}
-#else
-
-static inline char* idx(void* base,size_t size,size_t x) {
-  return ((char*)base)+x*size;
+  quicksort(base,size,0,nmemb-1,compar);
 }
-
-static void Qsort(void *base, size_t nmemb, size_t size,long l,long r,
-		  int (*compar)(const void *, const void *)) {
-  long i,j,k,p,q;
-  char* v;
-  if (r-l<10) {
-    isort(idx(base,size,l),r-l+1,size,compar);
-    return;
-  }
-  v=idx(base,size,r);
-  i=l-1; j=r; p=l-1; q=r;
-  for (;;) {
-    while (compar(idx(base,size,++i),v)<0) ;
-    while (compar(idx(base,size,--j),v)>0) if (j==l) break;
-    if (i>=j) break;
-    swap(base,size,i,j);
-    if (compar(idx(base,size,i),v)==0) { ++p; swap(base,size,p,i); }
-    if (compar(idx(base,size,j),v)==0) { --q; swap(base,size,q,j); }
-  }
-  swap(base,size,i,r); j=i-1; ++i;
-  for (k=l; k<p; ++k,--j) swap(base,size,k,j);
-  for (k=r-1; k>q; --k,++i) swap(base,size,k,i);
-  if (j>l) Qsort(base,nmemb,size,l,j,compar);
-  if (r>i) Qsort(base,nmemb,size,i,r,compar);
-}
-
-void qsort(void *base, size_t nmemb, size_t size,
-	   int (*compar)(const void *, const void *)) {
-  Qsort(base,nmemb,size,0,nmemb-1,compar);
-}
-#endif
diff -urNxCVS -xdebian ../../dietlibc/lib/stackgap.c ./lib/stackgap.c
--- ../../dietlibc/lib/stackgap.c	2006-04-04 05:35:14.000000000 +0000
+++ ./lib/stackgap.c	2006-10-30 15:28:32.000000000 +0000
@@ -2,14 +2,50 @@
 #include <fcntl.h>
 #include <alloca.h>
 #include <sys/time.h>
+#include <sys/tls.h>
 #include "dietfeatures.h"
 
 extern int main(int argc,char* argv[],char* envp[]);
 
-#ifdef WANT_SSP
+#if defined(WANT_SSP)
 extern unsigned long __guard;
 #endif
 
+#if defined(WANT_SSP) || defined(WANT_THREAD_SAFE)
+static tcbhead_t mainthread;
+
+static void setup_tls(void) {
+#if defined(__x86_64__)
+
+  mainthread.tcb=&mainthread;
+  mainthread.self=&mainthread;
+#if defined(WANT_SSP)
+  mainthread.stack_guard=__guard;
+#endif
+  arch_prctl(ARCH_SET_FS, &mainthread);
+
+#elif defined(__i386__)
+
+  static unsigned int sd[4];
+  mainthread.tcb=&mainthread;
+  mainthread.self=&mainthread;
+#if defined(WANT_SSP)
+  mainthread.stack_guard=__guard;
+#endif
+  sd[0]=-1;
+  sd[1]=(unsigned long int)&mainthread;
+  sd[2]=0xfffff; /* 4 GB limit */
+  sd[3]=0x51; /* bitfield, see struct user_desc in asm-i386/ldt.h */
+  if (set_thread_area(&sd)==0) {
+    asm volatile ("movw %w0, %%gs" :: "q" (sd[0]*8+3));
+  }
+
+#else
+#warning "no idea how to enable TLS on this platform, edit lib/stackgap.c"
+#endif
+}
+#endif
+
 int stackgap(int argc,char* argv[],char* envp[]);
 int stackgap(int argc,char* argv[],char* envp[]) {
 #ifdef WANT_SSP_XOR
@@ -34,6 +70,10 @@
   gettimeofday (&tv, NULL);
   __guard ^= tv.tv_usec ^ tv.tv_sec ^ getpid();
 #endif
+
+#if defined(WANT_SSP) || defined(WANT_THREAD_SAFE)
+  setup_tls();
+#endif
   return main(argc,argv,envp);
 }
 
diff -urNxCVS -xdebian ../../dietlibc/libcompat/getdelim.c ./libcompat/getdelim.c
--- ../../dietlibc/libcompat/getdelim.c	2003-08-23 16:55:05.000000000 +0000
+++ ./libcompat/getdelim.c	2006-12-20 10:37:45.000000000 +0000
@@ -13,17 +13,18 @@
   }
   if (!*lineptr) *n=0;
   for (i=0; ; ) {
-    int x=fgetc(stream);
+    int x;
     if (i>=*n) {
       int tmp=*n+100;
       char* new=realloc(*lineptr,tmp);
       if (!new) return -1;
       *lineptr=new; *n=tmp;
     }
+    x=fgetc(stream);
     if (x==EOF) { if (!i) return -1; (*lineptr)[i]=0; return i; }
     (*lineptr)[i]=x;
     ++i;
-    if (x==delim) break;
+    if (x==delim || i>=*n) break;
   }
   (*lineptr)[i]=0;
   return i;
diff -urNxCVS -xdebian ../../dietlibc/libcompat/getline.c ./libcompat/getline.c
--- ../../dietlibc/libcompat/getline.c	2003-08-23 16:50:54.000000000 +0000
+++ ./libcompat/getline.c	2006-12-20 10:37:45.000000000 +0000
@@ -1,5 +1,6 @@
 #define _GNU_SOURCE
 #include <stdio.h>
+#include <sys/types.h>
 #include "dietwarning.h"
 
 ssize_t getline(char **lineptr, size_t *n, FILE *stream) {
diff -urNxCVS -xdebian ../../dietlibc/libcruft/dn_skipname.c ./libcruft/dn_skipname.c
--- ../../dietlibc/libcruft/dn_skipname.c	1970-01-01 00:00:00.000000000 +0000
+++ ./libcruft/dn_skipname.c	2007-04-11 08:09:12.000000000 +0000
@@ -0,0 +1,19 @@
+#include <resolv.h>
+
+int dn_skipname(const unsigned char* cur,const unsigned char* eom) {
+  const unsigned char* orig=cur;
+  while (cur<eom) {
+    if ((*cur&0xc)==0xc) { /* compression */
+      if (cur+1<eom)
+	return cur-orig+2;
+      else
+	return -1;
+    } else
+      if (*cur==0) return cur-orig+1;
+      if (cur+*cur+1<eom)
+	cur+=*cur+1;
+      else
+	return -1;
+  }
+  return -1;
+}
diff -urNxCVS -xdebian ../../dietlibc/libcruft/dnscruft.c ./libcruft/dnscruft.c
--- ../../dietlibc/libcruft/dnscruft.c	2006-06-18 18:32:35.000000000 +0000
+++ ./libcruft/dnscruft.c	2006-10-30 15:28:32.000000000 +0000
@@ -45,9 +45,8 @@
   tmp=socket(PF_INET6,SOCK_DGRAM,IPPROTO_UDP);
   if (tmp<0) return;
   fcntl(tmp,F_SETFD,FD_CLOEXEC);
+  memset(&si,0,sizeof(si));
   si.sin6_family=AF_INET6;
-  si.sin6_port=0;
-  memset(&si.sin6_addr,0,16);
   if (bind(tmp,(struct sockaddr*)&si,sizeof(si))) return;
   __dns_fd6=tmp;
 }
diff -urNxCVS -xdebian ../../dietlibc/libcruft/dnscruft2.c ./libcruft/dnscruft2.c
--- ../../dietlibc/libcruft/dnscruft2.c	2005-05-01 20:08:25.000000000 +0000
+++ ./libcruft/dnscruft2.c	2006-10-30 15:28:32.000000000 +0000
@@ -5,7 +5,6 @@
 #include <netdb.h>
 #include <stdlib.h>
 #include <arpa/inet.h>
-#include <sys/poll.h>
 #include <unistd.h>
 #include <errno.h>
 #include <arpa/nameser.h>
diff -urNxCVS -xdebian ../../dietlibc/libcruft/getopt_long.c ./libcruft/getopt_long.c
--- ../../dietlibc/libcruft/getopt_long.c	2005-10-21 19:02:19.000000000 +0000
+++ ./libcruft/getopt_long.c	2006-07-04 08:54:14.000000000 +0000
@@ -36,33 +36,46 @@
     char* arg=argv[optind]+2;
     char* max=strchr(arg,'=');
     const struct option* o;
+    const struct option* match=0;
     if (!max) max=arg+strlen(arg);
     for (o=longopts; o->name; ++o) {
-      if (!strncmp(o->name,arg,(size_t)(max-arg))) {	/* match */
-	if (longindex) *longindex=o-longopts;
-	if (o->has_arg>0) {
-	  if (*max=='=')
-	    optarg=max+1;
-	  else {
-	    optarg=argv[optind+1];
-	    if (!optarg && o->has_arg==1) {	/* no argument there */
-	      if (*optstring==':') return ':';
-	      write(2,"argument required: `",20);
-	      write(2,arg,(size_t)(max-arg));
-	      write(2,"'.\n",3);
-	      ++optind;
-	      return '?';
-	    }
+      size_t tlen=max-arg;
+      if (!strncmp(o->name,arg,tlen)) {	/* match */
+	if (strlen(o->name)==tlen) {
+	  match=o;	/* perfect match, not just prefix */
+	  break;
+	}
+	if (!match)
+	  match=o;
+	else
+	  /* Another imperfect match. */
+	  match=(struct option*)-1;
+      }
+    }
+    if (match!=(struct option*)-1 && (o=match)) {
+      if (longindex) *longindex=o-longopts;
+      if (o->has_arg>0) {
+	if (*max=='=')
+	  optarg=max+1;
+	else {
+	  optarg=argv[optind+1];
+	  if (!optarg && o->has_arg==1) {	/* no argument there */
+	    if (*optstring==':') return ':';
+	    write(2,"argument required: `",20);
+	    write(2,arg,(size_t)(max-arg));
+	    write(2,"'.\n",3);
 	    ++optind;
+	    return '?';
 	  }
+	  ++optind;
 	}
-	++optind;
-	if (o->flag)
-	  *(o->flag)=o->val;
-	else
-	  return o->val;
-	return 0;
       }
+      ++optind;
+      if (o->flag)
+	*(o->flag)=o->val;
+      else
+	return o->val;
+      return 0;
     }
     if (*optstring==':') return ':';
     write(2,"invalid option `",16);
diff -urNxCVS -xdebian ../../dietlibc/libcruft/getopt_long_only.c ./libcruft/getopt_long_only.c
--- ../../dietlibc/libcruft/getopt_long_only.c	2005-07-01 12:00:30.000000000 +0000
+++ ./libcruft/getopt_long_only.c	2006-07-04 08:54:14.000000000 +0000
@@ -34,33 +34,46 @@
   {
     char* max=strchr(arg,'=');
     const struct option* o;
+    const struct option* match=0;
     if (!max) max=arg+strlen(arg);
     for (o=longopts; o->name; ++o) {
-      if (!strncmp(o->name,arg,(size_t)(max-arg))) {	/* match */
-	if (longindex) *longindex=o-longopts;
-	if (o->has_arg>0) {
-	  if (*max=='=')
-	    optarg=max+1;
-	  else {
-	    optarg=argv[optind+1];
-	    if (!optarg && o->has_arg==1) {	/* no argument there */
-	      if (*optstring==':') return ':';
-	      write(2,"argument required: `",20);
-	      write(2,arg,(size_t)(max-arg));
-	      write(2,"'.\n",3);
-	      ++optind;
-	      return '?';
-	    }
+      size_t tlen=max-arg;
+      if (!strncmp(o->name,arg,tlen)) {	/* match */
+	if (strlen(o->name)==tlen) {
+	  match=o;	/* perfect match, not just prefix */
+	  break;
+	}
+	if (!match)
+	  match=o;
+	else
+	  /* Another imperfect match. */
+	  match=(struct option*)-1;
+      }
+    }
+    if (match!=(struct option*)-1 && (o=match)) {
+      if (longindex) *longindex=o-longopts;
+      if (o->has_arg>0) {
+	if (*max=='=')
+	  optarg=max+1;
+	else {
+	  optarg=argv[optind+1];
+	  if (!optarg && o->has_arg==1) {	/* no argument there */
+	    if (*optstring==':') return ':';
+	    write(2,"argument required: `",20);
+	    write(2,arg,(size_t)(max-arg));
+	    write(2,"'.\n",3);
 	    ++optind;
+	    return '?';
 	  }
+	  ++optind;
 	}
-	++optind;
-	if (o->flag)
-	  *(o->flag)=o->val;
-	else
-	  return o->val;
-	return 0;
       }
+      ++optind;
+      if (o->flag)
+	*(o->flag)=o->val;
+      else
+	return o->val;
+      return 0;
     }
     if (argv[optind][1]!='-') goto shortopt;
     if (*optstring==':') return ':';
diff -urNxCVS -xdebian ../../dietlibc/libcruft/res_mkquery.c ./libcruft/res_mkquery.c
--- ../../dietlibc/libcruft/res_mkquery.c	2004-11-10 17:45:17.000000000 +0000
+++ ./libcruft/res_mkquery.c	2006-10-30 15:28:32.000000000 +0000
@@ -42,10 +42,14 @@
 int res_mkquery(int op, const char *dname, int class, int type, char* data,
 		int datalen, const unsigned char* newrr, char* buf, int buflen) {
   unsigned char packet[512];
-  unsigned long len=0;
-  memmove(packet,dnspacket,12);
+  unsigned long len;
+
+  memcpy(packet,dnspacket,12);
+  len=rand();
+  packet[0]=len;
+  packet[1]=len>>8;
+  len=0;
   if ((_res.options&RES_RECURSE)==0) packet[2]=0;
-  *(unsigned short*)packet=rand();
   {
     unsigned char* x;
     const char* y,* tmp;
diff -urNxCVS -xdebian ../../dietlibc/libcruft/res_query.c ./libcruft/res_query.c
--- ../../dietlibc/libcruft/res_query.c	2005-10-14 15:37:59.000000000 +0000
+++ ./libcruft/res_query.c	2006-12-11 10:01:04.000000000 +0000
@@ -70,11 +70,10 @@
 	  if (pnpfd>=0) {
 	    int one=1;
 	    fcntl(pnpfd,F_SETFD,FD_CLOEXEC);
-	    if (v4pnp) {
-	      setsockopt(pnpfd,SOL_IP,IP_RECVTTL,&one,sizeof one);
-	      setsockopt(pnpfd,SOL_IP,IP_PKTINFO,&one,sizeof one);
-	    } else
+	    if (!v4pnp)
 	      setsockopt(pnpfd,IPPROTO_IPV6,IPV6_HOPLIMIT,&one,sizeof one);
+	    setsockopt(pnpfd,SOL_IP,IP_RECVTTL,&one,sizeof one);
+	    setsockopt(pnpfd,SOL_IP,IP_PKTINFO,&one,sizeof one);
 	  }
 	}
 #ifdef WANT_IPV6_DNS
@@ -84,22 +83,19 @@
 	  if (pnpfd!=-1) bind(pnpfd,(struct sockaddr*)&pnpsa6,sizeof(pnpsa6));
 	  pnpsa6.sin6_port=htons(5353);
 	  memcpy(&pnpsa6.sin6_addr,"\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfb",16);
-	} else {
-#endif
-	  memset(&pnpsa4,0,sizeof(pnpsa4));
-	  pnpsa4.sin_family=AF_INET;
-	  if (pnpfd!=-1) bind(pnpfd,(struct sockaddr*)&pnpsa4,sizeof(pnpsa4));
-	  pnpsa4.sin_port=htons(5353);
-	  memcpy(&pnpsa4.sin_addr,"\xe0\x00\x00\xfb",4);  /* 224.0.0.251 */
-#ifdef WANT_IPV6_DNS
 	}
 #endif
+	memset(&pnpsa4,0,sizeof(pnpsa4));
+	pnpsa4.sin_family=AF_INET;
+	if (pnpfd!=-1) bind(pnpfd,(struct sockaddr*)&pnpsa4,sizeof(pnpsa4));
+	pnpsa4.sin_port=htons(5353);
+	memcpy(&pnpsa4.sin_addr,"\xe0\x00\x00\xfb",4);  /* 224.0.0.251 */
 
 	duh[1].events=POLLIN;
 	duh[1].fd=pnpfd;
       } else {
 	duh[1].fd=-1;
-	duh[1].revents=0;
+	duh[1].events=0;
       }
 
 #endif
@@ -109,9 +105,8 @@
       last.tv_sec=0;
 #ifdef WANT_PLUGPLAY_DNS
       if (duh[1].fd!=-1) {
-	if (v4pnp)
-	  sendto(pnpfd,packet,size,0,(struct sockaddr*)(&pnpsa4),sizeof(pnpsa4));
-	else
+	sendto(pnpfd,packet,size,0,(struct sockaddr*)(&pnpsa4),sizeof(pnpsa4));
+	if (!v4pnp)
 	  sendto(pnpfd,packet,size,0,(struct sockaddr*)(&pnpsa6),sizeof(pnpsa6));
       }
       /* if it doesn't work, we don't care */
@@ -191,6 +186,8 @@
 	      /* as per standard, discard packets with TTL!=255 */
 	      continue;
 	    }
+	    /* work around stupid avahi bug */
+	    inpkg[2]=(inpkg[2]&~0x1) | (packet[2]&0x1);
 	  }
 #else
 	  int len=read(duh[0].fd,inpkg,sizeof(inpkg));
diff -urNxCVS -xdebian ../../dietlibc/libcruft/tempnam.c ./libcruft/tempnam.c
--- ../../dietlibc/libcruft/tempnam.c	2002-02-23 23:08:20.000000000 +0000
+++ ./libcruft/tempnam.c	2006-08-21 14:15:16.000000000 +0000
@@ -19,6 +19,7 @@
   else
     strncpy(buf,"/tmp/",len);
   len=(sizeof(buf)-1)-strlen(buf);
+  if (len<1) return 0;
   if (template)
     strncat(buf,template, --len);
   else
diff -urNxCVS -xdebian ../../dietlibc/libdl/_dl_int.h ./libdl/_dl_int.h
--- ../../dietlibc/libdl/_dl_int.h	2005-04-29 18:53:19.000000000 +0000
+++ ./libdl/_dl_int.h	2006-11-23 09:49:56.000000000 +0000
@@ -83,6 +83,7 @@
   char *	dyn_str_tab;	/* dyn_name table */
   Elf_Sym *	dyn_sym_tab;	/* dynamic symbol table */
   _dl_rel_t*	plt_rel;	/* PLT relocation table */
+  unsigned int*gnu_hash_tab;	/* GNU hash table */
 
   /* INIT / FINI */
   void (*init)(void);
@@ -108,6 +109,10 @@
 #define HASH_CHAIN_LEN(p)	(*((p)+1))
 #define HASH_CHAIN(p)		((p)+2+HASH_BUCKET_LEN(p))
 
+#define GNU_HASH_BUCKET_LEN(p)	(*((p)))
+#define GNU_HASH_BUCKET(p,n)	((p)[(n)+1])
+#define GNU_HASH_CHAIN(p,n)	((p)+(1+GNU_HASH_BUCKET_LEN(p)+(n)))
+
 /* _dl_alloc.c */
 #if 0
 extern struct _dl_handle* _dl_root_handle;
diff -urNxCVS -xdebian ../../dietlibc/libdl/_dl_main.c ./libdl/_dl_main.c
--- ../../dietlibc/libdl/_dl_main.c	2005-10-07 19:33:34.000000000 +0000
+++ ./libdl/_dl_main.c	2006-11-23 09:49:56.000000000 +0000
@@ -931,6 +931,12 @@
       pf(__FUNCTION__); pf(": have dyn_str_tab @ "); ph((long)dh->dyn_str_tab); pf("\n");
 #endif
       break;
+    case DT_GNU_HASH:
+      dh->gnu_hash_tab = (unsigned int*)(dh->mem_base+_dynamic[i].d_un.d_ptr);
+#ifdef DEBUG
+      pf(__FUNCTION__); pf(": have GNU-hash @ "); ph((long)dh->gnu_hash_tab); pf("\n");
+#endif
+      break;
 
       /* DYNAMIC INIT/FINI (constructors/destructors) */
     case DT_FINI:
diff -urNxCVS -xdebian ../../dietlibc/libdl/_dl_relocate.c ./libdl/_dl_relocate.c
--- ../../dietlibc/libdl/_dl_relocate.c	2005-05-13 12:14:06.000000000 +0000
+++ ./libdl/_dl_relocate.c	2006-11-23 09:49:56.000000000 +0000
@@ -46,7 +46,14 @@
 
 #ifdef __i386__
   if (typ==R_386_32) {			/* 1 */
-    *loc=(unsigned long)(dh->mem_base+dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+    unsigned long value=(unsigned long)(dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+#ifdef DEBUG
+    pf(__func__); pf(" value "); ph(value); pf("\n");
+#endif
+    if (value)
+      *loc=(unsigned long)(dh->mem_base+value);
+    else
+      *loc=(unsigned long)_dl_sym(dh,ELF_R_SYM(rel->r_info));
   } else if (typ==R_386_COPY)  {	/* 5 */
     unsigned long len=dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_size;
     void*from=_dl_sym_next(dh,ELF_R_SYM(rel->r_info));
@@ -66,7 +73,11 @@
 #endif
 #ifdef __arm__
   if (typ==R_ARM_ABS32) {		/*  2 */
-    *loc=(unsigned long)(dh->mem_base+dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+    unsigned long value=(unsigned long)(dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+    if (value)
+      *loc=(unsigned long)(dh->mem_base+value);
+    else
+      *loc=(unsigned long)_dl_sym(dh,ELF_R_SYM(rel->r_info));
   } else if (typ==R_ARM_COPY)  {	/* 20 */
     unsigned long len=dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_size;
     void*from=_dl_sym_next(dh,ELF_R_SYM(rel->r_info));
@@ -86,7 +97,11 @@
 #endif
 #ifdef __x86_64__
   if (typ==R_X86_64_64) {			/* 1 */
-    *loc=(unsigned long)(dh->mem_base+dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+    unsigned long value=(unsigned long)(dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+    if (value)
+      *loc=(unsigned long)(dh->mem_base+value);
+    else
+      *loc=(unsigned long)_dl_sym(dh,ELF_R_SYM(rel->r_info));
   } else if (typ==R_X86_64_COPY)  {	/* 5 */
     unsigned long len=dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_size;
     void*from=_dl_sym_next(dh,ELF_R_SYM(rel->r_info));
diff -urNxCVS -xdebian ../../dietlibc/libdl/dlsym.c ./libdl/dlsym.c
--- ../../dietlibc/libdl/dlsym.c	2005-10-07 19:33:34.000000000 +0000
+++ ./libdl/dlsym.c	2006-11-23 09:49:56.000000000 +0000
@@ -1,52 +1,93 @@
 #include "_dl_int.h"
 
 #include "elf_hash.h"
+#include "gnu_hash.h"
 
-#ifdef __DIET_LD_SO__
-static
-#endif
-void *_dlsym(void* handle,const unsigned char* symbol) {
+static void*_dlsym_elfhash(struct _dl_handle*dh,const unsigned char*symbol) {
   unsigned long*sym=0;
-  if (handle) {
-    struct _dl_handle*dh=(struct _dl_handle*)handle;
-    unsigned int hash =elf_hash(symbol);
-    unsigned int bhash=hash%HASH_BUCKET_LEN(dh->hash_tab);
-    unsigned int*chain=HASH_CHAIN(dh->hash_tab);
-    unsigned int ind;
-    unsigned char*name=(unsigned char*)dh->dyn_str_tab;
+  unsigned int hash =elf_hash(symbol);
+  unsigned int bhash=hash%HASH_BUCKET_LEN(dh->hash_tab);
+  unsigned int*chain=HASH_CHAIN(dh->hash_tab);
+  unsigned char*name=(unsigned char*)dh->dyn_str_tab;
+  unsigned int ind=HASH_BUCKET(dh->hash_tab)[bhash];
 
 #ifdef DEBUG
-//    pf(__FUNCTION__); pf(": bucket("); ph(bhash); pf(",\""); pf(symbol); pf("\")\n");
+//  pf(__FUNCTION__); pf(": bucket("); ph(bhash); pf(",\""); pf(symbol); pf("\")\n");
+//  pf(__FUNCTION__); pf(": chain ("); ph(ind); pf(",\""); pf(symbol); pf("\")\n");
 #endif
 
-    ind=HASH_BUCKET(dh->hash_tab)[bhash];
+  while(ind) {
+    int ptr=dh->dyn_sym_tab[ind].st_name;
 #ifdef DEBUG
-//    pf(__FUNCTION__); pf(": chain ("); ph(ind); pf(",\""); pf(symbol); pf("\")\n");
+//    pf(__FUNCTION__); pf(": symbol(\""); pf(name+ptr); pf("\",\""); pf(symbol); pf("\")\n");
 #endif
-
-    while(ind) {
-      int ptr=dh->dyn_sym_tab[ind].st_name;
+    if (_dl_lib_strcmp(name+ptr,symbol)==0 && dh->dyn_sym_tab[ind].st_value!=0) {
+      if (dh->dyn_sym_tab[ind].st_shndx!=SHN_UNDEF) {
+	sym=(unsigned long*)(dh->mem_base+dh->dyn_sym_tab[ind].st_value);
+	break;	/* ok found ... */
+      }
+    }
+    ind=chain[ind];
+  }
 #ifdef DEBUG
-//      pf(__FUNCTION__); pf(": symbol(\""); pf(name+ptr); pf("\",\""); pf(symbol); pf("\")\n");
+  pf(__FUNCTION__); pf(": symbol \""); pf(symbol); pf("\" @ "); ph((long)sym); pf("\n");
 #endif
-      if (_dl_lib_strcmp(name+ptr,symbol)==0 && dh->dyn_sym_tab[ind].st_value!=0) {
-	if (dh->dyn_sym_tab[ind].st_shndx!=SHN_UNDEF) {
-	  sym=(unsigned long*)(dh->mem_base+dh->dyn_sym_tab[ind].st_value);
-	  break;	/* ok found ... */
+  return sym;
+}
+static void*_dlsym_gnuhash(struct _dl_handle*dh,const unsigned char*symbol) {
+  unsigned long*sym=0;
+  unsigned char*name=(unsigned char*)dh->dyn_str_tab;
+  unsigned int hash =gnu_hash(symbol);
+  unsigned int bhash=hash%GNU_HASH_BUCKET_LEN(dh->gnu_hash_tab);
+  unsigned int ind  =GNU_HASH_BUCKET(dh->gnu_hash_tab,bhash);
+#ifdef DEBUG
+  //pf(__FUNCTION__); pf(": bucket("); ph(bhash); pf(",\""); pf(symbol); pf("\")\n");
+  //pf(__FUNCTION__); pf(": chain ("); ph(ind); pf(",\""); pf(symbol); pf("\")\n");
+#endif
+  if (ind!=0xffffffff) {
+    unsigned int*chain=GNU_HASH_CHAIN(dh->gnu_hash_tab,ind);
+    unsigned int idx=chain[0];
+    unsigned int i,nr=chain[1];
+    chain+=2;
+    for (i=0;i<nr;++i) {
+      if (chain[i]==hash) {
+	unsigned int ptr=dh->dyn_sym_tab[idx+i].st_name;
+#ifdef DEBUG
+	//pf(__FUNCTION__); pf(": symbol(\""); pf(name+ptr); pf("\",\""); pf(symbol); pf("\")\n");
+#endif
+	if (_dl_lib_strcmp(name+ptr,symbol)==0 && dh->dyn_sym_tab[idx+i].st_value!=0) {
+	  if (dh->dyn_sym_tab[ind].st_shndx!=SHN_UNDEF) {
+	    sym=(unsigned long*)(dh->mem_base+dh->dyn_sym_tab[idx+i].st_value);
+	    break;
+	  }
 	}
       }
-      ind=chain[ind];
     }
+  }
 #ifdef DEBUG
-    pf(__FUNCTION__); pf(": symbol \""); pf(symbol); pf("\" @ "); ph((long)sym); pf("\n");
+  pf(__FUNCTION__); pf(": symbol \""); pf(symbol); pf("\" @ "); ph((long)sym); pf("\n");
 #endif
-  }
   return sym;
 }
 
 #ifdef __DIET_LD_SO__
 static
 #endif
+void *_dlsym(void* handle,const unsigned char* symbol) {
+  if (handle) {
+    struct _dl_handle*dh=(struct _dl_handle*)handle;
+    // if the GNU hash-table is present... use it.
+    if (dh->gnu_hash_tab)
+      return _dlsym_gnuhash(dh,symbol);
+    else
+      return _dlsym_elfhash(dh,symbol);
+  }
+  return 0;
+}
+
+#ifdef __DIET_LD_SO__
+static
+#endif
 void*_dl_sym_search_str(struct _dl_handle*dh_begin,const unsigned char*name) {
   void *sym=0;
   struct _dl_handle*tmp;
diff -urNxCVS -xdebian ../../dietlibc/libdl/gnu_hash.h ./libdl/gnu_hash.h
--- ../../dietlibc/libdl/gnu_hash.h	1970-01-01 00:00:00.000000000 +0000
+++ ./libdl/gnu_hash.h	2006-11-16 10:04:00.000000000 +0000
@@ -0,0 +1,16 @@
+#ifndef __GNU_HASH_H__
+#define __GNU_HASH_H__
+
+#include <stdint.h>
+
+static uint_fast32_t gnu_hash(const unsigned char *s) {
+  unsigned char c;
+  uint_fast32_t h=5381;
+  for(c=*s;(c!='\0');c=*++s) {
+//    h=h*33+c;
+    h=((h<<5)+h)+c;
+  }
+  return (h&0xffffffff);
+}
+
+#endif
diff -urNxCVS -xdebian ../../dietlibc/libpthread/pthread_cond_timedwait.c ./libpthread/pthread_cond_timedwait.c
--- ../../dietlibc/libpthread/pthread_cond_timedwait.c	2003-08-18 17:32:52.000000000 +0000
+++ ./libpthread/pthread_cond_timedwait.c	2006-10-04 15:30:11.000000000 +0000
@@ -8,6 +8,7 @@
 		      const struct timespec*abstime) {
   _pthread_descr this=__thread_self();
   _pthread_descr*tmp;
+  int retval;
 
   if (mutex->owner!=this) return EINVAL;
 
@@ -25,7 +26,7 @@
   /* Aeh yeah / wait till condition-signal or timout (or cancel) */
   pthread_mutex_unlock(mutex);
 
-  __thread_suspend_till(this,1,abstime);
+  retval = __thread_suspend_till(this,1,abstime);
 
   pthread_mutex_lock(mutex);
 
@@ -40,7 +41,7 @@
 
   __NO_ASYNC_CANCEL_END_(this);
 
-  return 0;
+  return retval;
 }
 
 
diff -urNxCVS -xdebian ../../dietlibc/libpthread/pthread_internal.c ./libpthread/pthread_internal.c
--- ../../dietlibc/libpthread/pthread_internal.c	2004-06-07 17:05:03.000000000 +0000
+++ ./libpthread/pthread_internal.c	2006-10-04 15:30:11.000000000 +0000
@@ -204,10 +204,11 @@
 }
 
 /* suspend till timeout or restart signal / in NO_ASYNC_CANCEL */
-void __thread_suspend_till(_pthread_descr this,int cancel,const struct timespec*abstime) {
+int __thread_suspend_till(_pthread_descr this,int cancel,const struct timespec*abstime) {
   sigset_t newmask,oldmask;
   struct timeval tv;
   struct timespec reg;
+  int retval = 0;
 
   gettimeofday(&tv,0);
   reg.tv_nsec=abstime->tv_nsec-tv.tv_usec*1000;
@@ -225,9 +226,13 @@
 
   while(this->p_sig!=PTHREAD_SIG_RESTART) {
     if (cancel && (this->cancelstate==PTHREAD_CANCEL_ENABLE) && this->canceled) break;
-    if (reg.tv_sec<0||__libc_nanosleep(&reg,&reg)==0) break;
+    if (reg.tv_sec<0||__libc_nanosleep(&reg,&reg)==0) {
+      retval = ETIMEDOUT;
+      break;
+    }
   }
   sigprocmask(SIG_SETMASK,&oldmask,0);
+  return retval;
 }
 
 /* suspend till restart signal */
diff -urNxCVS -xdebian ../../dietlibc/libpthread/thread_internal.h ./libpthread/thread_internal.h
--- ../../dietlibc/libpthread/thread_internal.h	2005-09-21 07:33:08.000000000 +0000
+++ ./libpthread/thread_internal.h	2006-10-04 15:30:11.000000000 +0000
@@ -126,7 +126,7 @@
 
 void __thread_restart(struct _pthread_descr_struct*td);
 void __thread_suspend(struct _pthread_descr_struct*td,int cancel);
-void __thread_suspend_till(struct _pthread_descr_struct*td,int cancel,const struct timespec*abstime);
+int __thread_suspend_till(struct _pthread_descr_struct*td,int cancel,const struct timespec*abstime);
 
 void __thread_testcancel(struct _pthread_descr_struct*td);
 int __thread_setcanceltype(int type,int*oldtype,struct _pthread_descr_struct*td);
diff -urNxCVS -xdebian ../../dietlibc/librpc/clnt_simple.c ./librpc/clnt_simple.c
--- ../../dietlibc/librpc/clnt_simple.c	2003-08-19 19:34:18.000000000 +0000
+++ ./librpc/clnt_simple.c	2006-08-21 14:15:17.000000000 +0000
@@ -64,15 +64,20 @@
 	enum clnt_stat clnt_stat;
 	struct hostent *hp;
 	struct timeval timeout, tottimeout;
+	void* freeme=0;
 
 	if (crp == 0) {
 		crp = (struct callrpc_private *) calloc(1, sizeof(*crp));
 		if (crp == 0)
 			return (0);
-		callrpc_private = crp;
+		freeme = callrpc_private = crp;
 	}
 	if (crp->oldhost == NULL) {
 		crp->oldhost = malloc(256);
+		if (!crp->oldhost) {
+		  free(freeme);
+		  return 0;
+		}
 		crp->oldhost[0] = 0;
 		crp->socket = RPC_ANYSOCK;
 	}
diff -urNxCVS -xdebian ../../dietlibc/librpc/svc_auth_unix.c ./librpc/svc_auth_unix.c
--- ../../dietlibc/librpc/svc_auth_unix.c	2005-08-05 17:59:45.000000000 +0000
+++ ./librpc/svc_auth_unix.c	2006-12-06 16:01:29.000000000 +0000
@@ -67,8 +67,8 @@
 		gid_t area_gids[NGRPS];
 	} *area;
 	unsigned int auth_len;
-	int str_len, gid_len;
-	register int i;
+	unsigned int str_len, gid_len;
+	register unsigned int i;
 
 	area = (struct area *) rqst->rq_clntcred;
 	aup = &area->area_aup;
diff -urNxCVS -xdebian ../../dietlibc/libshell/dirname.c ./libshell/dirname.c
--- ../../dietlibc/libshell/dirname.c	2004-01-27 13:31:05.000000000 +0000
+++ ./libshell/dirname.c	2006-10-04 15:30:11.000000000 +0000
@@ -26,7 +26,7 @@
       continue;
     }
     if ( c!=path )
-      while ( *c==SLASH ) *c--=EOL; /* slashes in the middle */
+      while ( *c==SLASH && c>=path) *c--=EOL; /* slashes in the middle */
     else
       path[1]=EOL;                  /* slash is first symbol */
     return path;
diff -urNxCVS -xdebian ../../dietlibc/libstdio/ftell.c ./libstdio/ftell.c
--- ../../dietlibc/libstdio/ftell.c	2003-11-14 14:52:16.000000000 +0000
+++ ./libstdio/ftell.c	2007-02-06 16:34:45.000000000 +0000
@@ -4,10 +4,11 @@
 
 long ftell_unlocked(FILE *stream) {
   off_t l;
-  if (fflush_unlocked(stream)) return -1;
-  l=lseek(stream->fd,0,SEEK_CUR);
-  if (l==-1) return -1;
-  return l-stream->ungotten;
+  if (stream->flags&3 || (l=lseek(stream->fd,0,SEEK_CUR))==-1) return -1;
+  if (stream->flags&BUFINPUT)
+    return l-(stream->bs-stream->bm)-stream->ungotten;
+  else
+    return l+stream->bm;
 }
 
 long ftell(FILE *stream) __attribute__((weak,alias("ftell_unlocked")));
diff -urNxCVS -xdebian ../../dietlibc/libugly/ctime_r.c ./libugly/ctime_r.c
--- ../../dietlibc/libugly/ctime_r.c	1970-01-01 00:00:00.000000000 +0000
+++ ./libugly/ctime_r.c	2006-10-15 12:35:47.000000000 +0000
@@ -0,0 +1,5 @@
+#include <time.h>
+
+char *ctime_r(const time_t *timep, char* buf) {
+  return asctime_r(localtime(timep),buf);
+}
diff -urNxCVS -xdebian ../../dietlibc/libugly/getaddrinfo.c ./libugly/getaddrinfo.c
--- ../../dietlibc/libugly/getaddrinfo.c	2005-10-04 17:47:03.000000000 +0000
+++ ./libugly/getaddrinfo.c	2007-04-11 08:09:12.000000000 +0000
@@ -28,9 +28,10 @@
       struct hostent *H;
       int herrno=0;
       char buf[4096];
-      int lookupok=0;
+      int lookupok=0, i;
       char* interface;
       h.h_addr_list=(char**)buf+16;
+      h.h_addr_list[1]=0;
       if (node) {
 	if ((interface=strchr(node,'%'))) ++interface;
 	if (family==PF_INET6 && inet_pton(AF_INET,node,buf)) continue;
@@ -58,94 +59,82 @@
 	lookupok=1;
       }
       if (lookupok) {
-	struct ai_v6 {
-	  struct addrinfo ai;
-	  union {
-	    struct sockaddr_in6 ip6;
-	    struct sockaddr_in ip4;
-	  } ip;
-	  char name[1];
-	} *foo;
-	unsigned short port;
-	int len=sizeof(struct ai_v6)+(h.h_name?strlen(h.h_name):0);
-	if (!(foo=malloc(len))) goto error;
-	foo->ai.ai_next=0;
-	foo->ai.ai_socktype=SOCK_STREAM;
-	foo->ai.ai_protocol=IPPROTO_TCP;
-	foo->ai.ai_addrlen=family==PF_INET6?sizeof(struct sockaddr_in6):sizeof(struct sockaddr_in);
-	foo->ai.ai_addr=(struct sockaddr*)&foo->ip;
-	if (family==PF_INET6) {
-	  memset(&foo->ip,0,sizeof(foo->ip));
-	  memmove(&foo->ip.ip6.sin6_addr,h.h_addr_list[0],16);
-	  if (interface) foo->ip.ip6.sin6_scope_id=if_nametoindex(interface);
-	} else {
-	  memmove(&foo->ip.ip4.sin_addr,h.h_addr_list[0],4);
-	}
-	foo->ip.ip6.sin6_family=foo->ai.ai_family=family;
+
+	for (i=0; h.h_addr_list[i]; ++i) {
+	  struct ai_v6 {
+	    struct addrinfo ai;
+	    union {
+	      struct sockaddr_in6 ip6;
+	      struct sockaddr_in ip4;
+	    } ip;
+	    char name[1];
+	  } *foo;
+	  unsigned short port;
+	  int len;
+
+	  len=sizeof(struct ai_v6)+(h.h_name?strlen(h.h_name):0);
+
+	  if (!(foo=malloc(len))) goto error;
+	  foo->ai.ai_next=0;
+	  foo->ai.ai_addrlen=family==PF_INET6?sizeof(struct sockaddr_in6):sizeof(struct sockaddr_in);
+	  foo->ai.ai_addr=(struct sockaddr*)&foo->ip;
+	  if (family==PF_INET6) {
+	    memset(&foo->ip,0,sizeof(foo->ip));
+	    memmove(&foo->ip.ip6.sin6_addr,h.h_addr_list[i],16);
+	    if (interface) foo->ip.ip6.sin6_scope_id=if_nametoindex(interface);
+	  } else {
+	    memmove(&foo->ip.ip4.sin_addr,h.h_addr_list[i],4);
+	  }
+	  foo->ip.ip6.sin6_family=foo->ai.ai_family=family;
 #ifdef WANT_PLUGPLAY_DNS
-	if (family==AF_INET6 && node) {
-	  int l=strlen(node);
-	  if (!strcmp(node-6,".local"))
-	    foo->ip.ip6.sin6_scope_id=__dns_plugplay_interface;
-	}
+	  if (family==AF_INET6 && node) {
+	    int l=strlen(node);
+	    if (l>6 && !strcmp(node+l-6,".local"))
+	      foo->ip.ip6.sin6_scope_id=__dns_plugplay_interface;
+	  }
 #endif
-	if (h.h_name) {
-	  foo->ai.ai_canonname=foo->name;
-	  memmove(foo->name,h.h_name,strlen(h.h_name)+1);
-	} else
-	  foo->ai.ai_canonname=0;
-	if (!hints || hints->ai_socktype!=SOCK_DGRAM) {	/* TCP is OK */
-	  char *x;
-	  port=htons(strtol(service?service:"0",&x,0));
-	  if (*x) {	/* service is not numeric :-( */
-	    struct servent* se;
-	    if ((se=getservbyname(service,"tcp"))) {	/* found a service. */
-	      port=se->s_port;
-blah1:
-	      if (family==PF_INET6)
-		foo->ip.ip6.sin6_port=port;
-	      else
-		foo->ip.ip4.sin_port=port;
-	      if (!*tmp) *tmp=&(foo->ai); else (*tmp)->ai_next=&(foo->ai);
-	      if (!(foo=malloc(len))) goto error;
-	      memmove(foo,*tmp,len);
-	      tmp=&(*tmp)->ai_next;
-	      foo->ai.ai_addr=(struct sockaddr*)&foo->ip;
-	      if (foo->ai.ai_canonname)
-		foo->ai.ai_canonname=foo->name;
-	    } else {
-	      freeaddrinfo(*res);
-	      return EAI_SERVICE;
+	  if (h.h_name) {
+	    foo->ai.ai_canonname=foo->name;
+	    memmove(foo->name,h.h_name,strlen(h.h_name)+1);
+	  } else
+	    foo->ai.ai_canonname=0;
+
+	  for (foo->ai.ai_socktype=SOCK_STREAM; ; foo->ai.ai_socktype=SOCK_DGRAM) {
+	    char* type,* x;
+	    if (foo->ai.ai_socktype==SOCK_STREAM) {	/* TCP */
+	      if (hints->ai_socktype==SOCK_DGRAM) continue;
+	      foo->ai.ai_protocol=IPPROTO_TCP;
+	      type="tcp";
+	    } else {	/* UDP */
+	      if (hints->ai_socktype==SOCK_STREAM) break;
+	      foo->ai.ai_protocol=IPPROTO_UDP;
+	      type="udp";
 	    }
-	  } else goto blah1;
-	}
-	foo->ai.ai_socktype=SOCK_DGRAM;
-	foo->ai.ai_protocol=IPPROTO_UDP;
-	if (!hints || hints->ai_socktype!=SOCK_STREAM) {	/* UDP is OK */
-	  char *x;
-	  port=htons(strtol(service?service:"0",&x,0));
-	  if (*x) {	/* service is not numeric :-( */
-	    struct servent* se;
-	    if ((se=getservbyname(service,"udp"))) {	/* found a service. */
-	      port=se->s_port;
-blah2:
-	      if (family==PF_INET6)
-		foo->ip.ip6.sin6_port=port;
-	      else
-		foo->ip.ip4.sin_port=port;
-	      if (!*tmp) *tmp=&(foo->ai); else (*tmp)->ai_next=&(foo->ai);
-	      if (!(foo=malloc(len))) goto error;
-	      memmove(foo,*tmp,len);
-	      tmp=&(*tmp)->ai_next;
-	      foo->ai.ai_addr=(struct sockaddr*)&foo->ip;
-	      foo->ai.ai_canonname=foo->name;
-	    } else {
-	      freeaddrinfo(*res);
-	      return EAI_SERVICE;
+	    port=htons(strtol(service?service:"0",&x,0));
+	    if (*x) {	/* service is not numeric :-( */
+	      struct servent* se;
+	      if ((se=getservbyname(service,type)))
+		port=se->s_port;
+	      else {
+		freeaddrinfo(*res);
+		return EAI_SERVICE;
+	      }
 	    }
-	  } else goto blah2;
+	    if (family==PF_INET6)
+	      foo->ip.ip6.sin6_port=port;
+	    else
+	      foo->ip.ip4.sin_port=port;
+	    if (!*tmp) *tmp=&(foo->ai); else (*tmp)->ai_next=&(foo->ai);
+	    if (!(foo=malloc(len))) goto error;
+	    memmove(foo,*tmp,len);
+	    tmp=&(*tmp)->ai_next;
+	    foo->ai.ai_addr=(struct sockaddr*)&foo->ip;
+	    if (foo->ai.ai_canonname)
+	      foo->ai.ai_canonname=foo->name;
+	    if (foo->ai.ai_socktype==SOCK_DGRAM) break;
+	  }
+	  free(foo);
 	}
-	free(foo);
       }
     }
     if (family==PF_INET) break;
diff -urNxCVS -xdebian ../../dietlibc/libugly/iconv.c ./libugly/iconv.c
--- ../../dietlibc/libugly/iconv.c	2005-04-10 13:59:32.000000000 +0000
+++ ./libugly/iconv.c	2007-04-11 08:09:12.000000000 +0000
@@ -91,7 +91,6 @@
       if (*outbytesleft<1) goto bloat;
       if (v>0xff) ++result;
       *out=(unsigned char)v;
-      ++j;
       break;
     case UCS_2:
       if (*outbytesleft<2) goto bloat;
diff -urNxCVS -xdebian ../../dietlibc/libugly/strftime.c ./libugly/strftime.c
--- ../../dietlibc/libugly/strftime.c	2006-02-14 07:00:05.000000000 +0000
+++ ./libugly/strftime.c	2006-08-21 14:15:17.000000000 +0000
@@ -36,6 +36,7 @@
     unsigned long no;
     char          buf [5];
 
+    if (!max) return 0;
     for ( ; *format != '\0'; format++ ) {
 	if (*format == '%') {
 	    if (*++format == '%') {
diff -urNxCVS -xdebian ../../dietlibc/libugly/strndup.c ./libugly/strndup.c
--- ../../dietlibc/libugly/strndup.c	2003-08-19 21:40:28.000000000 +0000
+++ ./libugly/strndup.c	2006-08-21 14:15:17.000000000 +0000
@@ -2,9 +2,16 @@
 /* *puke* */
 #include <string.h>
 #include <stdlib.h>
+#include "dietfeatures.h"
 
 char *strndup(const char *s,size_t n) {
+  /* This relies on the fact that our malloc(0) returns NULL.
+   * Otherwise this would be an exploitable integer overflow! */
+#ifdef WANT_MALLOC_ZERO
+  char *tmp=!(n+1)?0:(char *)malloc(n+1);
+#else
   char *tmp=(char *)malloc(n+1);
+#endif
   if (!tmp) return 0;
   strncpy(tmp,s,n);
   tmp[n]=0;
diff -urNxCVS -xdebian ../../dietlibc/libugly/strptime.c ./libugly/strptime.c
--- ../../dietlibc/libugly/strptime.c	2005-08-10 11:15:02.000000000 +0000
+++ ./libugly/strptime.c	2007-04-11 08:09:12.000000000 +0000
@@ -3,6 +3,8 @@
 #include <string.h>
 #include <strings.h>
 
+extern const short  __spm [];
+
 static const char*  months [12] = { 
     "January", "February", "March", "April", "May", "June",
     "July", "August", "September", "October", "November", "December"
@@ -22,6 +24,7 @@
 
 char* strptime(const char* s,const char* format, struct tm* tm) {
   int i,j;
+  register time_t  day;
   while (*format) {
     switch (*format) {
     case ' ': case '\t':
@@ -32,7 +35,7 @@
     case '%':
       ++format;
       switch (*format) {
-      case '%': if (*s=='%') ++s; else return (char*)s; break;
+      case '%': if (*s=='%') ++s; else return 0; break;
       case 'a': case 'A': /* weekday; we just skip */
 	for (i=0; i<3; ++i)
 	  if (isalpha(*s)) ++s;
@@ -44,7 +47,7 @@
 	      j=0;
 	  if (j) break;
 	}
-	if (!j) return (char*)s;
+	if (!j) return 0;
 	s+=j;
 	tm->tm_mon=i;
 	break;
@@ -53,12 +56,12 @@
 	break;
       case 'C':
 	i=getint(&s,2);
-	if (i==-1) return (char*)s;
+	if (i==-1) return 0;
 	tm->tm_year=(tm->tm_year%100)+(i*100);
 	break;
       case 'd': case 'e':
 	i=getint(&s,2);
-	if (i==-1 || i>31) return (char*)s;
+	if (i==-1 || i>31) return 0;
 	tm->tm_mday=i;
 	break;
       case 'D':
@@ -66,12 +69,12 @@
 	break;
       case 'H': case 'k':
 	i=getint(&s,2);
-	if (i==-1 || i>23) return (char*)s;
+	if (i==-1 || i>23) return 0;
 	tm->tm_hour=i;
 	break;
       case 'I': case 'l':
 	i=getint(&s,2);
-	if (i==-1 || i>12) return (char*)s;
+	if (i==-1 || i>12) return 0;
 	tm->tm_hour=(tm->tm_hour/12)*12+i;
 	break;
       case 'j':
@@ -79,12 +82,12 @@
 	break;
       case 'm':
 	i=getint(&s,2);
-	if (i<=0 || i>12) return (char*)s;
+	if (i<=0 || i>12) return 0;
 	tm->tm_mon=i-1;
 	break;
       case 'M':
 	i=getint(&s,2);
-	if (i==-1 || i>59) return (char*)s;
+	if (i==-1 || i>59) return 0;
 	tm->tm_min=i;
 	break;
       case 'n': case 't':
@@ -102,17 +105,17 @@
 	break;
       case 'S':
 	i=getint(&s,2);
-	if (i==-1 || i>60) return (char*)s;
+	if (i==-1 || i>60) return 0;
 	tm->tm_sec=i;
 	break;
       case 'T':
 	s=strptime(s,"%H:%M:%S",tm);
 	break;
       case 'U': case 'W':
-	if (getint(&s,2)==-1) return (char*)s;
+	if (getint(&s,2)==-1) return 0;
 	break;
       case 'w':
-	if (*s<'0' || *s>'6') return (char*)s;
+	if (*s<'0' || *s>'6') return 0;
 	++s;
 	break;
       case 'x':
@@ -123,22 +126,27 @@
 	break;
       case 'y':
 	i=getint(&s,2);
-	if (i<0) return (char*)s;
+	if (i<0) return 0;
 	tm->tm_year=(i<69)?i+100:i;
 	break;
       case 'Y':
 	i=getint(&s,5);
-	if (i==-1) return (char*)s;
+	if (i==-1) return 0;
 	tm->tm_year=i-1900;
 	break;
       }
       ++format;
       break;
     default:
-      if (*s != *format) return (char*)s;
+      if (*s != *format) return 0;
       ++format; ++s;
       break;
-      }
+    }
   }
+ 
+  day  = (tm->tm_year - 70) * 365 + (tm->tm_year - 69) / 4;
+  day += tm->tm_yday = __spm [tm->tm_mon] + tm->tm_mday-1 + (__isleap (tm->tm_year+1900) & (tm->tm_mon > 1));
+  tm->tm_wday = (day + 4) % 7;
+
   return (char*)s;
 }
diff -urNxCVS -xdebian ../../dietlibc/libugly/strsignal.c ./libugly/strsignal.c
--- ../../dietlibc/libugly/strsignal.c	2002-09-25 15:03:19.000000000 +0000
+++ ./libugly/strsignal.c	2006-08-21 14:15:17.000000000 +0000
@@ -3,7 +3,7 @@
 #include <signal.h>
 
 const char* strsignal(int sig) {
-  if (sig<=SIGRTMAX)
+  if ((unsigned int)sig<=SIGRTMAX)
     return sys_siglist[sig];
   else
     return "(unknown signal)";
diff -urNxCVS -xdebian ../../dietlibc/mips/syscalls.h ./mips/syscalls.h
--- ../../dietlibc/mips/syscalls.h	2005-03-23 19:05:25.000000000 +0000
+++ ./mips/syscalls.h	2006-10-04 15:30:11.000000000 +0000
@@ -286,6 +286,32 @@
 #define __NR_add_key			(__NR_Linux + 280)
 #define __NR_request_key		(__NR_Linux + 281)
 #define __NR_keyctl			(__NR_Linux + 282)
+#define __NR_set_thread_area		(__NR_Linux + 283)
+#define __NR_inotify_init		(__NR_Linux + 284)
+#define __NR_inotify_add_watch		(__NR_Linux + 285)
+#define __NR_inotify_rm_watch		(__NR_Linux + 286)
+#define __NR_migrate_pages		(__NR_Linux + 287)
+#define __NR_openat			(__NR_Linux + 288)
+#define __NR_mkdirat			(__NR_Linux + 289)
+#define __NR_mknodat			(__NR_Linux + 290)
+#define __NR_fchownat			(__NR_Linux + 291)
+#define __NR_futimesat			(__NR_Linux + 292)
+#define __NR_fstatat			(__NR_Linux + 293)
+#define __NR_unlinkat			(__NR_Linux + 294)
+#define __NR_renameat			(__NR_Linux + 295)
+#define __NR_linkat			(__NR_Linux + 296)
+#define __NR_symlinkat			(__NR_Linux + 297)
+#define __NR_readlinkat			(__NR_Linux + 298)
+#define __NR_fchmodat			(__NR_Linux + 299)
+#define __NR_faccessat			(__NR_Linux + 300)
+#define __NR_pselect6			(__NR_Linux + 301)
+#define __NR_ppoll			(__NR_Linux + 302)
+#define __NR_unshare			(__NR_Linux + 303)
+#define __NR_splice			(__NR_Linux + 304)
+#define __NR_sync_file_range		(__NR_Linux + 305)
+#define __NR_tee			(__NR_Linux + 306)
+#define __NR_vmsplice			(__NR_Linux + 307)
+#define __NR_move_pages			(__NR_Linux + 308)
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff -urNxCVS -xdebian ../../dietlibc/ppc/syscalls.h ./ppc/syscalls.h
--- ../../dietlibc/ppc/syscalls.h	2005-09-21 07:33:08.000000000 +0000
+++ ./ppc/syscalls.h	2006-10-04 15:30:11.000000000 +0000
@@ -276,6 +276,29 @@
 #define __NR_inotify_init	275
 #define __NR_inotify_add_watch	276
 #define __NR_inotify_rm_watch	277
+#define __NR_spu_run		278
+#define __NR_spu_create		279
+#define __NR_pselect6		280
+#define __NR_ppoll		281
+#define __NR_unshare		282
+#define __NR_splice		283
+#define __NR_tee		284
+#define __NR_vmsplice		285
+#define __NR_openat		286
+#define __NR_mkdirat		287
+#define __NR_mknodat		288
+#define __NR_fchownat		289
+#define __NR_futimesat		290
+#define __NR_fstatat64		291
+#define __NR_unlinkat		292
+#define __NR_renameat		293
+#define __NR_linkat		294
+#define __NR_symlinkat		295
+#define __NR_readlinkat		296
+#define __NR_fchmodat		297
+#define __NR_faccessat		298
+#define __NR_get_robust_list	299
+#define __NR_set_robust_list	300
 
 
 #define syscall_weak(name,wsym,sym) \
diff -urNxCVS -xdebian ../../dietlibc/ppc64/syscalls.h ./ppc64/syscalls.h
--- ../../dietlibc/ppc64/syscalls.h	2005-09-21 07:33:08.000000000 +0000
+++ ./ppc64/syscalls.h	2006-10-04 15:30:11.000000000 +0000
@@ -276,6 +276,29 @@
 #define __NR_inotify_init	275
 #define __NR_inotify_add_watch	276
 #define __NR_inotify_rm_watch	277
+#define __NR_spu_run		278
+#define __NR_spu_create		279
+#define __NR_pselect6		280
+#define __NR_ppoll		281
+#define __NR_unshare		282
+#define __NR_splice		283
+#define __NR_tee		284
+#define __NR_vmsplice		285
+#define __NR_openat		286
+#define __NR_mkdirat		287
+#define __NR_mknodat		288
+#define __NR_fchownat		289
+#define __NR_futimesat		290
+#define __NR_newfstatat		291
+#define __NR_unlinkat		292
+#define __NR_renameat		293
+#define __NR_linkat		294
+#define __NR_symlinkat		295
+#define __NR_readlinkat		296
+#define __NR_fchmodat		297
+#define __NR_faccessat		298
+#define __NR_get_robust_list	299
+#define __NR_set_robust_list	300
 
 
 
diff -urNxCVS -xdebian ../../dietlibc/s390/syscalls.h ./s390/syscalls.h
--- ../../dietlibc/s390/syscalls.h	2005-10-08 21:39:53.000000000 +0000
+++ ./s390/syscalls.h	2006-10-04 15:30:11.000000000 +0000
@@ -271,6 +271,28 @@
 #define __NR_inotify_init	284
 #define __NR_inotify_add_watch	285
 #define __NR_inotify_rm_watch	286
+/* Number 287 is reserved for new sys_migrate_pages */
+#define __NR_openat		288
+#define __NR_mkdirat		289
+#define __NR_mknodat		290
+#define __NR_fchownat		291
+#define __NR_futimesat		292
+#define __NR_unlinkat		294
+#define __NR_renameat		295
+#define __NR_linkat		296
+#define __NR_symlinkat		297
+#define __NR_readlinkat		298
+#define __NR_fchmodat		299
+#define __NR_faccessat		300
+#define __NR_pselect6		301
+#define __NR_ppoll		302
+#define __NR_unshare		303
+#define __NR_set_robust_list	304
+#define __NR_get_robust_list	305
+#define __NR_splice		306
+#define __NR_sync_file_range	307
+#define __NR_tee		308
+#define __NR_vmsplice		309
 
 
 #define syscall_weak(name,wsym,sym) \
diff -urNxCVS -xdebian ../../dietlibc/s390x/syscalls.h ./s390x/syscalls.h
--- ../../dietlibc/s390x/syscalls.h	2005-10-08 21:39:53.000000000 +0000
+++ ./s390x/syscalls.h	2006-10-04 15:30:11.000000000 +0000
@@ -271,6 +271,28 @@
 #define __NR_inotify_init	284
 #define __NR_inotify_add_watch	285
 #define __NR_inotify_rm_watch	286
+/* Number 287 is reserved for new sys_migrate_pages */
+#define __NR_openat		288
+#define __NR_mkdirat		289
+#define __NR_mknodat		290
+#define __NR_fchownat		291
+#define __NR_futimesat		292
+#define __NR_unlinkat		294
+#define __NR_renameat		295
+#define __NR_linkat		296
+#define __NR_symlinkat		297
+#define __NR_readlinkat		298
+#define __NR_fchmodat		299
+#define __NR_faccessat		300
+#define __NR_pselect6		301
+#define __NR_ppoll		302
+#define __NR_unshare		303
+#define __NR_set_robust_list	304
+#define __NR_get_robust_list	305
+#define __NR_splice		306
+#define __NR_sync_file_range	307
+#define __NR_tee		308
+#define __NR_vmsplice		309
 
 
 /* 
@@ -334,6 +356,7 @@
 #undef  __NR_fcntl64
 #undef  __NR_sendfile64
 #undef  __NR_fadvise64_64
+#undef  __NR_fstatat64
 
 #define __NR_select		142
 #define __NR_getrlimit		191	/* SuS compliant getrlimit */
@@ -356,6 +379,7 @@
 #define __NR_setgid  		214
 #define __NR_setfsuid  		215
 #define __NR_setfsgid  		216
+#define __NR_newfstatat		293
 
 #endif
 
diff -urNxCVS -xdebian ../../dietlibc/sparc/syscalls.h ./sparc/syscalls.h
--- ../../dietlibc/sparc/syscalls.h	2005-03-23 19:05:25.000000000 +0000
+++ ./sparc/syscalls.h	2006-10-04 15:30:11.000000000 +0000
@@ -282,6 +282,24 @@
 #define __NR_add_key		281
 #define __NR_request_key	282
 #define __NR_keyctl		283
+#define __NR_openat		284
+#define __NR_mkdirat		285
+#define __NR_mknodat		286
+#define __NR_fchownat		287
+#define __NR_futimesat		288
+#define __NR_fstatat64		289
+#define __NR_unlinkat		290
+#define __NR_renameat		291
+#define __NR_linkat		292
+#define __NR_symlinkat		293
+#define __NR_readlinkat		294
+#define __NR_fchmodat		295
+#define __NR_faccessat		296
+#define __NR_pselect6		297
+#define __NR_ppoll		298
+#define __NR_unshare		299
+#define __NR_set_robust_list	300
+#define __NR_get_robust_list	301
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff -urNxCVS -xdebian ../../dietlibc/sparc64/longjmp.S ./sparc64/longjmp.S
--- ../../dietlibc/sparc64/longjmp.S	2002-09-16 11:17:02.000000000 +0000
+++ ./sparc64/longjmp.S	2006-07-05 07:50:22.000000000 +0000
@@ -11,7 +11,7 @@
 .type	__libc_longjmp,function
 __libc_longjmp:
 	movrz	%o1, 1, %o1			/* never return 0 in setjmp */
-	stx	%o1, [ %o0+MC_G1 ]		/* save return value in context */
+	stx	%o1, [ %o0 + (4+MC_G1) * 8 ]    /* save return value in context */
 	ld	[ %o0+FLAG_SAVEMASK ], %o1	/* has setjmp saved the signalmask ? */
 	ta	0x6f				/* setcontext / restore context */
 .size	__libc_longjmp,.-__libc_longjmp
diff -urNxCVS -xdebian ../../dietlibc/sparc64/syscalls.h ./sparc64/syscalls.h
--- ../../dietlibc/sparc64/syscalls.h	2005-03-23 19:05:25.000000000 +0000
+++ ./sparc64/syscalls.h	2006-10-04 15:30:11.000000000 +0000
@@ -281,6 +281,24 @@
 #define __NR_add_key		281
 #define __NR_request_key	282
 #define __NR_keyctl		283
+#define __NR_openat		284
+#define __NR_mkdirat		285
+#define __NR_mknodat		286
+#define __NR_fchownat		287
+#define __NR_futimesat		288
+#define __NR_fstatat64		289
+#define __NR_unlinkat		290
+#define __NR_renameat		291
+#define __NR_linkat		292
+#define __NR_symlinkat		293
+#define __NR_readlinkat		294
+#define __NR_fchmodat		295
+#define __NR_faccessat		296
+#define __NR_pselect6		297
+#define __NR_ppoll		298
+#define __NR_unshare		299
+#define __NR_set_robust_list	300
+#define __NR_get_robust_list	301
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff -urNxCVS -xdebian ../../dietlibc/syscalls.s/__guard.S ./syscalls.s/__guard.S
--- ../../dietlibc/syscalls.s/__guard.S	2006-07-06 11:21:53.000000000 +0000
+++ ./syscalls.s/__guard.S	2006-10-30 15:28:32.000000000 +0000
@@ -1,3 +1,4 @@
+#include <endian.h>
 .data
 .type __guard,@object
 .global __guard
@@ -5,5 +6,9 @@
 .global __stack_chk_guard
 __guard:
 __stack_chk_guard:
+#if __WORDSIZE == 64
+.quad 0xaff00
+#else
 .long 0xaff00
+#endif
 
diff -urNxCVS -xdebian ../../dietlibc/test/ftell.c ./test/ftell.c
--- ../../dietlibc/test/ftell.c	1970-01-01 00:00:00.000000000 +0000
+++ ./test/ftell.c	2007-02-01 11:57:49.000000000 +0000
@@ -0,0 +1,26 @@
+#include <stdio.h>
+#include <assert.h>
+
+int main() {
+  FILE* f = popen("/bin/echo testing","r");
+  int i=getc(f);
+  assert(ftell(f)==-1);
+  assert(getc(f) == 'e');
+  pclose(f);
+  f=fopen("/tmp/test","w");
+  assert(ftell(f)==0);
+  fputs("test",f);
+  assert(ftell(f)==4);
+  fclose(f);
+  f=fopen("/tmp/test","r");
+  assert(ftell(f)==0);
+  i=getc(f);
+  assert(ftell(f)==1);
+  ungetc(i,f);
+  assert(ftell(f)==0);
+  i=getc(f);
+  i=getc(f);
+  assert(ftell(f)==2);
+  fclose(f);
+  unlink("/tmp/test");
+}
diff -urNxCVS -xdebian ../../dietlibc/test/getaddrinfo.c ./test/getaddrinfo.c
--- ../../dietlibc/test/getaddrinfo.c	2003-02-20 15:57:12.000000000 +0000
+++ ./test/getaddrinfo.c	2007-02-06 16:34:45.000000000 +0000
@@ -13,7 +13,7 @@
   memset(&hints,0,sizeof(hints));
   hints.ai_family=AF_UNSPEC;
   hints.ai_flags=0;
-  hints.ai_socktype=SOCK_STREAM;
+  hints.ai_socktype=0;
   if ((gaierr = getaddrinfo(NULL,"6010",&hints,&aitop)) != 0) {
     printf("error: %.100s\n",gai_strerror(gaierr));
     exit(0);
diff -urNxCVS -xdebian ../../dietlibc/test/getopt.c ./test/getopt.c
--- ../../dietlibc/test/getopt.c	2001-07-31 14:24:34.000000000 +0000
+++ ./test/getopt.c	2006-07-04 08:54:15.000000000 +0000
@@ -1,78 +1,79 @@
-       #include <stdio.h>     /* for printf */
-       #include <stdlib.h>    /* for exit */
-       #include <getopt.h>
-
-       int
-       main (int argc, char **argv) {
-           int c;
-           int digit_optind = 0;
-
-           while (1) {
-               int this_option_optind = optind ? optind : 1;
-               int option_index = 0;
-               static struct option long_options[] = {
-                   {"add", 1, 0, 0},
-                   {"append", 0, 0, 0},
-                   {"delete", 1, 0, 0},
-                   {"verbose", 0, 0, 0},
-                   {"create", 1, 0, 'c'},
-                   {"file", 1, 0, 0},
-                   {0, 0, 0, 0}
-               };
-
-               c = getopt_long_only (argc, argv, "abc:d:012",
-                        long_options, &option_index);
-               if (c == -1)
-                   break;
-
-               switch (c) {
-               case 0:
-                   printf ("option %s", long_options[option_index].name);
-                   if (optarg)
-                       printf (" with arg %s", optarg);
-                   printf ("\n");
-                   break;
-
-               case '0':
-               case '1':
-               case '2':
-                   if (digit_optind != 0 && digit_optind != this_option_optind)
-                     printf ("digits occur in two different argv-elements.\n");
-                   digit_optind = this_option_optind;
-                   printf ("option %c\n", c);
-                   break;
-
-               case 'a':
-                   printf ("option a\n");
-                   break;
-
-               case 'b':
-                   printf ("option b\n");
-                   break;
-
-               case 'c':
-                   printf ("option c with value `%s'\n", optarg);
-                   break;
-
-               case 'd':
-                   printf ("option d with value `%s'\n", optarg);
-                   break;
-
-               case '?':
-                   break;
-
-               default:
-                   printf ("?? getopt returned character code 0%o ??\n", c);
-               }
-           }
-
-           if (optind < argc) {
-               printf ("non-option ARGV-elements: ");
-               while (optind < argc)
-                   printf ("%s ", argv[optind++]);
-               printf ("\n");
-           }
+#include <stdio.h>     /* for printf */
+#include <stdlib.h>    /* for exit */
+#include <getopt.h>
+
+int
+main (int argc, char **argv) {
+  int c;
+  int digit_optind = 0;
+
+  while (1) {
+    int this_option_optind = optind ? optind : 1;
+    int option_index = 0;
+    static struct option long_options[] = {
+      {"add-file", 1, 0, 0},
+      {"add", 1, 0, 0},
+      {"append", 0, 0, 0},
+      {"delete", 1, 0, 0},
+      {"verbose", 0, 0, 0},
+      {"create", 1, 0, 'c'},
+      {"file", 1, 0, 0},
+      {0, 0, 0, 0}
+    };
+
+    c = getopt_long_only (argc, argv, "abc:d:012",
+			  long_options, &option_index);
+    if (c == -1)
+	break;
+
+    switch (c) {
+    case 0:
+      printf ("option %s", long_options[option_index].name);
+      if (optarg)
+	printf (" with arg %s", optarg);
+      printf ("\n");
+      break;
+
+    case '0':
+    case '1':
+    case '2':
+      if (digit_optind != 0 && digit_optind != this_option_optind)
+	printf ("digits occur in two different argv-elements.\n");
+      digit_optind = this_option_optind;
+      printf ("option %c\n", c);
+      break;
+
+    case 'a':
+      printf ("option a\n");
+      break;
+
+    case 'b':
+      printf ("option b\n");
+      break;
+
+    case 'c':
+      printf ("option c with value `%s'\n", optarg);
+      break;
+
+    case 'd':
+      printf ("option d with value `%s'\n", optarg);
+      break;
+
+    case '?':
+      break;
+
+    default:
+      printf ("?? getopt returned character code 0%o ??\n", c);
+    }
+  }
+
+  if (optind < argc) {
+    printf ("non-option ARGV-elements: ");
+    while (optind < argc)
+      printf ("%s ", argv[optind++]);
+    printf ("\n");
+  }
 
-           exit (0);
-       }
+  exit (0);
+}
 
diff -urNxCVS -xdebian ../../dietlibc/test/qsort.c ./test/qsort.c
--- ../../dietlibc/test/qsort.c	1970-01-01 00:00:00.000000000 +0000
+++ ./test/qsort.c	2006-08-16 22:13:56.000000000 +0000
@@ -0,0 +1,78 @@
+#define _BSD_SOURCE
+#define _GNU_SOURCE
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <inttypes.h>
+
+int compar(const void* a,const void* b) {
+  const unsigned char* A=*(void **)a;
+  const unsigned char* B=*(void **)b;
+  int l;
+  while (l=(*A-*B)) {
+    if (!*A) return 0;
+    ++A; ++B;
+  }
+  return l;
+}
+
+char** A;
+unsigned long a,n;
+
+#if defined (__i386__)
+#define RDTSC(dst) asm volatile ("rdtsc" : "=A" (dst))
+#elif defined (__x86_64__)
+#define RDTSC(dst) do {                                                        \
+  uint32_t l, h;                                                               \
+  asm volatile ("rdtsc" : "=a" (l), "=d" (h)); \
+  dst = (((uint64_t)h) << 32) | l;                             \
+} while (0)
+#else
+#error "Unimplemented rdtsc"
+#endif
+
+int main() {
+  char buf[2048];
+  unsigned long x,y;
+  while (fgets(buf,sizeof(buf),stdin)) {
+    buf[sizeof(buf)-1]=0;
+    if (n==a) {
+      a+=512;
+      A=realloc(A,a*sizeof(*A));
+      if (!A) {
+	printf("realloc to %lu elements failed!\n",a);
+	return 1;
+      }
+    }
+    if (!(A[n]=strdup(buf))) {
+      printf("strdup failed!\n");
+      return 1;
+    }
+    ++n;
+  }
+  printf("sorting %lu elements...\n",n);
+  {
+    char** B=malloc(n*sizeof(*A));
+    if (!B) {
+      printf("could not alloc %lu bytes!\n",n*sizeof(*A));
+      return 1;
+    }
+    memcpy(B,A,n*sizeof(*A));
+    qsort(A,n,sizeof(*A),compar);
+    memcpy(A,B,n*sizeof(*A));
+  }
+  RDTSC(x);
+  qsort(A,n,sizeof(*A),compar);
+  RDTSC(y);
+  printf("qsort took %lu cycles.\n",y-x);
+  {
+    unsigned int i;
+    for (i=0; i+1<n; ++i) {
+      if (compar(&A[i],&A[i+1])>0) {
+	printf(" -> not sorted!\n");
+	return 1;
+      }
+    }
+  }
+  return 0;
+}
diff -urNxCVS -xdebian ../../dietlibc/x86_64/Makefile.add ./x86_64/Makefile.add
--- ../../dietlibc/x86_64/Makefile.add	2002-08-07 01:21:51.000000000 +0000
+++ ./x86_64/Makefile.add	2006-10-30 15:28:32.000000000 +0000
@@ -1,2 +1,3 @@
 CFLAGS := -Os -fstrict-aliasing -momit-leaf-frame-pointer -mfancy-math-387
 VPATH  := x86_64:syscalls.s:$(VPATH)
+LIBOBJ += $(OBJDIR)/arch_prctl.o
diff -urNxCVS -xdebian ../../dietlibc/x86_64/arch_prctl.S ./x86_64/arch_prctl.S
--- ../../dietlibc/x86_64/arch_prctl.S	1970-01-01 00:00:00.000000000 +0000
+++ ./x86_64/arch_prctl.S	2006-10-13 23:59:50.000000000 +0000
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(arch_prctl,arch_prctl)
diff -urNxCVS -xdebian ../../dietlibc/x86_64/dyn_syscalls.S ./x86_64/dyn_syscalls.S
--- ../../dietlibc/x86_64/dyn_syscalls.S	2005-10-08 21:11:32.000000000 +0000
+++ ./x86_64/dyn_syscalls.S	2006-10-30 15:28:32.000000000 +0000
@@ -297,3 +297,5 @@
 
 #define __errno_location __errno_location@PLT
 #include "x86_64/gettimeofday.S"
+
+#include "syscalls.s/__guard.S"
diff -urNxCVS -xdebian ../../dietlibc/x86_64/getpriority.S ./x86_64/getpriority.S
--- ../../dietlibc/x86_64/getpriority.S	1970-01-01 00:00:00.000000000 +0000
+++ ./x86_64/getpriority.S	2007-03-26 03:06:59.000000000 +0000
@@ -0,0 +1,12 @@
+#include "syscalls.h"
+
+.text
+.global getpriority
+.type   getpriority,@function
+getpriority:
+     mov     $__NR_getpriority,%al
+     xorq    %rsi,%rsi
+     call    __unified_syscall
+     neg     %rax    /* the value is bios by 20 to avoid negative values */
+     add     $20,%rax
+     ret
diff -urNxCVS -xdebian ../../dietlibc/x86_64/syscalls.h ./x86_64/syscalls.h
--- ../../dietlibc/x86_64/syscalls.h	2005-09-21 07:33:08.000000000 +0000
+++ ./x86_64/syscalls.h	2006-10-04 15:30:12.000000000 +0000
@@ -301,6 +301,30 @@
 #define __NR_inotify_init	253
 #define __NR_inotify_add_watch	254
 #define __NR_inotify_rm_watch	255
+#define __NR_migrate_pages	256
+#define __NR_openat		257
+#define __NR_mkdirat		258
+#define __NR_mknodat		259
+#define __NR_fchownat		260
+#define __NR_futimesat		261
+#define __NR_newfstatat		262
+#define __NR_unlinkat		263
+#define __NR_renameat		264
+#define __NR_linkat		265
+#define __NR_symlinkat		266
+#define __NR_readlinkat		267
+#define __NR_fchmodat		268
+#define __NR_faccessat		269
+#define __NR_pselect6		270
+#define __NR_ppoll		271
+#define __NR_unshare		272
+#define __NR_set_robust_list	273
+#define __NR_get_robust_list	274
+#define __NR_splice		275
+#define __NR_tee		276
+#define __NR_sync_file_range	277
+#define __NR_vmsplice		278
+#define __NR_move_pages		279
 
 #ifdef __PIC__
 #define syscall_weak(name,wsym,sym) \
