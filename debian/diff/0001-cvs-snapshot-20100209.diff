From 7ca31938c5a2e532610b423403c9db78556640cd Mon Sep 17 00:00:00 2001
From: Gerrit Pape <pape@smarden.org>
Date: Wed, 10 Feb 2010 09:58:52 +0000
Subject: [PATCH 01/13] cvs snapshot 20100209

---
 CHANGES                       |   10 ++
 Makefile                      |    8 +
 PORTING                       |    1 +
 README                        |   11 +-
 TODO                          |    2 +
 diet.c                        |    2 +-
 dietfeatures.h                |    7 +-
 i386/memchr.S                 |   76 ++++++++--
 i386/syscalls.h               |   11 ++-
 i386/unified.S                |   13 +-
 include/elf.h                 |   60 ++++++---
 include/fcntl.h               |    7 +
 include/fenv.h                |  303 +++++++++++++++++++++++++++++++++++++++++
 include/netinet/in.h          |    4 +
 include/sys/personality.h     |   58 +-------
 include/sys/tls.h             |    8 +
 include/termios.h             |    1 +
 lib/posix_fallocate.c         |    7 +
 lib/stackgap.c                |   63 ++++++---
 libcruft/res_query.c          |    2 +-
 libpthread/pthread_create.c   |   33 +++++-
 libpthread/pthread_internal.c |   57 ++++++++
 libpthread/thread_internal.h  |    4 +-
 libregex/rx.c                 |   27 +++-
 librpc/pmap_clnt.c            |    6 +-
 libugly/wmemmove.c            |   12 ++
 mips/divdi3.c                 |   32 ++--
 parisc/clone.S                |    2 +-
 ppc64/__longjmp.S             |    4 +
 ppc64/setjmp.S                |    5 +
 syscalls.s/fallocate.S        |    5 +
 t.c                           |    2 +-
 test/regex.c                  |    2 +-
 x86_64/memchr.S               |   40 ++++++
 x86_64/strlen.S               |   32 +++++
 x86_64/strnlen.S              |   20 +++
 x86_64/syscalls.h             |   11 ++
 37 files changed, 793 insertions(+), 155 deletions(-)
 create mode 100644 include/fenv.h
 create mode 100644 lib/posix_fallocate.c
 create mode 100644 libugly/wmemmove.c
 create mode 100644 syscalls.s/fallocate.S
 create mode 100644 x86_64/memchr.S
 create mode 100644 x86_64/strlen.S
 create mode 100644 x86_64/strnlen.S

diff --git a/CHANGES b/CHANGES
index 83fdbad..84e36fd 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,3 +1,13 @@
+0.33:
+  first stab at getting TLS to work in actual threads
+  use fs: to find current thread on x86_64
+  add fallocate, posix_fallocate
+  work around Ubuntu who added -fstack-protector to their gcc, which
+    added stack protector code to the function from the dietlibc startup
+    code that sets up the registers and segments used by the stack
+    protector mechanism.
+  fix sys/personality.h (Mathias Krause)
+
 0.32:
   add mbsinit, mbrlen, mbtowc, wctomb, mbrtowc, wcrtomb, wcwidth
   add btowc, wctype, iswctype
diff --git a/Makefile b/Makefile
index adc2779..ddfd34b 100644
--- a/Makefile
+++ b/Makefile
@@ -155,6 +155,8 @@ $(OBJDIR) $(PICODIR):
 
 % :: %,v
 
+$(OBJDIR)/%.o: $(OBJDIR)
+
 ifeq ($(CC),tcc)
 $(OBJDIR)/%.o: %.S $(ARCH)/syscalls.h
 	$(CROSS)cpp $(INC) $< | $(CROSS)as -o $@
@@ -282,6 +284,9 @@ $(PICODIR)/libdl.so: libdl/_dl_main.c dietfeatures.h
 	$(LD_UNSET) $(CROSS)$(CC) -D__OD_CLEAN_ROOM -DNODIETREF -fPIC -nostdlib -shared -Bsymbolic -Wl,-Bsymbolic \
 		-o $@ $(SAFE_CFLAGS) $(INC) libdl/_dl_main.c -Wl,-soname=libdl.so
 
+$(OBJDIR)/pthread_create.o $(PICODIR)/pthread_create.o: dietfeatures.h
+$(OBJDIR)/pthread_internal.o $(PICODIR)/pthread_internal.o: dietfeatures.h
+
 #$(PICODIR)/libdl.so: $(DYN_LIBDL_OBJS) dietfeatures.h
 #	$(CROSS)$(CC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_LIBDL_OBJS) -L$(PICODIR) -ldietc -Wl,-soname=libdl.so
 
@@ -519,7 +524,10 @@ $(LIBPTHREAD_OBJS): include/pthread.h
 $(OBJDIR)/fcntl64.o: dietfeatures.h
 
 # WANT_SSP
+# This facepalm brought to you by: Ubuntu!
 $(OBJDIR)/stackgap.o: dietfeatures.h
+	$(CROSS)$(CC) $(INC) $(CFLAGS) -c lib/stackgap.c -o $@ -D__dietlibc__ -fno-stack-protector
+	$(COMMENT) -$(CROSS)strip -x -R .comment -R .note $@
 
 # WANT_MALLOC_ZERO
 $(OBJDIR)/strndup.o: dietfeatures.h
diff --git a/PORTING b/PORTING
index 4e2a635..4c008a7 100644
--- a/PORTING
+++ b/PORTING
@@ -24,5 +24,6 @@ To port the diet libc to a new architecture, you need to:
   - edit diet.c to make it recognize the architecture and add proper
     CFLAGS
   - edit libcompat/syscall.S
+  - edit include/fenv.h
 
 (I may have missed a few)
diff --git a/README b/README
index 2a1fa33..5c29f8a 100644
--- a/README
+++ b/README
@@ -37,13 +37,10 @@ appropriate location, too:
 	# cp diet.1 /usr/local/man/man1
 
 After you compiled the diet libc successfully, I invite you to check out
-the embedded utils (http://www.fefe.de/embutils/) and the diet libc
-binary repository (ftp://foobar.math.fu-berlin.de/pub/dietlibc/), too.
-The embedded utils are small replacements for common utilities like mv,
-chown, ls, and even a small tar that can extract tar files.  The binary
-repository contains a few utilities I linked against the diet libc, for
-example gzip, bzip2 and fdisk.
+the embedded utils (http://www.fefe.de/embutils/).  The embedded utils
+are small replacements for common utilities like mv, chown, ls, and even
+a small tar that can extract tar files.
 
 
 The license for the diet libc is the GNU General Public License, version
-2 (as included in the file COPYING).
+2 (as included in the file COPYING) or later.
diff --git a/TODO b/TODO
index 8002a84..6988144 100644
--- a/TODO
+++ b/TODO
@@ -33,3 +33,5 @@ set_thread_area -> set up TLD, for stack guard
 
 lsearch, lfind, hsearch, tsearch
 
+add option to detect valgrind (strstr for "valgrind" in getenv("LD_PRELOAD")),
+  then set a flag and disable optimizations that trigger warnings
diff --git a/diet.c b/diet.c
index 3677b4c..e7fd3e8 100644
--- a/diet.c
+++ b/diet.c
@@ -136,7 +136,7 @@ int main(int argc,char *argv[]) {
     char *tmp=strchr(cc,0)-2;
     char *tmp2,*tmp3;
     if (tmp<cc) goto donttouch;
-    if (!strstr(cc,"cc")) goto donttouch;
+    if (!strstr(cc,"cc") && !strstr(cc,"clang")) goto donttouch;
     if ((tmp2=strstr(cc,"linux-"))) {	/* cross compiling? */
       int len=strlen(platform);
       --tmp2;
diff --git a/dietfeatures.h b/dietfeatures.h
index 7ba02ec..63e388c 100644
--- a/dietfeatures.h
+++ b/dietfeatures.h
@@ -22,10 +22,10 @@
 /* this is only for meaningful for ttyname and sysconf_cpus so far */
 #define SLASH_PROC_OK
 
-/* use errno_location instead of errno */
+/* use errno_location instead of errno; NEEDED FOR MULTI-THREADING! */
 #define WANT_THREAD_SAFE
 
-/* support __thread */
+/* support __thread; NEEDED FOR MULTI-THREADING! */
 #define WANT_TLS
 
 /* make the startcode, etc. dynamic aware ({con,de}structors) */
@@ -115,6 +115,9 @@
 /* ProPolice is part of gcc 4.1 and up, there were patches for earlier
  * versions.  To make use of this, compile your application with
  * -fstack-protector. */
+/* If you compile dietlibc without WANT_SSP and then try to link code
+ * compiled with -fstack-protector against it, the binary will segfault
+ * when calling that code. */
 #if (__GNUC__>4) || ((__GNUC__==4) && (__GNUC_MINOR__>=1))
 #define WANT_SSP
 #endif
diff --git a/i386/memchr.S b/i386/memchr.S
index 7d04f99..0d7bef0 100644
--- a/i386/memchr.S
+++ b/i386/memchr.S
@@ -1,24 +1,68 @@
 .text
-.align 0
 .global memchr
-.type	 memchr,@function
+.type memchr,@function
 memchr:
-	pushl %edi
-	movl 8(%esp),%edi
-	movl 12(%esp),%eax
-	movl 16(%esp),%ecx
-	cld
-	jecxz .Lnotfound
+	push %edi
+	mov 8(%esp),%edi	/* edi = ptr */
+	movzxb 12(%esp),%eax
+	mov 16(%esp),%ecx
+	imul $0x01010101,%eax	/* eax = simd vector, 8 x ch */
+	push %esi
+	push %ebx
+	jecxz .Lnull
+	add %edi,%ecx		/* ecx == max ptr */
 
-	repne scasb
+1:	/* compare byte-wise until alignment */
+	test $3,%edi
+	jz 1f
+	cmp %al,(%edi)
+	jz .Lfound
+	inc %edi
+	jmp 1b
+
+1:	/* compare word-wise */
+	cmp %edi,%ecx
+	jb .Lnull
+	mov (%edi),%edx
+	xor %eax,%edx		/* in the input vector, change the byte we want to 0 */
+	mov %edx,%ebx
+	sub $0x01010101,%ebx
+	not %edx
+	and %ebx,%edx
+	shr $7,%edx
+	and $0x01010101,%edx	/* this sequence did !! to every byte in edx */
+	jnz 1f
+	add $4,%edi
+	jmp 1b
+
+1:	/* there is a nonzero byte in %edx, try lower half */
+	test %dx,%dx
+	jnz 1f
+	/* not in lower half, swap halves */
+	shr $16,%edx
+	add $2,%edi
+1:
+	test %dl,%dl
+	jnz 1f
+	/* no match in lower byte */
+	mov %dh,%dl
+	inc %edi
+1:
 
-	je .Lfound
-.Lnotfound:
-	xorl %edi, %edi
-	incl %edi
 .Lfound:
-	movl %edi, %eax
-	decl %eax
+	cmp %edi,%ecx
+	jb .Lnull
+	mov %edi,%eax
+	pop %ebx
+	pop %esi
+	pop %edi
+	ret
 
-	popl %edi
+.Lnull:
+	xor %eax,%eax
+	pop %ebx
+	pop %esi
+	pop %edi
 	ret
+.Lhere:
+.size memchr,.Lhere-memchr
diff --git a/i386/syscalls.h b/i386/syscalls.h
index 328f8c8..09edb12 100644
--- a/i386/syscalls.h
+++ b/i386/syscalls.h
@@ -325,7 +325,16 @@
 #define __NR_fallocate		324
 #define __NR_timerfd_settime	325
 #define __NR_timerfd_gettime	326
-
+#define __NR_signalfd4		327
+#define __NR_eventfd2		328
+#define __NR_epoll_create1	329
+#define __NR_dup3		330
+#define __NR_pipe2		331
+#define __NR_inotify_init1	332
+#define __NR_preadv		333
+#define __NR_pwritev		334
+#define __NR_rt_tgsigqueueinfo	335
+#define __NR_perf_event_open	336
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff --git a/i386/unified.S b/i386/unified.S
index 0a26647..0a8aec4 100644
--- a/i386/unified.S
+++ b/i386/unified.S
@@ -33,15 +33,17 @@ __unified_syscall:
 	push	%edi
 	push	%esi
 	push	%ebx
+	push	%ebp
 	movl	%esp,%edi
 	/* we use movl instead of pop because otherwise a signal would
 	   destroy the stack frame and crash the program, although it
 	   would save a few bytes. */
-	movl	0x10(%edi),%ebx
-	movl	0x14(%edi),%ecx
-	movl	0x18(%edi),%edx
-	movl	0x1c(%edi),%esi
-	movl	0x20(%edi),%edi
+	movl	5*4(%edi),%ebx
+	movl	6*4(%edi),%ecx
+	movl	7*4(%edi),%edx
+	movl	8*4(%edi),%esi
+	movl	10*4(%edi),%ebp
+	movl	9*4(%edi),%edi
 #ifdef WANT_SYSENTER
 	call	*.Lvsyscall /* 0xffffe000 */
 #else
@@ -60,6 +62,7 @@ __unified_syscall:
 	sbb	%eax,%eax               # eax = eax - eax - CY = -1
 #endif
 .Lnoerror:
+	pop	%ebp
 	pop	%ebx
 	pop	%esi
 	pop	%edi
diff --git a/include/elf.h b/include/elf.h
index 6bfd3d6..5197548 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -527,25 +527,47 @@ typedef struct
 
 /* Legal values for p_type (segment type).  */
 
-#define	PT_NULL		0		/* Program header table entry unused */
-#define PT_LOAD		1		/* Loadable program segment */
-#define PT_DYNAMIC	2		/* Dynamic linking information */
-#define PT_INTERP	3		/* Program interpreter */
-#define PT_NOTE		4		/* Auxiliary information */
-#define PT_SHLIB	5		/* Reserved */
-#define PT_PHDR		6		/* Entry for header table itself */
-#define PT_TLS		7		/* Thread-local storage segment */
-#define	PT_NUM		8		/* Number of defined types */
-#define PT_LOOS		0x60000000	/* Start of OS-specific */
-#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
-#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
-#define PT_LOSUNW	0x6ffffffa
-#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
-#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
-#define PT_HISUNW	0x6fffffff
-#define PT_HIOS		0x6fffffff	/* End of OS-specific */
-#define PT_LOPROC	0x70000000	/* Start of processor-specific */
-#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
+enum {
+  PT_NULL = 0,			/* Program header table entry unused */
+  PT_LOAD = 1,			/* Loadable program segment */
+  PT_DYNAMIC = 2,		/* Dynamic linking information */
+  PT_INTERP = 3,		/* Program interpreter */
+  PT_NOTE = 4,			/* Auxiliary information */
+  PT_SHLIB = 5,			/* Reserved */
+  PT_PHDR = 6,			/* Entry for header table itself */
+  PT_TLS = 7,			/* Thread-local storage segment */
+  PT_NUM = 8,			/* Number of defined types */
+  PT_LOOS = 0x60000000,		/* Start of OS-specific */
+  PT_GNU_EH_FRAME = 0x6474e550,	/* GCC .eh_frame_hdr segment */
+  PT_GNU_STACK = 0x6474e551,	/* Indicates stack executability */
+  PT_LOSUNW = 0x6ffffffa,
+  PT_SUNWBSS = 0x6ffffffa,	/* Sun Specific segment */
+  PT_SUNWSTACK = 0x6ffffffb,	/* Stack segment */
+  PT_HISUNW = 0x6fffffff,
+  PT_HIOS = 0x6fffffff,		/* End of OS-specific */
+  PT_LOPROC = 0x70000000,	/* Start of processor-specific */
+  PT_HIPROC = 0x7fffffff	/* End of processor-specific */
+};
+
+#define PT_NULL PT_NULL
+#define PT_LOAD PT_LOAD
+#define PT_DYNAMIC PT_DYNAMIC
+#define PT_INTERP PT_INTERP
+#define PT_NOTE PT_NOTE
+#define PT_SHLIB PT_SHLIB
+#define PT_PHDR PT_PHDR
+#define PT_TLS PT_TLS
+#define PT_NUM PT_NUM
+#define PT_LOOS PT_LOOS
+#define PT_GNU_EH_FRAME PT_GNU_EH_FRAME
+#define PT_GNU_STACK PT_GNU_STACK
+#define PT_LOSUNW PT_LOSUNW
+#define PT_SUNWBSS PT_SUNWBSS
+#define PT_SUNWSTACK PT_SUNWSTACK
+#define PT_HISUNW PT_HISUNW
+#define PT_HIOS PT_HIOS
+#define PT_LOPROC PT_LOPROC
+#define PT_HIPROC PT_HIPROC
 
 /* Legal values for p_flags (segment flags).  */
 
diff --git a/include/fcntl.h b/include/fcntl.h
index dd0ee36..510826c 100644
--- a/include/fcntl.h
+++ b/include/fcntl.h
@@ -643,6 +643,10 @@ long vmsplice(int fd, const struct iovec *iov, unsigned long nr_segs, unsigned i
 long splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags) __THROW;
 
 int sync_file_range(int fd, off64_t offset, off64_t nbytes, unsigned int flags) __THROW;
+
+#define FALLOC_FL_KEEP_SIZE 1
+
+int fallocate(int fd, int mode, loff_t offset, loff_t len) __THROW;
 #endif
 
 #ifdef _ATFILE_SOURCE
@@ -668,6 +672,9 @@ int mkfifoat(int dirfd, const char *pathname, mode_t mode);
 int utimensat(int dirfd, const char *pathname, struct timespec* t);
 #endif
 
+#if defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE - 0) >= 600
+int posix_fallocate(int fd, off64_t offset, off64_t len) __THROW;
+#endif
 
 __END_DECLS
 
diff --git a/include/fenv.h b/include/fenv.h
new file mode 100644
index 0000000..6c66553
--- /dev/null
+++ b/include/fenv.h
@@ -0,0 +1,303 @@
+#ifndef _FENV_H
+#define _FENV_H
+
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+
+#if defined(__i386__)
+
+enum
+  {
+    FE_INVALID = 0x01,
+#define FE_INVALID      FE_INVALID
+    __FE_DENORM = 0x02,
+    FE_DIVBYZERO = 0x04,
+#define FE_DIVBYZERO    FE_DIVBYZERO
+    FE_OVERFLOW = 0x08,
+#define FE_OVERFLOW     FE_OVERFLOW
+    FE_UNDERFLOW = 0x10,
+#define FE_UNDERFLOW    FE_UNDERFLOW
+    FE_INEXACT = 0x20
+#define FE_INEXACT      FE_INEXACT
+  };
+
+#define FE_ALL_EXCEPT \
+        (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {
+    FE_TONEAREST = 0,
+#define FE_TONEAREST    FE_TONEAREST
+    FE_DOWNWARD = 0x400,
+#define FE_DOWNWARD     FE_DOWNWARD
+    FE_UPWARD = 0x800,
+#define FE_UPWARD       FE_UPWARD
+    FE_TOWARDZERO = 0xc00
+#define FE_TOWARDZERO   FE_TOWARDZERO
+  };
+
+#define FE_DFL_ENV      ((__const fenv_t *) -1)
+
+/* Type representing exception flags.  */
+typedef unsigned short int fexcept_t;
+
+/* Type representing floating-point environment.  This function corresponds
+   to the layout of the block written by the `fstenv'.  */
+typedef struct {
+  unsigned short int __control_word;
+  unsigned short int __unused1;
+  unsigned short int __status_word;
+  unsigned short int __unused2;
+  unsigned short int __tags;
+  unsigned short int __unused3;
+  unsigned int __eip;
+  unsigned short int __cs_selector;
+  unsigned int __opcode:11;
+  unsigned int __unused4:5;
+  unsigned int __data_offset;
+  unsigned short int __data_selector;
+  unsigned short int __unused5;
+} fenv_t;
+
+#elif defined(__ia64__)
+
+enum
+  {
+    FE_INEXACT =        1UL << 5,
+#define FE_INEXACT      FE_INEXACT
+
+    FE_UNDERFLOW =      1UL << 4,
+#define FE_UNDERFLOW    FE_UNDERFLOW
+
+    FE_OVERFLOW =       1UL << 3,
+#define FE_OVERFLOW     FE_OVERFLOW
+
+    FE_DIVBYZERO =      1UL << 2,
+#define FE_DIVBYZERO    FE_DIVBYZERO
+
+    FE_UNNORMAL =       1UL << 1,
+#define FE_UNNORMAL     FE_UNNORMAL
+
+    FE_INVALID =        1UL << 0,
+#define FE_INVALID      FE_INVALID
+
+    FE_ALL_EXCEPT =
+        (FE_INEXACT | FE_UNDERFLOW | FE_OVERFLOW | FE_DIVBYZERO | FE_UNNORMAL | FE_INVALID)
+#define FE_ALL_EXCEPT   FE_ALL_EXCEPT
+  };
+
+enum
+  {
+    FE_TOWARDZERO =     3,
+#define FE_TOWARDZERO   FE_TOWARDZERO
+
+    FE_UPWARD =         2,
+#define FE_UPWARD       FE_UPWARD
+
+    FE_DOWNWARD =       1,
+#define FE_DOWNWARD     FE_DOWNWARD
+
+    FE_TONEAREST =      0,
+#define FE_TONEAREST    FE_TONEAREST
+  };
+
+#define FE_DFL_ENV      ((__const fenv_t *) 0xc009804c0270033fUL)
+
+typedef unsigned long int fexcept_t;
+typedef unsigned long int fenv_t;
+
+#elif defined(__powerpc__)
+
+enum
+  {
+    FE_INEXACT = 1 << (31 - 6),
+#define FE_INEXACT      FE_INEXACT
+    FE_DIVBYZERO = 1 << (31 - 5),
+#define FE_DIVBYZERO    FE_DIVBYZERO
+    FE_UNDERFLOW = 1 << (31 - 4),
+#define FE_UNDERFLOW    FE_UNDERFLOW
+    FE_OVERFLOW = 1 << (31 - 3),
+#define FE_OVERFLOW     FE_OVERFLOW
+
+    /* ... except for FE_INVALID, for which we use bit 31. FE_INVALID
+       actually corresponds to bits 7 through 12 and 21 through 23
+       in the FPSCR, but we can't use that because the current draft
+       says that it must be a power of 2.  Instead we use bit 2 which
+       is the summary bit for all the FE_INVALID exceptions, which
+       kind of makes sense.  */
+    FE_INVALID = 1 << (31 - 2),
+#define FE_INVALID      FE_INVALID
+  };
+
+#define FE_ALL_EXCEPT \
+        (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {
+    FE_TONEAREST = 0,
+#define FE_TONEAREST    FE_TONEAREST
+    FE_TOWARDZERO = 1,
+#define FE_TOWARDZERO   FE_TOWARDZERO
+    FE_UPWARD = 2,
+#define FE_UPWARD       FE_UPWARD
+    FE_DOWNWARD = 3
+#define FE_DOWNWARD     FE_DOWNWARD
+  };
+
+typedef unsigned int fexcept_t;
+typedef double fenv_t;
+extern const fenv_t __fe_dfl_env;
+#define FE_DFL_ENV      (&__fe_dfl_env)
+
+#elif defined(__s390__)
+
+enum
+  {
+    FE_INVALID = 0x80,
+#define FE_INVALID      FE_INVALID
+    FE_DIVBYZERO = 0x40,
+#define FE_DIVBYZERO    FE_DIVBYZERO
+    FE_OVERFLOW = 0x20,
+#define FE_OVERFLOW     FE_OVERFLOW
+    FE_UNDERFLOW = 0x10,
+#define FE_UNDERFLOW    FE_UNDERFLOW
+    FE_INEXACT = 0x08
+#define FE_INEXACT      FE_INEXACT
+  };
+
+#define FE_ALL_EXCEPT \
+        (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {
+    FE_TONEAREST = 0,
+#define FE_TONEAREST    FE_TONEAREST
+    FE_DOWNWARD = 0x3,
+#define FE_DOWNWARD     FE_DOWNWARD
+    FE_UPWARD = 0x2,
+#define FE_UPWARD       FE_UPWARD
+    FE_TOWARDZERO = 0x1
+#define FE_TOWARDZERO   FE_TOWARDZERO
+  };
+
+#define FE_DFL_ENV      ((__const fenv_t *) -1)
+
+typedef unsigned int fexcept_t; /* size of fpc */
+typedef struct
+{
+  fexcept_t fpc;
+  void *ieee_instruction_pointer;
+  /* failing instruction for ieee exceptions */
+} fenv_t;
+
+#elif defined(__sparc__)
+
+enum
+  {    
+    FE_INVALID =        (1 << 9),
+#define FE_INVALID      FE_INVALID
+    FE_OVERFLOW =       (1 << 8),
+#define FE_OVERFLOW     FE_OVERFLOW
+    FE_UNDERFLOW =      (1 << 7),
+#define FE_UNDERFLOW    FE_UNDERFLOW
+    FE_DIVBYZERO =      (1 << 6),
+#define FE_DIVBYZERO    FE_DIVBYZERO
+    FE_INEXACT =        (1 << 5)
+#define FE_INEXACT      FE_INEXACT
+  };
+
+#define FE_ALL_EXCEPT \
+        (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {      
+    FE_TONEAREST =      (0U << 30),
+#define FE_TONEAREST    FE_TONEAREST
+    FE_TOWARDZERO =     (1U << 30),
+#define FE_TOWARDZERO   FE_TOWARDZERO
+    FE_UPWARD =         (2U << 30),
+#define FE_UPWARD       FE_UPWARD
+    FE_DOWNWARD =       (3U << 30)
+#define FE_DOWNWARD     FE_DOWNWARD
+  };
+
+#define __FE_ROUND_MASK (3U << 30)
+#define FE_DFL_ENV      ((__const fenv_t *) -1)
+
+typedef unsigned long int fexcept_t;
+typedef unsigned long int fenv_t;
+
+#elif defined(__x86_64__)
+
+enum
+  {    
+    FE_INVALID = 0x01,  
+#define FE_INVALID      FE_INVALID
+    __FE_DENORM = 0x02,
+    FE_DIVBYZERO = 0x04,
+#define FE_DIVBYZERO    FE_DIVBYZERO
+    FE_OVERFLOW = 0x08,
+#define FE_OVERFLOW     FE_OVERFLOW
+    FE_UNDERFLOW = 0x10,
+#define FE_UNDERFLOW    FE_UNDERFLOW
+    FE_INEXACT = 0x20
+#define FE_INEXACT      FE_INEXACT
+  };
+
+#define FE_ALL_EXCEPT \
+        (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  { 
+    FE_TONEAREST = 0,
+#define FE_TONEAREST    FE_TONEAREST
+    FE_DOWNWARD = 0x400,
+#define FE_DOWNWARD     FE_DOWNWARD
+    FE_UPWARD = 0x800,
+#define FE_UPWARD       FE_UPWARD
+    FE_TOWARDZERO = 0xc00
+#define FE_TOWARDZERO   FE_TOWARDZERO
+  };
+
+#define FE_DFL_ENV      ((__const fenv_t *) -1)
+
+typedef unsigned short int fexcept_t;
+
+typedef struct {
+  unsigned short int __control_word;
+  unsigned short int __unused1;
+  unsigned short int __status_word;
+  unsigned short int __unused2;
+  unsigned short int __tags;
+  unsigned short int __unused3;
+  unsigned int __eip;
+  unsigned short int __cs_selector;
+  unsigned int __opcode:11;
+  unsigned int __unused4:5;
+  unsigned int __data_offset;
+  unsigned short int __data_selector;
+  unsigned short int __unused5;
+  unsigned int __mxcsr;
+} fenv_t;
+
+#else
+
+#error unsupported platform, edit include/fenv.h
+#endif
+
+int  feclearexcept(int);
+int  fegetexceptflag(fexcept_t *, int);
+int  feraiseexcept(int);
+int  fesetexceptflag(const fexcept_t *, int);
+int  fetestexcept(int);
+int  fegetround(void);
+int  fesetround(int);
+int  fegetenv(fenv_t *);
+int  feholdexcept(fenv_t *);
+int  fesetenv(const fenv_t *);
+int  feupdateenv(const fenv_t *);
+
+__END_DECLS
+
+#endif
diff --git a/include/netinet/in.h b/include/netinet/in.h
index ff07ccd..7daa24b 100644
--- a/include/netinet/in.h
+++ b/include/netinet/in.h
@@ -41,6 +41,10 @@ enum {
 #define IPPROTO_AH IPPROTO_AH
   IPPROTO_COMP   = 108,                /* Compression Header protocol */
 #define IPPROTO_COMP IPPROTO_COMP
+    IPPROTO_SCTP = 132,	   /* Stream Control Transmission Protocol.  */
+#define IPPROTO_SCTP		IPPROTO_SCTP
+    IPPROTO_UDPLITE = 136, /* UDP-Lite protocol.  */
+#define IPPROTO_UDPLITE		IPPROTO_UDPLITE
   IPPROTO_RAW	 = 255,		/* Raw IP packets			*/
 #define IPPROTO_RAW IPPROTO_RAW
   IPPROTO_MAX
diff --git a/include/sys/personality.h b/include/sys/personality.h
index b6103ff..5106b75 100644
--- a/include/sys/personality.h
+++ b/include/sys/personality.h
@@ -1,16 +1,7 @@
 #ifndef _PERSONALITY_H
 #define _PERSONALITY_H
 
-/*
- * Handling of different ABIs (personalities).
- */
-
-struct exec_domain;
-struct pt_regs;
-
-extern int		register_exec_domain(struct exec_domain *);
-extern int		unregister_exec_domain(struct exec_domain *);
-extern int		__set_personality(unsigned long);
+#include <sys/cdefs.h>
 
 /*
  * Flags for bug emulation.
@@ -33,12 +24,6 @@ enum {
 };
 
 /*
- * Security-relevant compatibility flags that must be
- * cleared upon setuid or setgid exec:
- */
-#define PER_CLEAR_ON_SETID (READ_IMPLIES_EXEC|ADDR_NO_RANDOMIZE)
-
-/*
  * Personality types.
  *
  * These go in the low byte.  Avoid using the top bit, it will
@@ -71,44 +56,11 @@ enum {
 	PER_MASK =		0x00ff,
 };
 
+__BEGIN_DECLS
 
-/*
- * Description of an execution domain.
- * 
- * The first two members are refernced from assembly source
- * and should stay where they are unless explicitly needed.
- */
-typedef void (*handler_t)(int, struct pt_regs *);
+/* Set different ABIs (personalities).  */
+extern int personality (unsigned long int __persona) __THROW;
 
-struct exec_domain {
-	const char		*name;		/* name of the execdomain */
-	handler_t		handler;	/* handler for syscalls */
-	unsigned char		pers_low;	/* lowest personality */
-	unsigned char		pers_high;	/* highest personality */
-	unsigned long		*signal_map;	/* signal mapping */
-	unsigned long		*signal_invmap;	/* reverse signal mapping */
-	struct map_segment	*err_map;	/* error mapping */
-	struct map_segment	*socktype_map;	/* socket type mapping */
-	struct map_segment	*sockopt_map;	/* socket option mapping */
-	struct map_segment	*af_map;	/* address family mapping */
-	struct module		*module;	/* module context of the ed. */
-	struct exec_domain	*next;		/* linked list (internal) */
-};
-
-/*
- * Return the base personality without flags.
- */
-#define personality(pers)	(pers & PER_MASK)
-
-/*
- * Personality of the currently running process.
- */
-#define get_personality		(current->personality)
-
-/*
- * Change personality of the currently running process.
- */
-#define set_personality(pers) \
-	((current->personality == pers) ? 0 : __set_personality(pers))
+__END_DECLS
 
 #endif /* _PERSONALITY_H */
diff --git a/include/sys/tls.h b/include/sys/tls.h
index d4bd9f6..7db014c 100644
--- a/include/sys/tls.h
+++ b/include/sys/tls.h
@@ -23,11 +23,19 @@ typedef struct
   dtv_t *dtv;
   void *self;           /* Pointer to the thread descriptor.  */
   int multiple_threads;
+#ifdef __x86_64__
+  int gscope_flag;
+#endif
   uintptr_t sysinfo;
   uintptr_t stack_guard;
   uintptr_t pointer_guard;
+#ifdef __i386__
+  int gscope_flag;
+#endif
 } tcbhead_t;
 
+tcbhead_t* __get_cur_tcb(void) __THROW;
+
 #if defined(__i386__)
 
 struct user_desc {
diff --git a/include/termios.h b/include/termios.h
index 3f18d45..6cb3d43 100644
--- a/include/termios.h
+++ b/include/termios.h
@@ -239,6 +239,7 @@ struct termios {
 #define IXANY	0004000
 #define IXOFF	0010000
 #define IMAXBEL	0020000
+#define IUTF8	0040000
 
 /* c_oflag bits */
 #define OPOST	0000001
diff --git a/lib/posix_fallocate.c b/lib/posix_fallocate.c
new file mode 100644
index 0000000..ef9f985
--- /dev/null
+++ b/lib/posix_fallocate.c
@@ -0,0 +1,7 @@
+#define _GNU_SOURCE
+#define _XOPEN_SOURCE 600
+#include <fcntl.h>
+
+int posix_fallocate(int fd, off64_t offset, off64_t len) {
+  return fallocate(fd,0,offset,len);
+}
diff --git a/lib/stackgap.c b/lib/stackgap.c
index e974e2c..0e22dc0 100644
--- a/lib/stackgap.c
+++ b/lib/stackgap.c
@@ -1,3 +1,12 @@
+/* Warning: this code sets up the machine registers and segments needed
+ * for -fstack-protector to work.  If you compile this function with
+ * -fstack-protector, it will reference those registers before they are
+ * set up properly, causing a segmentation fault.  Ubuntu adds
+ * -fstack-protector to their gcc default options, so this breaks.  I
+ * added a workaround to the Makefile to make sure this code is always
+ * compiled with -fno-stack-protector for this reason.  Or, as a friend
+ * put it: yo dawg. I herd u liek stack protektion. :-)
+ */
 #include <unistd.h>
 #include <fcntl.h>
 #include <alloca.h>
@@ -13,6 +22,10 @@ extern int main(int argc,char* argv[],char* envp[]);
 extern unsigned long __guard;
 #endif
 
+#ifdef __i386__
+int __modern_linux;
+#endif
+
 #ifdef WANT_TLS
 /* __tdatasize is the size of the initialized thread local data section
  * __tmemsize is the size of the complete thread local data section
@@ -29,19 +42,19 @@ static void findtlsdata(long* auxvec) {
 #else
   Elf32_Phdr* x=0;
 #endif
-  size_t i,n;
+  size_t i,n=0;
   while (*auxvec) {
-    if (auxvec[0]==3) {
+    if (auxvec[0]==3) {	/* AT_PHDR */
       x=(void*)auxvec[1];
-      break;
+      if (n) break;
+    } else if (auxvec[0]==5) { /* AT_PHNUM */
+      n=auxvec[1];
+      if (x) break;
     }
     auxvec+=2;
   } /* if we don't find the entry, the kernel let us down */
-  if (!x) return;	/* a kernel this old does not support thread local storage anyway */
-  if (x->p_type!=PT_PHDR) return;	/* should start with PT_PHDR */
-  /* if it doesn't, assume there is no thread local storage */
-  n=x->p_memsz/sizeof(*x);
-  for (i=1; i<n; ++i)
+  if (!x || !n) return;	/* a kernel this old does not support thread local storage anyway */
+  for (i=0; i<n; ++i)
     if (x[i].p_type==PT_TLS) {
       __tdataptr=(void*)x[i].p_vaddr;
       __tdatasize=x[i].p_filesz;
@@ -54,11 +67,15 @@ static void findtlsdata(long* auxvec) {
 #endif
 
 #if defined(WANT_SSP) || defined(WANT_TLS)
-static tcbhead_t mainthread;
+tcbhead_t* __tcb_mainthread;
+
+void __setup_tls(tcbhead_t*);
 
-static void setup_tls(tcbhead_t* mainthread) {
-  mainthread->tcb=&mainthread;
-  mainthread->self=&mainthread;
+void __setup_tls(tcbhead_t* mainthread) {
+  mainthread->tcb=mainthread;
+  mainthread->dtv=0;
+  mainthread->self=0;
+  mainthread->multiple_threads=0;
 #if defined(WANT_SSP)
   mainthread->stack_guard=__guard;
 #endif
@@ -69,14 +86,17 @@ static void setup_tls(tcbhead_t* mainthread) {
 
 #elif defined(__i386__)
 
-  static unsigned int sd[4];
+  unsigned int sd[4];
   sd[0]=-1;
   sd[1]=(unsigned long int)mainthread;
   sd[2]=0xfffff; /* 4 GB limit */
   sd[3]=0x51; /* bitfield, see struct user_desc in asm-i386/ldt.h */
-  if (set_thread_area((struct user_desc*)(void*)&sd)==0) {
-    asm volatile ("movw %w0, %%gs" :: "q" (sd[0]*8+3));
-  }
+  if (__modern_linux>=0)
+    if (set_thread_area((struct user_desc*)(void*)&sd)==0) {
+      asm volatile ("movw %w0, %%gs" :: "q" (sd[0]*8+3));
+      __modern_linux=1;
+    } else
+      __modern_linux=-1;
 
 #elif defined(__alpha__) || defined(__s390__)
   __builtin_set_thread_pointer(mainthread);
@@ -133,12 +153,19 @@ int stackgap(int argc,char* argv[],char* envp[]) {
 #endif
 #endif
 
-#if defined(WANT_SSP) || defined(WANT_TLS)
+#ifdef WANT_TLS
   findtlsdata(auxvec);
+  if (__unlikely(__tmemsize+sizeof(tcbhead_t)<sizeof(tcbhead_t)) ||
+      __unlikely(__tmemsize>512*1024*1024) ||
+      __unlikely(__tmemsize<__tdatasize))
+    return 111;
   tlsdata=alloca(__tmemsize+sizeof(tcbhead_t));
   memcpy(tlsdata,__tdataptr,__tdatasize);
   memset(tlsdata+__tdatasize,0,__tmemsize-__tdatasize);
-  setup_tls((tcbhead_t*)(tlsdata+__tmemsize));
+  __setup_tls(__tcb_mainthread=(tcbhead_t*)(tlsdata+__tmemsize));
+#elif defined(WANT_SSP)
+  tlsdata=alloca(sizeof(tcbhead_t));
+  __setup_tls(__tcb_mainthread=(tcbhead_t*)(tlsdata));
 #endif
   return main(argc,argv,envp);
 }
diff --git a/libcruft/res_query.c b/libcruft/res_query.c
index d1e4b73..41f9410 100644
--- a/libcruft/res_query.c
+++ b/libcruft/res_query.c
@@ -207,8 +207,8 @@ int res_query(const char *dname, int class, int type, unsigned char *answer, int
 	    } else
 	      continue;
 /* ignore NXDOMAIN from the multicast socket */
-nxdomain:
 #endif
+nxdomain:
 	    h_errno=HOST_NOT_FOUND;
 	    return -1;
 	  }		/* error */
diff --git a/libpthread/pthread_create.c b/libpthread/pthread_create.c
index fcfc37e..12d3115 100644
--- a/libpthread/pthread_create.c
+++ b/libpthread/pthread_create.c
@@ -6,6 +6,12 @@
 #include <pthread.h>
 #include "thread_internal.h"
 
+#ifdef WANT_TLS
+#include <sys/tls.h>
+
+extern size_t __tmemsize;
+#endif
+
 int pthread_attr_init(pthread_attr_t*attr) {
   memset(attr,0,sizeof(pthread_attr_t));
   attr->__stacksize=PTHREAD_STACK_SIZE;
@@ -22,11 +28,22 @@ int pthread_attr_destroy(pthread_attr_t *attr) __attribute__((alias("pthread_att
 
 int pthread_create(pthread_t*thread,const pthread_attr_t*d_attr,
 		void*(*start_routine)(void*),void*arg) {
+#if 0
+  /* first try the linux 2.6 way */
+  if (__likely(__modern_linux>=0)) {
+    /* try new way; if it fails, assume old kernel */
+  }
+#endif
   struct __thread_descr request;
   pthread_attr_t attr;
-  _pthread_descr td,this=__thread_self();
+  _pthread_descr td,this;
+  this=__thread_self();
   char*stack;
   int ret;
+#ifdef WANT_TLS
+  size_t origsize;
+  size_t additional;
+#endif
 
   if (thread==0) kill(getpid(),SIGSEGV);
   if (start_routine==0) return EINVAL;
@@ -38,6 +55,19 @@ int pthread_create(pthread_t*thread,const pthread_attr_t*d_attr,
   else
     pthread_attr_init(&attr);
 
+#ifdef WANT_TLS
+  origsize=attr.__stacksize;
+  additional=__tmemsize+sizeof(tcbhead_t);
+  additional=(additional+15)&-16;
+  if (additional < sizeof(tcbhead_t) ||
+      origsize < sizeof(struct _pthread_descr_struct) ||
+      origsize+additional < origsize) {
+    ret=EINVAL;
+    goto func_out;
+  }
+  attr.__stacksize=origsize+additional;
+#endif
+
   {
     register char*stb,*st=0;
     if ((stack=attr.__stackaddr)==0) {
@@ -48,6 +78,7 @@ int pthread_create(pthread_t*thread,const pthread_attr_t*d_attr,
 	goto func_out;
       }
     }
+
     stb=stack;
 #ifdef __parisc__
     td=(_pthread_descr)stack;
diff --git a/libpthread/pthread_internal.c b/libpthread/pthread_internal.c
index 70761b9..5291a9f 100644
--- a/libpthread/pthread_internal.c
+++ b/libpthread/pthread_internal.c
@@ -10,6 +10,8 @@
 #include <sched.h>
 #include <sys/resource.h>
 
+#include <stdlib.h>
+
 #include <pthread.h>
 #include "thread_internal.h"
 
@@ -19,6 +21,10 @@
 #include <stdio.h>
 #endif
 
+#ifdef WANT_TLS
+#include <sys/tls.h>
+#endif
+
 #define INTR_RETRY(e) ({ long ret; do ret=(long)(e); while ((ret==-1)&&(_errno_==EINTR)); ret; })
 
 #define __NO_ASYNC_CANCEL_STOP }
@@ -115,6 +121,16 @@ _pthread_descr __thread_self(void) {
   asm("ear %0,%%a0" : "=d"(cur) );	/* a0 (access register 0) is used as thread pointer */
 #elif defined(__ia64__)
   asm("mov %0 = r13" : "=r"(cur) );	/* r13 (tp) is used as thread pointer */
+#elif defined(__x86_64__)
+  asm("mov %%fs:(16),%0" : "=r"(cur));
+#elif defined(__i386__)
+  if (__likely(__modern_linux==1))
+    asm("mov %%gs:(8),%0" : "=r"(cur));
+  else {
+    /* old cruft O(n*) */
+    cur=__thread_find_(getpid());
+    if (cur) UNLOCK(cur);
+  }
 #else	/* other */
   /* all other archs:
    * search the thread depending on the PID O(n*) */
@@ -336,6 +352,21 @@ static inline _pthread_descr __thread_set_register(void*arg) {
 #endif
   return (_pthread_descr)arg;
 }
+
+#ifdef WANT_TLS
+extern size_t __tdatasize, __tmemsize;
+extern void* __tdataptr;
+extern void __setup_tls(tcbhead_t* thread);
+#endif
+
+#ifdef WANT_SSP
+extern unsigned long __guard;
+#endif
+
+#if defined(WANT_TLS) || defined(WANT_SSP)
+extern tcbhead_t* __tcb_mainthread;
+#endif
+
 /* thread start helper */
 static void* __managed_start(void*arg) {
 #if defined(__sparc__)
@@ -345,7 +376,33 @@ static void* __managed_start(void*arg) {
 #else
   _pthread_descr td;
 #endif
+#if defined(WANT_TLS) || defined(WANT_SSP)
+  __tcb_mainthread->multiple_threads=1;
+  tcbhead_t* me=alloca(sizeof(tcbhead_t)
+#ifdef WANT_TLS
+		                        +__tmemsize);
+/*  printf("allocating %lu bytes (%lu + %lu)\n",sizeof(tcbhead_t)+__tmemsize,sizeof(tcbhead_t),__tmemsize); */
+  memcpy(me,__tdataptr,__tdatasize);
+  memset(((char*)me)+__tdatasize,0,__tmemsize-__tdatasize);
+  me=(tcbhead_t*)(((char*)me) + __tmemsize);
+#endif
+  __setup_tls(me);
+  me->multiple_threads=1;
+
+#ifdef WANT_SSP
+  me->pointer_guard=__guard ^ (uintptr_t)me;
+#endif
+  me->self=arg;
+  td=arg;
+  __thread_set_register(me);
+
+#else
   td=__thread_set_register(arg);
+#endif
+
+#ifdef WANT_TLS
+#endif
+
   td->pid=getpid();
 #ifdef DEBUG
   printf("__managed_start: %d pre suspend\n",td->pid);
diff --git a/libpthread/thread_internal.h b/libpthread/thread_internal.h
index e1d0704..ad382ba 100644
--- a/libpthread/thread_internal.h
+++ b/libpthread/thread_internal.h
@@ -13,6 +13,9 @@
 #error "the diet libc is not compiled with thread safeness enabled!"
 #endif
 
+extern int __modern_linux;	/* can be -1 (old linux), 0 (unknown), or 1 (new linux). */
+/* if 1, assume 2.6 kernel with TLS and futexes et al */
+
 #undef errno
 #define _errno_ (*__errno_location())
 
@@ -85,7 +88,6 @@ struct _pthread_descr_struct {
   int h_errno;
   struct res_state __res;
 #endif
-
 } __attribute__((aligned(32)));
 #define thread_sig_mask jmp_exit->__saved_mask
 
diff --git a/libregex/rx.c b/libregex/rx.c
index 8b60952..8ba4d45 100644
--- a/libregex/rx.c
+++ b/libregex/rx.c
@@ -243,12 +243,21 @@ match:
     return plus+matchlen;
 }
 
+static int closebracket(const char* s,const regex_t* r) {
+  if (r->cflags&REG_EXTENDED)
+    return *s==')';
+  else
+    return (*s=='\\' && s[1]==')');
+}
+
 static const char* parseatom(struct atom*__restrict__ a,const char*__restrict__ s,regex_t*__restrict__ rx) {
   const char *tmp;
   a->m=(matcher)matchatom;
   a->bnum=-1;
   switch (*s) {
   case '(':
+    if ((rx->cflags&REG_EXTENDED)==0) goto handle_char;
+openbracket:
     a->bnum=++rx->brackets;
     if (s[1]==')') {
       a->type=EMPTY;
@@ -256,11 +265,13 @@ static const char* parseatom(struct atom*__restrict__ a,const char*__restrict__
     }
     a->type=REGEX;
     tmp=parseregex(&a->u.r,s+1,rx);
-    if (*tmp==')')
-      return tmp+1;
+    if (closebracket(tmp,rx))
+      return tmp+1+((rx->cflags&REG_EXTENDED)==0);
+  case ')':
+    if ((rx->cflags&REG_EXTENDED)==0) goto handle_char;
+    /* fall through */
   case 0:
   case '|':
-  case ')':
     return s;
   case '[':
     a->type=BRACKET;
@@ -288,9 +299,13 @@ static const char* parseatom(struct atom*__restrict__ a,const char*__restrict__
       a->type=BACKREF;
       a->u.c=*s-'0';
       break;
+    } else if ((rx->cflags&REG_EXTENDED)==0) {
+      if (*s=='(') goto openbracket; else
+      if (*s==')') return s-1;
     }
     /* fall through */
   default:
+handle_char:
     a->type=CHAR;
     if (rx->cflags&REG_ICASE) {
       a->u.c=tolower(*s);
@@ -483,7 +498,7 @@ static const char* parseregex(struct regex*__restrict__ r,const char*__restrict_
   }
   for (;;) {
     tmp=parsebranch(&b,s,p,&r->pieces);
-    if (tmp==s && *s!=')') return s;
+    if (tmp==s && !closebracket(s,p)) return s;
 //    printf("r->b from %p to ",r->b);
     {
       struct branch* tmp;
@@ -493,13 +508,13 @@ static const char* parseregex(struct regex*__restrict__ r,const char*__restrict_
     }
 //    printf("%p (size %d)\n",r->b,r->num*sizeof(b));
     r->b[r->num-1]=b;
-    if (*s==')') {
+    if (closebracket(s,p)) {
       r->b[r->num-1].m=matchempty;
       return s;
     }
 //    printf("assigned branch %d at %p\n",r->num-1,r->b);
     s=tmp;
-    if (*s==')') return s;
+    if (closebracket(s,p)) return s;
     if (*s=='|') ++s;
   }
   return tmp;
diff --git a/librpc/pmap_clnt.c b/librpc/pmap_clnt.c
index 9dbf3f6..f6bf03e 100644
--- a/librpc/pmap_clnt.c
+++ b/librpc/pmap_clnt.c
@@ -52,11 +52,7 @@ static struct timeval tottimeout = { 60, 0 };
  * Set a mapping between program,version and port.
  * Calls the pmap service remotely to do the mapping.
  */
-bool_t pmap_set(program, version, protocol, port)
-unsigned long program;
-unsigned long version;
-int protocol;
-unsigned short port;
+bool_t pmap_set(const unsigned long program, const unsigned long version, int protocol, unsigned short port)
 {
 	struct sockaddr_in myaddress;
 	int socket = -1;
diff --git a/libugly/wmemmove.c b/libugly/wmemmove.c
new file mode 100644
index 0000000..b4bd589
--- /dev/null
+++ b/libugly/wmemmove.c
@@ -0,0 +1,12 @@
+#include <wchar.h>
+
+wchar_t *wmemmove(wchar_t *dest, const wchar_t *src, size_t n) {
+  size_t i;
+  if (src<dest && dest<src+n)
+    for (i=0; i<n; ++i)
+      dest[n-i-1]=src[n-i-1];
+  else
+    for (i=0; i<n; ++i)
+      dest[i]=src[i];
+  return dest;
+}
diff --git a/mips/divdi3.c b/mips/divdi3.c
index df6a5d2..18d8a2b 100644
--- a/mips/divdi3.c
+++ b/mips/divdi3.c
@@ -23,21 +23,6 @@
 
 #if __WORDSIZE == 32
 
-typedef unsigned int UQItype	__attribute__ ((mode (QI)));
-typedef          int SItype	__attribute__ ((mode (SI)));
-typedef unsigned int USItype	__attribute__ ((mode (SI)));
-typedef          int DItype	__attribute__ ((mode (DI)));
-typedef unsigned int UDItype	__attribute__ ((mode (DI)));
-#define Wtype SItype
-#define HWtype SItype
-#define DWtype DItype
-#define UWtype USItype
-#define UHWtype USItype
-#define UDWtype UDItype
-#define W_TYPE_SIZE 32
-
-#include "longlong.h"
-
 const
 unsigned char __clz_tab[] =
 {
@@ -51,6 +36,21 @@ unsigned char __clz_tab[] =
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
 };
 
+#include "mips/longlong.h"
+
+typedef unsigned int UQItype	__attribute__ ((mode (QI)));
+typedef          int SItype	__attribute__ ((mode (SI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+typedef          int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+#define Wtype SItype
+#define HWtype SItype
+#define DWtype DItype
+#define UWtype USItype
+#define UHWtype USItype
+#define UDWtype UDItype
+#define W_TYPE_SIZE 32
+
 #if __BYTE_ORDER == __BIG_ENDIAN
 struct DWstruct { Wtype high, low;};
 #elif __BYTE_ORDER == __LITTLE_ENDIAN
@@ -318,7 +318,7 @@ __moddi3 (DWtype u, DWtype v)
     }
   if (v < 0)
     v = -v;
-  __udivmoddi4 (u, v, &w);
+  __udivmoddi4 (u, v, (UDWtype *) &w);
   if (c)
     w = -w;
   return w;
diff --git a/parisc/clone.S b/parisc/clone.S
index 2846f3b..7a13996 100644
--- a/parisc/clone.S
+++ b/parisc/clone.S
@@ -37,4 +37,4 @@ __clone:
 	bl	_exit,%r2		/* exit thread */
 	copy	%r28,%r26		/* return -> arg0 */
 
-	iitlbp	%r0,(%r0)		/* DIE ! DIE ! */
+/*	iitlbp	%r0,(%r0) */		/* DIE ! DIE ! */
diff --git a/ppc64/__longjmp.S b/ppc64/__longjmp.S
index d4e4caa..f8f7472 100644
--- a/ppc64/__longjmp.S
+++ b/ppc64/__longjmp.S
@@ -1,5 +1,9 @@
 #include <setjmp.h>
 
+	.globl __longjmp
+	.section	".opd","aw"
+	.align 3
+__longjmp:
 		.quad	.__longjmp,.TOC.@tocbase,0
 		.text
 		.size	__longjmp,24
diff --git a/ppc64/setjmp.S b/ppc64/setjmp.S
index 724bcf2..948974e 100644
--- a/ppc64/setjmp.S
+++ b/ppc64/setjmp.S
@@ -6,6 +6,11 @@
 #define JUMPTARGET(name) .name
 #endif
 
+
+	.globl __sigsetjmp
+	.section	".opd","aw"
+	.align 3
+__sigsetjmp:
 		.quad	.__sigsetjmp,.TOC.@tocbase,0
 		.text
 		.size	__sigsetjmp,24
diff --git a/syscalls.s/fallocate.S b/syscalls.s/fallocate.S
new file mode 100644
index 0000000..ca64330
--- /dev/null
+++ b/syscalls.s/fallocate.S
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_fallocate
+syscall(fallocate,fallocate)
+#endif
diff --git a/t.c b/t.c
index 987e070..a48d25f 100644
--- a/t.c
+++ b/t.c
@@ -103,7 +103,7 @@ int compint(const void *a, const void *b) {
 extern char* strcpy2(char*a,char*b);
 
 #define rdtscl(low) \
-     __asm__ __volatile__ ("rdtsc" : "=a" (low) : : "edx")
+     __asm__ __volatile__ ("rdtscp" : "=a" (low) : : "ecx","edx")
 
 #define malloc(x) ({typeof(x) y=x; (y<0 || (size_t)(y)!=y ? 0 : malloc(y));})
 
diff --git a/test/regex.c b/test/regex.c
index 9be81e3..d932d22 100644
--- a/test/regex.c
+++ b/test/regex.c
@@ -109,7 +109,7 @@ int main() {
   assert(regexec(&r,"mail.b-net.com.ua",0,NULL,0)==0);
   regfree(&r);
 
-  assert(regcomp(&r,"(foo)bar\\1",0)==0);
+  assert(regcomp(&r,"\\(foo\\)bar\\1",0)==0);
   assert(regexec(&r,"foobarfoo",10,matches,0)==0);
   regfree(&r);
 
diff --git a/x86_64/memchr.S b/x86_64/memchr.S
new file mode 100644
index 0000000..866a695
--- /dev/null
+++ b/x86_64/memchr.S
@@ -0,0 +1,40 @@
+.text
+.global memchr
+.type memchr,@function
+memchr:	/* rdi=ptr, esi=ch, rdx=len */
+  and $0xff,%esi
+  test %rdx,%rdx
+  jz .Lnull		/* if (!len) return 0 */
+  imul $0x1010101,%esi	/* esi = ch x 4 */
+
+  mov %rdi,%rcx
+  and $15,%ecx
+  movd %esi,%xmm0
+  lea (%rdi,%rdx),%rsi	/* rsi = max ptr */
+  and $~15,%rdi		/* 16-align rdi, diff in cl */
+  or $-1,%eax
+  shl %cl,%eax
+
+  pshufd $0,%xmm0,%xmm0	/* xmm0 = ch x 16 */
+1:
+  movdqa (%rdi),%xmm1
+  pcmpeqb %xmm0,%xmm1
+  pmovmskb %xmm1,%ecx
+  and %eax,%ecx
+  jnz .Lfound	/* found something */
+  lea 16(%rdi),%rdi
+  or $-1,%eax
+  cmp %rsi,%rdi
+  jb 1b
+  jmp .Lnull
+.Lfound:
+  bsf %ecx,%eax
+  add %rdi,%rax
+  cmp %rsi,%rax
+  ja .Lnull
+  ret
+.Lnull:
+  xor %eax,%eax
+  ret
+.Lhere:
+.size memchr,.Lhere-memchr
diff --git a/x86_64/strlen.S b/x86_64/strlen.S
new file mode 100644
index 0000000..5c13a8c
--- /dev/null
+++ b/x86_64/strlen.S
@@ -0,0 +1,32 @@
+.text
+.global strlen
+.type strlen,@function
+strlen:
+        mov %rdi,%rax
+        mov %edi,%ecx
+        pxor %xmm0,%xmm0
+        and $15,%ecx
+        and $-16,%rax
+        movdqa (%rax),%xmm1
+        pcmpeqb %xmm0,%xmm1
+        pmovmskb %xmm1,%edx
+        shr %cl,%edx
+        shl %cl,%edx
+        test %edx,%edx
+        jnz .L2
+.L1:
+        lea 16(%rax),%rax
+        movdqa (%rax),%xmm1
+        pcmpeqb %xmm0,%xmm1
+        pmovmskb %xmm1,%edx
+        test %edx,%edx
+        jz .L1
+.L2:
+        sub %rax,%rdi
+        bsf %edx,%eax
+        sub %rdi,%rax
+        ret
+
+.Lhere:
+        .size    strlen,.Lhere-strlen
+
diff --git a/x86_64/strnlen.S b/x86_64/strnlen.S
new file mode 100644
index 0000000..868dbaf
--- /dev/null
+++ b/x86_64/strnlen.S
@@ -0,0 +1,20 @@
+.text
+.global strnlen
+.type strnlen,@function
+strnlen:
+	/* incoming: rdi = ptr, rsi = len */
+	mov %rdi,%r8
+	mov %rsi,%r9
+	mov %rsi,%rdx
+	xor %esi,%esi
+	call memchr
+	test %rax,%rax
+	jz .Lnotfound
+	sub %r8,%rax
+	ret
+.Lnotfound:
+	mov %r9,%rax
+	ret
+
+.Lhere:
+	.size	 strnlen,.Lhere-strnlen
diff --git a/x86_64/syscalls.h b/x86_64/syscalls.h
index 23966cb..23e34ec 100644
--- a/x86_64/syscalls.h
+++ b/x86_64/syscalls.h
@@ -334,6 +334,17 @@
 #define __NR_fallocate		285
 #define __NR_timerfd_settime	286
 #define __NR_timerfd_gettime	287
+#define __NR_accept4		288
+#define __NR_signalfd4		289
+#define __NR_eventfd2		290
+#define __NR_epoll_create1	291
+#define __NR_dup3		292
+#define __NR_pipe2		293
+#define __NR_inotify_init1	294
+#define __NR_preadv		295
+#define __NR_pwritev		296
+#define __NR_rt_tgsigqueueinfo	297
+#define __NR_perf_event_open	298
 
 #ifdef __PIC__
 #define syscall_weak(name,wsym,sym) \
-- 
1.7.0

