From 9c64149007229a0c5ea49d6cfa086de0b54c6604 Mon Sep 17 00:00:00 2001
From: Gerrit Pape <pape@smarden.org>
Date: Thu, 3 May 2007 09:04:32 +0000
Subject: [PATCH] cvs snapshot 200705030800.

---
 .cvsignore                          |    1 +
 CHANGES                             |   60 +++++++++++-
 FAQ                                 |   18 +++-
 Makefile                            |    8 +-
 TODO                                |    3 +
 arm/syscalls.h                      |   12 ++
 contrib/dnsd.c                      |  171 ++++++++++++-------------------
 diet.c                              |    2 +-
 dynlinker/ldso_start.S              |   16 +++
 i386/dyn_syscalls.S                 |    2 +
 i386/syscalls.h                     |   26 +++++
 ia64/syscalls.h                     |   22 ++++
 include/elf.h                       |    3 +
 include/pthread.h                   |    4 +
 include/resolv.h                    |    2 +
 include/stdio.h                     |    4 +-
 include/stdlib.h                    |    2 +-
 include/sys/prctl.h                 |   61 +++++++++++-
 include/sys/stat.h                  |  115 +++++++++++----------
 include/sys/tls.h                   |   62 +++++++++++
 include/termios.h                   |    4 +-
 include/time.h                      |    1 +
 include/unistd.h                    |    8 +-
 lib/__dtostr.c                      |   13 ++-
 lib/__fstatfs64.c                   |    2 +-
 lib/__getcwd.c                      |   12 ++-
 lib/__v_printf.c                    |   74 +++++++++-----
 lib/cfgetospeed.c                   |    4 +-
 lib/ftw.c                           |    5 +-
 lib/ftw64.c                         |   51 +++++++++-
 lib/if_nameindex.c                  |   10 +-
 lib/if_nametoindex.c                |    9 +-
 lib/putenv.c                        |    6 +-
 lib/qsort.c                         |  192 +++++++----------------------------
 lib/stackgap.c                      |   42 ++++++++-
 libcompat/getdelim.c                |    5 +-
 libcompat/getline.c                 |    1 +
 libcruft/dn_skipname.c              |   19 ++++
 libcruft/dnscruft.c                 |    3 +-
 libcruft/dnscruft2.c                |    1 -
 libcruft/getopt_long.c              |   55 ++++++----
 libcruft/getopt_long_only.c         |   55 ++++++----
 libcruft/res_mkquery.c              |   10 ++-
 libcruft/res_query.c                |   29 +++---
 libcruft/tempnam.c                  |    1 +
 libdl/_dl_int.h                     |    5 +
 libdl/_dl_main.c                    |    6 +
 libdl/_dl_relocate.c                |   21 ++++-
 libdl/dlsym.c                       |   91 ++++++++++++-----
 libdl/gnu_hash.h                    |   16 +++
 libpthread/pthread_cond_timedwait.c |    5 +-
 libpthread/pthread_internal.c       |    9 ++-
 libpthread/thread_internal.h        |    2 +-
 librpc/clnt_simple.c                |    7 +-
 librpc/svc_auth_unix.c              |    4 +-
 libshell/dirname.c                  |    2 +-
 libstdio/ftell.c                    |    9 +-
 libugly/ctime_r.c                   |    5 +
 libugly/getaddrinfo.c               |  157 +++++++++++++---------------
 libugly/iconv.c                     |    1 -
 libugly/strftime.c                  |    1 +
 libugly/strndup.c                   |    7 ++
 libugly/strptime.c                  |   38 ++++---
 libugly/strsignal.c                 |    2 +-
 mips/syscalls.h                     |   26 +++++
 ppc/syscalls.h                      |   23 ++++
 ppc64/syscalls.h                    |   23 ++++
 s390/syscalls.h                     |   22 ++++
 s390x/syscalls.h                    |   24 +++++
 sparc/syscalls.h                    |   18 ++++
 sparc64/longjmp.S                   |    2 +-
 sparc64/syscalls.h                  |   18 ++++
 syscalls.s/__guard.S                |    5 +
 test/ftell.c                        |   26 +++++
 test/getaddrinfo.c                  |    2 +-
 test/getopt.c                       |  129 ++++++++++++------------
 test/qsort.c                        |   78 ++++++++++++++
 x86_64/Makefile.add                 |    1 +
 x86_64/arch_prctl.S                 |    3 +
 x86_64/dyn_syscalls.S               |    2 +
 x86_64/getpriority.S                |   12 ++
 x86_64/syscalls.h                   |   24 +++++
 82 files changed, 1372 insertions(+), 660 deletions(-)
 create mode 100644 include/sys/tls.h
 create mode 100644 libcruft/dn_skipname.c
 create mode 100644 libdl/gnu_hash.h
 create mode 100644 libugly/ctime_r.c
 create mode 100644 test/ftell.c
 create mode 100644 test/qsort.c
 create mode 100644 x86_64/arch_prctl.S
 create mode 100644 x86_64/getpriority.S

diff --git a/.cvsignore b/.cvsignore
index 7e94d08..8304777 100644
--- a/.cvsignore
+++ b/.cvsignore
@@ -26,4 +26,5 @@ pic-s390
 pic-sparc64
 bin-ia64
 bin-x86_64
+pic-x86_64
 cycles
diff --git a/CHANGES b/CHANGES
index cfbebdc..7c45414 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,3 +1,61 @@
+0.31:
+  getopt_long and getopt_long_only now refuse ambiguous abbreviations
+  fix printf %u/%x on 64-bit platforms
+  fix fd leak in if_nameindex (Florian Westphal)
+  fix printf %g (well, get closer)
+  fix sparc64 longjmp (Rene Rebe)
+  add dn_skipname
+  add pthread prototypes that are needed to compile libgcc when
+    compiling a cross compiler gcc
+  fix ftw64
+  fixes for some corner cases from Ilja van Sprundel:
+    - tempnam
+    - strsignal
+    - strftime
+    - sunrpc code
+  faster qsort
+  support %j in printf (Gernot Tenchio)
+  do omit the frame pointer on x86_64
+  fix pthread_cond_timedwait (Gernot Tenchio)
+  fix getcwd, ftw, ftw64, dirname (Ilja van Sprundel)
+    Some fd leaks in error conditions.
+  fix stackguard to be .quad instead of .long (cause subtle memory
+    corruption, which in most cases caused DNS lookups to fail on 64-bit
+    platforms)
+  fix dynamic build
+  do the magic required for -fstack-protector in gcc 4.1.1 to actually
+    work (which includes setting up thread local storage), so far on
+    i386 and amd64
+  add ctime_r (for c-icap, Gernot Tenchio)
+  fix strptime return value (Gernot Tenchio)
+  fix R_386_32, R_ARM_ABS32, R_X86_64_64 in libdl (Gernot Tenchio)
+  Olaf: Added DT_GNU_HASH symbol resolver.
+  fix security bug in librpc.  You know, librpc, that stinking Sun code
+    full of problems?  Just adding that code was a bad mistake, I think.
+    I tried auditing it, but I nearly got a brain tumor when I opened
+    those files.  Thanks to Ilja van Sprundel for finding this bug (with
+    Google codesearch, no less! :-) )
+  accept mDNS packets with set recursion desired bit
+  add const to cfgetispeed and cfgetospeed arguments
+  fix off-by-one in getdelim (reported by Ilja van Sprundel)
+  prevent integer overflows in printf (return -1, like Solaris)
+  fix putenv (Nikola Vladov)
+  use time_t in struct stat for the time values
+  support LLMNR in dnsd (no idea if it works, apparently only Vista
+    supports it)
+  fix ftell (Jens Laas)
+  fix getaddrinfo (return more than just the first IP) (Gernot Tenchio)
+  make sure to declare __dietlibc__ during compilation of the lib
+    itself, so we can have more portable code in the libc code behind
+    #ifndef __dietlibc__ (see ftw64 for an example)
+  fix off-by-one in iconv
+  add missing brackets in dn_skipname
+  strptime also fills in tm_wday and tm_yday (Gernot Tenchio)
+  x86-64 getpriority has bias 20 (Rene Rebe)
+  fix typo in fstatfs64 (Gernot Tenchio)
+  fix infinite loop in getaddrinfo (Nikola Vladov)
+  don't include sys/stat.h in stdio.h and unistd.h (Gernot Tenchio)
+
 0.30:
   put exception handling frames in read-only section on AMD64 and S/390
   make sys/stat.h ILP64 compatible
@@ -51,7 +109,7 @@
   fix unlockpt (Gernot Tenchio)
   Olaf: fixing putenv for the situation that environ is NULL
     (situation after a clearenv)
-  HP-PA fixes (Micah Anderson, Hubert Poetzl)
+  HP-PA fixes (Micah Anderson, Herbert Poetzl)
   syscall() for ppc/64
   make __kernel_size_t more like the real thing (Rene Rebe)
   fix __exec_shell (execv and execvp) (Gernot Tenchio)
diff --git a/FAQ b/FAQ
index 177f77c..b004629 100644
--- a/FAQ
+++ b/FAQ
@@ -300,7 +300,7 @@ A: Use size(1) to find the real size, like this:
 
 
 Q: I get an error message at link time, that "main" can not be found.
-A: Disable WANT_STACKGAP in dietfeautres.h or try upgrading your binutils.
+A: Disable WANT_STACKGAP in dietfeatures.h or try upgrading your binutils.
 
 
 Q: I want to have a gcc that uses the diet libc by default.
@@ -315,3 +315,19 @@ A: You will have to edit the "specs" file from gcc then.  John K. Hohm
    %{shared:dyn_so_start.o%s}%{!shared:%{static:start.o%s dyn_start.o%s}%{!static:dstart.o%s dyn_dstart.o%s}}
 
 
+Q: Dynamically linked binaries don't work on Fedora 6!
+A: Fedora 6 ships with binutils that can create non-standard ELF
+   binaries, and they hacked their gcc to generate them by default.  You
+   can see whether your gcc also does this with
+
+     gcc -dumpspecs|grep "hash-style=gnu"
+
+   and you can see if a shared library was build with this flag with
+
+     readelf -S libname.so|grep GNU_HASH
+
+   You can override this behavior like this:
+
+     diet-dyn gcc -Wl,--hash-style=sysv -shared -o libx.so x.c
+                  ^^^^^^^^^^^^^^^^^^^^^
+
diff --git a/Makefile b/Makefile
index 7d93464..fc5062f 100644
--- a/Makefile
+++ b/Makefile
@@ -186,6 +186,8 @@ SAFE_CFLAGS=$(CFLAGS)
 SAFER_CFLAGS=$(CFLAGS)
 endif
 
+CC+=-D__dietlibc__
+
 $(OBJDIR)/crypt.o: libcrypt/crypt.c
 	$(CROSS)$(CC) $(INC) $(SAFER_CFLAGS) -c $< -o $@
 
@@ -227,9 +229,6 @@ $(OBJDIR)/libm.a: $(LIBMATHOBJ)
 
 LD_UNSET = env -u LD_RUN_PATH
 
-$(OBJDIR)/libdietc.so: $(OBJDIR)/dietlibc.a
-	$(LD_UNSET) $(CROSS)ld -whole-archive -shared -o $@ $^
-
 dyn: dyn_lib
 
 # added dynamic linker
@@ -512,3 +511,6 @@ $(OBJDIR)/fcntl64.o: dietfeatures.h
 
 # WANT_SSP
 $(OBJDIR)/stackgap.o: dietfeatures.h
+
+# WANT_MALLOC_ZERO
+$(OBJDIR)/strndup.o: dietfeatures.h
diff --git a/TODO b/TODO
index 7a22e72..b955ef0 100644
--- a/TODO
+++ b/TODO
@@ -29,3 +29,6 @@
 implement AI_V4MAPPED in getaddrinfo (not in man page, only susv3)
 
 Also: AF_UNSPEC, AI_ADDRCONFIG
+set_thread_area -> set up TLD, for stack guard
+
+lsearch, lfind, hsearch, tsearch
diff --git a/arm/syscalls.h b/arm/syscalls.h
index ad1998a..a5fa27a 100644
--- a/arm/syscalls.h
+++ b/arm/syscalls.h
@@ -290,7 +290,19 @@
 #define __NR_inotify_init		(__NR_SYSCALL_BASE+316)
 #define __NR_inotify_add_watch		(__NR_SYSCALL_BASE+317)
 #define __NR_inotify_rm_watch		(__NR_SYSCALL_BASE+318)
+#define __NR_mbind			(__NR_SYSCALL_BASE+319)
+#define __NR_get_mempolicy		(__NR_SYSCALL_BASE+320)
+#define __NR_set_mempolicy		(__NR_SYSCALL_BASE+321)
 
+/*
+ * The following SWIs are ARM private.
+ */
+#define __ARM_NR_BASE			(__NR_SYSCALL_BASE+0x0f0000)
+#define __ARM_NR_breakpoint		(__ARM_NR_BASE+1)
+#define __ARM_NR_cacheflush		(__ARM_NR_BASE+2)
+#define __ARM_NR_usr26			(__ARM_NR_BASE+3)
+#define __ARM_NR_usr32			(__ARM_NR_BASE+4)
+#define __ARM_NR_set_tls		(__ARM_NR_BASE+5)
 
 /* ok the next few values are for the optimization of the unified syscalls
  * on arm.
diff --git a/contrib/dnsd.c b/contrib/dnsd.c
index 6f5d2ac..7ea1a9c 100644
--- a/contrib/dnsd.c
+++ b/contrib/dnsd.c
@@ -18,20 +18,23 @@ char myhostname[100];
 int namelen;
 struct sockaddr* peer;
 socklen_t sl;
+/* zeroconf/bonjour */
 int s6,s4;
+/* llmnr */
+int ls6,ls4;
 char ifname[10];
 
 struct sockaddr_in mysa4;
 struct sockaddr_in6 mysa6;
 
-static void handle(int s,char* buf,int len,int interface) {
+static void handle(int s,char* buf,int len,int interface,int llmnr) {
   int q;
   char* obuf=buf;
   char* after;
   int olen=len;
   if (len<8*2) return;			/* too short */
   buf[len]=0;
-  if ((buf[2]&0xf8) != 0) return;		/* not query */
+  if ((buf[2]&(llmnr?0xfd:0xf8)) != 0) return;		/* not query */
   q=(((unsigned int)(buf[4])) << 8) | buf[5];
   if (q!=1) return;			/* cannot handle more than 1 query */
   if (buf[6] || buf[7]) return;		/* answer count must be 0 */
@@ -101,7 +104,7 @@ static void handle(int s,char* buf,int len,int interface) {
 
 struct sockaddr_in sa4;
 struct sockaddr_in6 sa6;
-struct pollfd pfd[2];
+struct pollfd pfd[4];
 
 struct msghdr mh;
 struct iovec iv;
@@ -174,13 +177,13 @@ static int v4if() {
   return 0;
 }
 
-static void recv4() {
+static void recv4(int s) {
   int len;
   int interface;
 
   mh.msg_name=&sa4;
   mh.msg_namelen=sizeof(sa4);
-  if ((len=recvmsg(s4,&mh,0))==-1) {
+  if ((len=recvmsg(s,&mh,0))==-1) {
     perror("recvmsg");
     exit(3);
   }
@@ -190,15 +193,15 @@ static void recv4() {
   interface=v4if();
   getip(interface);
 
-  handle(s4,buf,len,interface);
+  handle(s,buf,len,interface,s==ls4);
 }
 
-static void recv6() {
+static void recv6(int s) {
   int len,interface;
 
   mh.msg_name=&sa6;
   mh.msg_namelen=sizeof(sa6);
-  if ((len=recvmsg(s6,&mh,0))==-1) {
+  if ((len=recvmsg(s,&mh,0))==-1) {
     perror("recvmsg");
     exit(3);
   }
@@ -212,34 +215,22 @@ static void recv6() {
 
   getip(interface);
 
-  handle(s6,buf,len,interface);
+  handle(s,buf,len,interface,s==ls6);
 }
 
-int main() {
-  mh.msg_name=&sa4;
-  mh.msg_namelen=sizeof(sa4);
-  mh.msg_iov=&iv;
-  mh.msg_iovlen=1;
-  iv.iov_base=buf;
-  iv.iov_len=PKGSIZE;
-  mh.msg_control=abuf;
-  mh.msg_controllen=sizeof(abuf);
-
-  if (gethostname(myhostname,64)==-1) {
-    perror("gethostname");
-    return 1;
-  }
-  namelen=strlen(myhostname);
+static void init_sockets(int* sock6,int* sock4,int port,char* v6ip,char* v4ip) {
+  int s4,s6;
+  *sock6=-1; *sock4=-1;
   s6=socket(PF_INET6,SOCK_DGRAM,IPPROTO_UDP);
   s4=socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);
   if (s4==-1 && s6==-1) {
     perror("socket");
-    return 2;
+    return;
   }
   if (s6!=-1) {
     memset(&sa6,0,sizeof(sa6));
     sa6.sin6_family=PF_INET6;
-    sa6.sin6_port=htons(5353);
+    sa6.sin6_port=htons(port);
     if (bind(s6,(struct sockaddr*)&sa6,sizeof(struct sockaddr_in6))==-1) {
       perror("bind IPv6");
       close(s6);
@@ -249,7 +240,7 @@ int main() {
   if (s4!=-1) {
     memset(&sa4,0,sizeof(sa4));
     sa4.sin_family=PF_INET;
-    sa4.sin_port=htons(5353);
+    sa4.sin_port=htons(port);
     if (bind(s4,(struct sockaddr*)&sa4,sizeof(struct sockaddr_in))==-1) {
       if (errno!=EADDRINUSE || s6==-1)
 	perror("bind IPv4");
@@ -257,7 +248,7 @@ int main() {
       s4=-1;
     }
   }
-  if (s4==-1 && s6==-1) return 2;
+  if (s4==-1 && s6==-1) return;
 
   {
     int val=255;
@@ -266,7 +257,7 @@ int main() {
       struct ipv6_mreq opt;
       setsockopt(s6,IPPROTO_IPV6,IPV6_UNICAST_HOPS,&val,sizeof(val));
       setsockopt(s6,IPPROTO_IPV6,IPV6_MULTICAST_LOOP,&one,sizeof(one));
-      memcpy(&opt.ipv6mr_multiaddr,"\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfb",16);
+      memcpy(&opt.ipv6mr_multiaddr,v6ip,16);
       opt.ipv6mr_interface=0;
       setsockopt(s6,IPPROTO_IPV6,IPV6_ADD_MEMBERSHIP,&opt,sizeof opt);
 //      setsockopt(s6,IPPROTO_IPV6,IPV6_PKTINFO,&one,sizeof one);
@@ -275,95 +266,61 @@ int main() {
       struct ip_mreq opt;
       int s=(s4==-1?s6:s4);
       setsockopt(s,SOL_IP,IP_TTL,&val,sizeof(val));
-      memcpy(&opt.imr_multiaddr.s_addr,"\xe0\x00\x00\xfb",4);
+      memcpy(&opt.imr_multiaddr.s_addr,v4ip,4);
       opt.imr_interface.s_addr=0;
       setsockopt(s,IPPROTO_IP,IP_ADD_MEMBERSHIP,&opt,sizeof(opt));
       setsockopt(s,SOL_IP,IP_PKTINFO,&one,sizeof one);
     }
   }
 
-  for (;;) {
-    /* 1500 is the MTU for UDP, I figure we won't longer packets */
-    /* add 1 to be able to add \0 */
-    int len;
-    int interface=0;
-    if (s4!=-1 && s6!=-1) {
-      if (s4!=-1) {
-	recv4();
-#if 0
-	if ((len=recvmsg(s4,&mh,0))==-1) {
-	  perror("recvmsg");
-	  return 3;
-	}
-	peer=(struct sockaddr*)&sa4;
-	sl=sizeof(sa4);
-
-	for (x=CMSG_FIRSTHDR(&mh); x; x=CMSG_NXTHDR(&mh,x))
-	  if (x->cmsg_level==SOL_IP && x->cmsg_type==IP_PKTINFO) {
-	    struct in_pktinfo* y=(struct in_pktinfo*)(CMSG_DATA(x));
-	    interface=y->ipi_ifindex;
-	    break;
-	  }
+  *sock4=s4;
+  *sock6=s6;
+}
 
-	handle(s4,buf,len,interface);
-#endif
-      } else {
-	recv6();
-#if 0
-	sl=sizeof(sa6);
-	if ((len=recvfrom(s6,buf,PKGSIZE,0,(struct sockaddr*)&sa6,&sl))==-1) {
-	  perror("recvfrom");
-	  return 3;
-	}
-	peer=(struct sockaddr*)&sa6;
+int main() {
+  int n=-1;
+  mh.msg_name=&sa4;
+  mh.msg_namelen=sizeof(sa4);
+  mh.msg_iov=&iv;
+  mh.msg_iovlen=1;
+  iv.iov_base=buf;
+  iv.iov_len=PKGSIZE;
+  mh.msg_control=abuf;
+  mh.msg_controllen=sizeof(abuf);
 
-	handle(s6,buf,len,sa6.sin6_scope_id);
-#endif
-      }
-    } else {
-      pfd[0].fd=s4; pfd[0].events=POLLIN;
-      pfd[1].fd=s6; pfd[1].events=POLLIN;
-      switch (poll(pfd,2,5*1000)) {
-      case -1:
-	if (errno==EINTR) continue;
-	perror("poll");
-	return 1;
-      case 0:
-	continue;
-      }
-      if (pfd[0].revents & POLLIN) {
-	recv4();
-#if 0
-	if ((len=recvmsg(s4,&mh,0))==-1) {
-	  perror("recvmsg");
-	  return 3;
-	}
-	peer=(struct sockaddr*)&sa4;
-	sl=sizeof(sa4);
+  if (gethostname(myhostname,64)==-1) {
+    perror("gethostname");
+    return 1;
+  }
+  namelen=strlen(myhostname);
 
-	for (x=CMSG_FIRSTHDR(&mh); x; x=CMSG_NXTHDR(&mh,x))
-	  if (x->cmsg_level==SOL_IP && x->cmsg_type==IP_PKTINFO) {
-	    struct in_pktinfo* y=(struct in_pktinfo*)(CMSG_DATA(x));
-	    interface=y->ipi_ifindex;
-	    break;
-	  }
+  init_sockets(&s6,&s4,5353,"\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfb","\xe0\x00\x00\xfb");
+  init_sockets(&ls6,&ls4,5355,"\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x03","\xe0\x00\x00\xfc");
 
-	handle(s4,buf,len,interface);
-#endif
-      }
-      if (pfd[1].revents & POLLIN) {
-	recv6();
-#if 0
-	sl=sizeof(sa6);
-	if ((len=recvfrom(s6,buf,sizeof(buf),0,(struct sockaddr*)&sa6,&sl))==-1) {
-	  perror("recvfrom");
-	  return 3;
-	}
-	peer=(struct sockaddr*)&sa6;
-	handle(s6,buf,len,sa6.sin6_scope_id);
-#endif
-      }
+  pfd[0].events=pfd[1].events=pfd[2].events=pfd[3].events=POLLIN;
+  if (s6!=-1) pfd[++n].fd=s6;
+  if (s4!=-1) pfd[++n].fd=s4;
+  if (ls6!=-1) pfd[++n].fd=ls6;
+  if (ls4!=-1) pfd[++n].fd=ls4;
+  if (!++n)
+    return 2;
+  for (;;) {
+    int i;
+    switch (poll(pfd,n,5*1000)) {
+    case -1:
+      if (errno==EINTR) continue;
+      perror("poll");
+      return 1;
+    case 0:
+      continue;
     }
+    for (i=0; i<n; ++i)
+      if (pfd[i].revents & POLLIN) {
+	if (pfd[i].fd==s6 || pfd[i].fd==ls6)
+	  recv6(pfd[i].fd);
+	else
+	  recv4(pfd[i].fd);
+      }
   }
   return 0;
 }
diff --git a/diet.c b/diet.c
index 0659722..9864a2c 100644
--- a/diet.c
+++ b/diet.c
@@ -28,7 +28,7 @@ static const char* Os[] = {
   "i386","-Os","-mpreferred-stack-boundary=2",
 	 "-falign-functions=1","-falign-jumps=1",
 	 "-falign-loops=1","-fomit-frame-pointer",0,
-  "x86_64","-Os","-fno-omit-frame-pointer",0,
+  "x86_64","-Os",0,
   "sparc","-Os","-mcpu=supersparc",0,
   "sparc64","-Os","-m64","-mhard-quad-float",0,
   "alpha","-Os","-fomit-frame-pointer",0,
diff --git a/dynlinker/ldso_start.S b/dynlinker/ldso_start.S
index 6243c45..ca278d7 100644
--- a/dynlinker/ldso_start.S
+++ b/dynlinker/ldso_start.S
@@ -1,3 +1,5 @@
+#include <endian.h>
+
 .text
 .globl ldso_start
 ldso_start:
@@ -68,7 +70,21 @@ errno:
 environ:
 .global __environ
 __environ:
+#if __WORDSIZE == 64
+	.quad 0
+#else
 	.long 0
+#endif
+
+.global environ
+environ:
+.global __environ
+__environ:
+#if __WORDSIZE == 64
+	.quad 0
+#else
+	.long 0
+#endif
 
 .global fini_entry
 fini_entry:
diff --git a/i386/dyn_syscalls.S b/i386/dyn_syscalls.S
index cece231..678d9c3 100644
--- a/i386/dyn_syscalls.S
+++ b/i386/dyn_syscalls.S
@@ -388,3 +388,5 @@ __unified_syscall:
 
 #include "__longjmp.S"
 #include "setjmp.S"
+
+#include "syscalls.s/__guard.S"
diff --git a/i386/syscalls.h b/i386/syscalls.h
index 3a08854..268fd25 100644
--- a/i386/syscalls.h
+++ b/i386/syscalls.h
@@ -292,6 +292,32 @@
 #define __NR_inotify_init	291
 #define __NR_inotify_add_watch	292
 #define __NR_inotify_rm_watch	293
+#define __NR_migrate_pages	294
+#define __NR_openat		295
+#define __NR_mkdirat		296
+#define __NR_mknodat		297
+#define __NR_fchownat		298
+#define __NR_futimesat		299
+#define __NR_fstatat64		300
+#define __NR_unlinkat		301
+#define __NR_renameat		302
+#define __NR_linkat		303
+#define __NR_symlinkat		304
+#define __NR_readlinkat		305
+#define __NR_fchmodat		306
+#define __NR_faccessat		307
+#define __NR_pselect6		308
+#define __NR_ppoll		309
+#define __NR_unshare		310
+#define __NR_set_robust_list	311
+#define __NR_get_robust_list	312
+#define __NR_splice		313
+#define __NR_sync_file_range	314
+#define __NR_tee		315
+#define __NR_vmsplice		316
+#define __NR_move_pages		317
+#define __NR_getcpu		318
+#define __NR_epoll_pwait	319
 
 
 #define syscall_weak(name,wsym,sym) \
diff --git a/ia64/syscalls.h b/ia64/syscalls.h
index 316eb38..515242c 100644
--- a/ia64/syscalls.h
+++ b/ia64/syscalls.h
@@ -257,6 +257,28 @@
 #define __NR_inotify_init		1277
 #define __NR_inotify_add_watch		1278
 #define __NR_inotify_rm_watch		1279
+#define __NR_migrate_pages		1280
+#define __NR_openat			1281
+#define __NR_mkdirat			1282
+#define __NR_mknodat			1283
+#define __NR_fchownat			1284
+#define __NR_futimesat			1285
+#define __NR_newfstatat			1286
+#define __NR_unlinkat			1287
+#define __NR_renameat			1288
+#define __NR_linkat			1289
+#define __NR_symlinkat			1290
+#define __NR_readlinkat			1291
+#define __NR_fchmodat			1292
+#define __NR_faccessat			1293
+/* 1294, 1295 reserved for pselect/ppoll */
+#define __NR_unshare			1296
+#define __NR_splice			1297
+#define __NR_set_robust_list		1298
+#define __NR_get_robust_list		1299
+#define __NR_sync_file_range		1300
+#define __NR_tee			1301
+#define __NR_vmsplice			1302
 
 
 #define syscall(name, sym) \
diff --git a/include/elf.h b/include/elf.h
index 8f6ea2a..a79d948 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -670,6 +670,9 @@ typedef struct
    If any adjustment is made to the ELF object after it has been
    built these entries will need to be adjusted.  */
 #define DT_ADDRRNGLO	0x6ffffe00
+#define DT_GNU_HASH	0x6ffffe05
+#define DT_TLSDESC_PLT	0x6ffffe06
+#define DT_TLSDESC_GOT	0x6ffffe07
 #define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
 #define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
 #define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
diff --git a/include/pthread.h b/include/pthread.h
index ee6df53..225df0e 100644
--- a/include/pthread.h
+++ b/include/pthread.h
@@ -252,6 +252,10 @@ int pthread_equal(pthread_t __thread1,pthread_t __thread2);
 
 int pthread_sigmask(int how,const sigset_t*newset,sigset_t*oldset);
 
+/* these two aren't actually supported right now */
+int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr, int *restrict type);
+int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
+
 __END_DECLS
 
 #endif
diff --git a/include/resolv.h b/include/resolv.h
index 69bf953..e3fb94c 100644
--- a/include/resolv.h
+++ b/include/resolv.h
@@ -125,6 +125,8 @@ int dn_expand(unsigned char *msg, unsigned char *eomorig,
 
 void res_close(void) __THROW __attribute_dontuse__;
 
+int dn_skipname(const unsigned char* cur,const unsigned char* eom) __THROW;
+
 __END_DECLS
 
 #endif
diff --git a/include/stdio.h b/include/stdio.h
index 455c933..25411e9 100644
--- a/include/stdio.h
+++ b/include/stdio.h
@@ -3,8 +3,8 @@
 
 #include <sys/cdefs.h>
 #include <sys/types.h>
-#include <sys/stat.h>
 #include <stdarg.h>
+#include <endian.h>
 
 __BEGIN_DECLS
 
@@ -89,7 +89,7 @@ int fseeko_unlocked(FILE *stream, off_t offset, int whence) __THROW;
 off_t ftello(FILE *stream) __THROW;
 off_t ftello_unlocked(FILE *stream) __THROW;
 
-#ifndef __NO_STAT64
+#if __WORDSIZE == 32
 int fseeko64(FILE *stream, loff_t offset, int whence) __THROW;
 int fseeko64_unlocked(FILE *stream, loff_t offset, int whence) __THROW;
 loff_t ftello64(FILE *stream) __THROW;
diff --git a/include/stdlib.h b/include/stdlib.h
index 0829bda..e03dd60 100644
--- a/include/stdlib.h
+++ b/include/stdlib.h
@@ -29,7 +29,7 @@ long int strtol(const char *nptr, char **endptr, int base) __THROW;
 unsigned long int strtoul(const char *nptr, char **endptr, int base) __THROW;
 
 extern int __ltostr(char *s, unsigned int size, unsigned long i, unsigned int base, int UpCase) __THROW;
-extern int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2) __THROW;
+extern int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2,int g) __THROW;
 
 #if !defined(__STRICT_ANSI__) || __STDC_VERSION__ + 0 >= 199900L
 __extension__ long long int strtoll(const char *nptr, char **endptr, int base) __THROW;
diff --git a/include/sys/prctl.h b/include/sys/prctl.h
index 5c51993..481fcf7 100644
--- a/include/sys/prctl.h
+++ b/include/sys/prctl.h
@@ -3,9 +3,68 @@
 
 #include <sys/cdefs.h>
 
+/* Values to pass as first argument to prctl() */
+
+#define PR_SET_PDEATHSIG  1  /* Second arg is a signal */
+#define PR_GET_PDEATHSIG  2  /* Second arg is a ptr to return the signal */
+
+/* Get/set current->mm->dumpable */
+#define PR_GET_DUMPABLE   3
+#define PR_SET_DUMPABLE   4
+
+/* Get/set unaligned access control bits (if meaningful) */
+#define PR_GET_UNALIGN	  5
+#define PR_SET_UNALIGN	  6
+# define PR_UNALIGN_NOPRINT	1	/* silently fix up unaligned user accesses */
+# define PR_UNALIGN_SIGBUS	2	/* generate SIGBUS on unaligned user access */
+
+/* Get/set whether or not to drop capabilities on setuid() away from uid 0 */
+#define PR_GET_KEEPCAPS   7
+#define PR_SET_KEEPCAPS   8
+
+/* Get/set floating-point emulation control bits (if meaningful) */
+#define PR_GET_FPEMU  9
+#define PR_SET_FPEMU 10
+# define PR_FPEMU_NOPRINT	1	/* silently emulate fp operations accesses */
+# define PR_FPEMU_SIGFPE	2	/* don't emulate fp operations, send SIGFPE instead */
+
+/* Get/set floating-point exception mode (if meaningful) */
+#define PR_GET_FPEXC	11
+#define PR_SET_FPEXC	12
+# define PR_FP_EXC_SW_ENABLE	0x80	/* Use FPEXC for FP exception enables */
+# define PR_FP_EXC_DIV		0x010000	/* floating point divide by zero */
+# define PR_FP_EXC_OVF		0x020000	/* floating point overflow */
+# define PR_FP_EXC_UND		0x040000	/* floating point underflow */
+# define PR_FP_EXC_RES		0x080000	/* floating point inexact result */
+# define PR_FP_EXC_INV		0x100000	/* floating point invalid operation */
+# define PR_FP_EXC_DISABLED	0	/* FP exceptions disabled */
+# define PR_FP_EXC_NONRECOV	1	/* async non-recoverable exc. mode */
+# define PR_FP_EXC_ASYNC	2	/* async recoverable exception mode */
+# define PR_FP_EXC_PRECISE	3	/* precise exception mode */
+
+/* Get/set whether we use statistical process timing or accurate timestamp
+ * based process timing */
+#define PR_GET_TIMING   13
+#define PR_SET_TIMING   14
+# define PR_TIMING_STATISTICAL  0       /* Normal, traditional,
+                                                   statistical process timing */
+# define PR_TIMING_TIMESTAMP    1       /* Accurate timestamp based
+                                                   process timing */
+
+#define PR_SET_NAME    15		/* Set process name */
+#define PR_GET_NAME    16		/* Get process name */
+
+/* Get/set process endian */
+#define PR_GET_ENDIAN	19
+#define PR_SET_ENDIAN	20
+# define PR_ENDIAN_BIG		0
+# define PR_ENDIAN_LITTLE	1	/* True little endian mode */
+# define PR_ENDIAN_PPC_LITTLE	2	/* "PowerPC" pseudo little endian */
+
+
 __BEGIN_DECLS
 
-int prctl(int option, unsigned long arg2, unsigned long arg3 , unsigned long arg4, unsigned long arg5) __THROW;
+int prctl(int option, unsigned long arg2, ...) __THROW;
 
 __END_DECLS
 
diff --git a/include/sys/stat.h b/include/sys/stat.h
index 15f72cc..12c8f8f 100644
--- a/include/sys/stat.h
+++ b/include/sys/stat.h
@@ -21,11 +21,11 @@ struct stat {
 	unsigned long	st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	  signed long	st_atime;
+	time_t		st_atime;
 	unsigned long	__unused1;
-	  signed long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	  signed long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	unsigned long	__unused4;
 	unsigned long	__unused5;
@@ -53,13 +53,13 @@ __extension__	long long	st_size __attribute__((__packed__));
 	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
 	unsigned long	__pad4;		/* future possible st_blocks high bits */
 
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	__pad5;
 
-	  signed long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__pad6;
 
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__pad7;		/* will be high 32 bits of ctime someday */
 
 __extension__	unsigned long long	st_ino __attribute__((__packed__));
@@ -104,13 +104,13 @@ struct stat64 {
 	unsigned char	__pad4[8];
 	uint32_t	st_blocks;
 
-	uint32_t	st_atime;
+	time_t		st_atime;
 	uint32_t	st_atime_nsec;
 
-	uint32_t	st_mtime;
+	time_t		st_mtime;
 	uint32_t	st_mtime_nsec;
 
-	uint32_t	st_ctime;
+	time_t		st_ctime;
 	uint32_t	st_ctime_nsec;
 
 	uint32_t	__unused4;
@@ -118,6 +118,7 @@ struct stat64 {
 };
 
 #elif defined(__sparc__)
+
 struct stat {
 	uint16_t	st_dev;
 	unsigned long	st_ino;
@@ -127,11 +128,11 @@ struct stat {
 	uint16_t	st_gid;
 	uint16_t	st_rdev;
 	long		st_size;
-	long		st_atime;
+	time_t		st_atime;
 	unsigned long	__unused1;
-	long		st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	long		st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	long		st_blksize;
 	long		st_blocks;
@@ -161,19 +162,21 @@ __extension__	long long	st_size;
 	unsigned char	__pad4[8];
 	uint32_t	st_blocks;
 
-	 int32_t	st_atime;
+	time_t		st_atime;
 	uint32_t	__unused1;
 
-	 int32_t	st_mtime;
+	time_t		st_mtime;
 	uint32_t	__unused2;
 
-	 int32_t	st_ctime;
+	time_t		st_ctime;
 	uint32_t	__unused3;
 
 	uint32_t	__unused4;
 	uint32_t	__unused5;
 };
+
 #elif defined(__alpha__)
+
 struct stat {
 	uint32_t	st_dev;
 	uint32_t	st_ino;
@@ -183,15 +186,17 @@ struct stat {
 	uint32_t	st_gid;
 	uint32_t	st_rdev;
 	signed long	st_size;
-	signed long	st_atime;
-	signed long	st_mtime;
-	signed long	st_ctime;
+	time_t		st_atime;
+	time_t		st_mtime;
+	time_t		st_ctime;
 	uint32_t	st_blksize;
 	int32_t		st_blocks;
 	uint32_t	st_flags;
 	uint32_t	st_gen;
 };
+
 #elif defined(__mips__)
+
 struct stat {
 	uint32_t	st_dev;
 	long		st_pad1[3];		/* Reserved for network id */
@@ -249,6 +254,7 @@ __extension__ long long	st_size;
 __extension__ long long	st_blocks;
 };
 #elif defined(__powerpc__) || defined(__powerpc64__)
+
 #if defined(__powerpc__) && !defined(__powerpc64__)
 struct stat {
 	dev_t		st_dev;
@@ -261,11 +267,11 @@ struct stat {
 	off_t		st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	  signed long	st_atime;
+	time_t		st_atime;
 	unsigned long	__unused1;
-	  signed long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	  signed long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	unsigned long	__unused4;
 	unsigned long	__unused5;
@@ -282,11 +288,11 @@ struct stat {
 	off_t		st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	st_atime_nsec;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	st_mtime_nsec;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	st_ctime_nsec;
 	unsigned long	__unused4;
 	unsigned long	__unused5;
@@ -309,11 +315,11 @@ __extension__	long long st_size;		/* Size of file, in bytes.  */
 	long st_blksize;		/* Optimal block size for I/O.  */
 
 __extension__	long long st_blocks;		/* Number 512-byte blocks allocated. */
-	long st_atime;			/* Time of last access.  */
+	time_t st_atime;			/* Time of last access.  */
 	unsigned long int __unused1;
-	long st_mtime;			/* Time of last modification.  */
+	time_t st_mtime;			/* Time of last modification.  */
 	unsigned long int __unused2;
-	long st_ctime;			/* Time of last status change.  */
+	time_t st_ctime;			/* Time of last status change.  */
 	unsigned long int __unused3;
 	unsigned long int __unused4;
 	unsigned long int __unused5;
@@ -332,11 +338,11 @@ struct stat {
 	unsigned long	st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	  signed long	st_atime;
+	time_t		st_atime;
 	unsigned long	__unused1;
-	  signed long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	  signed long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	unsigned long	__unused4;
 	unsigned long	__unused5;
@@ -371,13 +377,13 @@ __extension__	long long	st_size;
 	unsigned long	__pad4;		/* future possible st_blocks high bits */
 #endif
 
-	  signed long	st_atime;
+	time_t		st_atime;
 	unsigned long	__pad5;
 
-	  signed long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__pad6;
 
-	  signed long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__pad7;		/* will be high 32 bits of ctime someday */
 
 __extension__	unsigned long long	st_ino;
@@ -394,11 +400,11 @@ struct stat {
         uint32_t	__pad1;
         unsigned long	st_rdev;
         unsigned long	st_size;
-        unsigned long	st_atime;
+        time_t		st_atime;
         unsigned long	__reserved0;    /* reserved for atime.nanoseconds */
-        unsigned long	st_mtime;
+        time_t		st_mtime;
         unsigned long	__reserved1;    /* reserved for mtime.nanoseconds */
-        unsigned long	st_ctime;
+        time_t		st_ctime;
         unsigned long	__reserved2;    /* reserved for ctime.nanoseconds */
         unsigned long	st_blksize;
         long		st_blocks;
@@ -418,11 +424,11 @@ struct stat {
 	unsigned long	st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	__unused1;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	unsigned long	__unused4;
 	unsigned long	__unused5;
@@ -446,11 +452,11 @@ __extension__	long long	st_size;
 	unsigned char	__pad4[4];
 	unsigned long	__pad5; 	/* future possible st_blocks high bits */
 	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	__pad6;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__pad7;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__pad8; 	/* will be high 32 bits of ctime someday */
 __extension__	unsigned long long	st_ino;
 };
@@ -466,11 +472,11 @@ struct stat {
        uint16_t		st_reserved2;   /* old st_gid */
        unsigned long	st_rdev;
        unsigned long	st_size;
-       unsigned long	st_atime;
+       time_t		st_atime;
        unsigned long	st_spare1;
-       unsigned long	st_mtime;
+       time_t		st_mtime;
        unsigned long	st_spare2;
-       unsigned long	st_ctime;
+       time_t		st_ctime;
        unsigned long	st_spare3;
        long		st_blksize;
        long		st_blocks;
@@ -503,16 +509,17 @@ struct stat64 {
 	unsigned long	st_blksize;
 
 	unsigned long long st_blocks;
- 	unsigned long	st_atime;
+ 	time_t		st_atime;
 	unsigned long	__unused1;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__unused2;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__unused3;
 	unsigned long long st_ino;
 };
 
 #elif defined(__x86_64__)
+
 struct stat {
 	unsigned long	st_dev;
 	unsigned long	st_ino;
@@ -525,11 +532,11 @@ struct stat {
 	unsigned long	st_size;
 	unsigned long	st_blksize;
 	unsigned long	st_blocks;
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	__reserved0;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	__reserved1;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	__reserved2;
 	long		__unused[3];
 };
@@ -546,11 +553,11 @@ struct stat {
 	uint32_t	__pad;
 	unsigned long	st_rdev;
 	unsigned long	st_size;
-	unsigned long	st_atime;
+	time_t		st_atime;
 	unsigned long	reserved;
-	unsigned long	st_mtime;
+	time_t		st_mtime;
 	unsigned long	reserved2;
-	unsigned long	st_ctime;
+	time_t		st_ctime;
 	unsigned long	reserved3;
 	unsigned long	st_blksize;
 	long		st_blocks;
diff --git a/include/sys/tls.h b/include/sys/tls.h
new file mode 100644
index 0000000..d4bd9f6
--- /dev/null
+++ b/include/sys/tls.h
@@ -0,0 +1,62 @@
+#ifndef _SYS_TLS_H
+#define _SYS_TLS_H
+
+#include <inttypes.h>
+#include <stddef.h>
+#include <stdbool.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+typedef struct
+{
+  void *tcb;            /* Pointer to the TCB.  Not necessary the
+                           thread descriptor used by libpthread.  */
+  dtv_t *dtv;
+  void *self;           /* Pointer to the thread descriptor.  */
+  int multiple_threads;
+  uintptr_t sysinfo;
+  uintptr_t stack_guard;
+  uintptr_t pointer_guard;
+} tcbhead_t;
+
+#if defined(__i386__)
+
+struct user_desc {
+	unsigned int  entry_number;
+	unsigned long base_addr;
+	unsigned int  limit;
+	unsigned int  seg_32bit:1;
+	unsigned int  contents:2;
+	unsigned int  read_exec_only:1;
+	unsigned int  limit_in_pages:1;
+	unsigned int  seg_not_present:1;
+	unsigned int  useable:1;
+};
+
+int set_thread_area(struct user_desc* uinfo);
+
+#elif defined(__x86_64__)
+
+#define ARCH_SET_GS 0x1001
+#define ARCH_SET_FS 0x1002
+#define ARCH_GET_FS 0x1003
+#define ARCH_GET_GS 0x1004
+
+int arch_prctl(unsigned int what, void* where);
+
+#else
+
+#warning "need proper sys/tls.h for this platform"
+
+#endif
+
+#endif
diff --git a/include/termios.h b/include/termios.h
index 7d5a9e9..3f18d45 100644
--- a/include/termios.h
+++ b/include/termios.h
@@ -390,9 +390,9 @@ struct termios {
 
 int tcgetattr(int fd, struct termios *termios_p) __THROW;
 int tcsetattr(int fd, int optional_actions, struct termios *termios_p) __THROW;
-speed_t cfgetospeed(struct termios *termios_p) __THROW;
+speed_t cfgetospeed(const struct termios *termios_p) __THROW;
 int cfsetospeed(struct termios *termios_p, speed_t speed) __THROW;
-speed_t cfgetispeed(struct termios *termios_p) __THROW;
+speed_t cfgetispeed(const struct termios *termios_p) __THROW;
 int cfsetispeed(struct termios *termios_p, speed_t speed) __THROW;
 void cfmakeraw(struct termios *t) __THROW;
 
diff --git a/include/time.h b/include/time.h
index 15ac50b..d682295 100644
--- a/include/time.h
+++ b/include/time.h
@@ -38,6 +38,7 @@ char *asctime(const struct tm *timeptr) __THROW;
 char *asctime_r(const struct tm *timeptr, char *buf) __THROW;
 
 char *ctime(const time_t *timep) __THROW;
+char *ctime_r(const time_t *timep, char* buf) __THROW;
 
 size_t strftime(char *s, size_t max, const char *format, const struct tm *tm) __THROW __attribute__((__format__(__strftime__,3,0)));
 time_t time(time_t *t) __THROW;
diff --git a/include/unistd.h b/include/unistd.h
index d3a8088..7ddbd08 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -3,7 +3,7 @@
 
 #include <sys/cdefs.h>
 #include <sys/types.h>
-#include <sys/stat.h>
+#include <endian.h>
 #include <sys/fsuid.h>
 #include <sys/select.h>
 
@@ -34,7 +34,7 @@ int access (const char *__name, int __type) __THROW;
 #define STDERR_FILENO  2
 
 off_t lseek(int fildes, off_t offset, int whence) __THROW;
-#ifndef __NO_STAT64
+#if __WORDSIZE == 32
 loff_t lseek64(int fildes, loff_t offset, int whence) __THROW;
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
 #define lseek(fildes,offset,whence) lseek64(fildes,offset,whence)
@@ -145,7 +145,7 @@ int setreuid(uid_t ruid, uid_t euid) __THROW;
 
 int truncate(const char *path, off_t length) __THROW;
 int ftruncate(int fd, off_t length) __THROW;
-#ifndef __NO_STAT64
+#if __WORDSIZE == 32
 int truncate64(const char *path, loff_t length) __THROW;
 int ftruncate64(int fd, loff_t length) __THROW;
 #endif
@@ -243,7 +243,7 @@ int vhangup(void) __THROW;
 
 extern char **__environ;
 
-#ifndef __NO_STAT64
+#if __WORDSIZE == 32
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
 #define open open64
 #define creat creat64
diff --git a/lib/__dtostr.c b/lib/__dtostr.c
index 8914538..1d082e3 100644
--- a/lib/__dtostr.c
+++ b/lib/__dtostr.c
@@ -11,7 +11,7 @@ static int copystring(char* buf,int maxlen, const char* s) {
   return i;
 }
 
-int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2) {
+int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned int prec2,int g) {
 #if 1
   union {
     unsigned long long l;
@@ -85,7 +85,7 @@ int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned i
 	*buf=digit+'0'; ++buf;
 	if (!maxlen) {
 	  /* use scientific notation */
-	  int len=__dtostr(backup/tmp,oldbuf,maxlen,prec,prec2);
+	  int len=__dtostr(backup/tmp,oldbuf,maxlen,prec,prec2,0);
 	  int initial=1;
 	  if (len==0) return 0;
 	  maxlen-=len; buf+=len;
@@ -126,8 +126,13 @@ int __dtostr(double d,char *buf,unsigned int maxlen,unsigned int prec,unsigned i
   if (prec2 || prec>(unsigned int)(buf-oldbuf)+1) {	/* more digits wanted */
     if (!maxlen) return 0; --maxlen;
     *buf='.'; ++buf;
-    prec-=buf-oldbuf-1;
-    if (prec2) prec=prec2;
+    if (g) {
+      if (prec2) prec=prec2;
+      prec-=buf-oldbuf-1;
+    } else {
+      prec-=buf-oldbuf-1;
+      if (prec2) prec=prec2;
+    }
     if (prec>maxlen) return 0;
     while (prec>0) {
       char digit;
diff --git a/lib/__fstatfs64.c b/lib/__fstatfs64.c
index a67034d..d06e43e 100644
--- a/lib/__fstatfs64.c
+++ b/lib/__fstatfs64.c
@@ -17,7 +17,7 @@ int fstatfs64(int fd, struct statfs64 *__buf) {
   }
   return 0;
 #else
-  return __dietlibc_fstatfs64(fd,sizeof(*__buf),buf);
+  return __dietlibc_fstatfs64(fd,sizeof(*__buf),__buf);
 #endif
 }
 #endif
diff --git a/lib/__getcwd.c b/lib/__getcwd.c
index 8616704..cbc42c8 100644
--- a/lib/__getcwd.c
+++ b/lib/__getcwd.c
@@ -1,11 +1,17 @@
 #include <unistd.h>
 #include <stdlib.h>
+#include <errno.h>
 
 extern int __syscall_getcwd(char* buf, size_t size);
 
 char *getcwd(char *buf, size_t size) {
-  int tmp;
-  if ((tmp=__syscall_getcwd(buf,size))<0) return 0;
-  buf[tmp]=0;
+  if (__unlikely(!size)) {
+    errno=EINVAL;
+    buf=0;
+  } else {
+    int tmp;
+    if ((tmp=__syscall_getcwd(buf,size-1))<0) return 0;
+    buf[tmp]=0;
+  }
   return buf;
 }
diff --git a/lib/__v_printf.c b/lib/__v_printf.c
index 14dba02..35143c2 100644
--- a/lib/__v_printf.c
+++ b/lib/__v_printf.c
@@ -7,24 +7,29 @@
 #include "dietstdio.h"
 #include "dietwarning.h"
 
-static inline unsigned int skip_to(const char *format) {
-  unsigned int nr;
+#define MAX_WIDTH 10*1024
+
+static inline unsigned long skip_to(const char *format) {
+  unsigned long nr;
   for (nr=0; format[nr] && (format[nr]!='%'); ++nr);
   return nr;
 }
 
 #define A_WRITE(fn,buf,sz)	((fn)->put((void*)(buf),(sz),(fn)->data))
+#define B_WRITE(fn,buf,sz)	{ if ((unsigned long)(sz) > (((unsigned long)(int)(-1))>>1) || len+(int)(sz)<len) return -1; A_WRITE(fn,buf,sz); } while (0)
 
 static const char pad_line[2][16]= { "                ", "0000000000000000", };
-static inline int write_pad(struct arg_printf* fn, int len, int padwith) {
+static int write_pad(int* dlen,struct arg_printf* fn, int len, int padwith) {
   int nr=0;
+  if (len<0 || *dlen+len<len) return -1;
   for (;len>15;len-=16,nr+=16) {
     A_WRITE(fn,pad_line[(padwith=='0')?1:0],16);
   }
   if (len>0) {
     A_WRITE(fn,pad_line[(padwith=='0')?1:0],(unsigned int)len); nr+=len;
   }
-  return nr;
+  *dlen += nr;
+  return 0;
 }
 
 int __v_printf(struct arg_printf* fn, const char *format, va_list arg_ptr)
@@ -35,9 +40,9 @@ int __v_printf(struct arg_printf* fn, const char *format, va_list arg_ptr)
 #endif
 
   while (*format) {
-    unsigned int sz = skip_to(format);
+    unsigned long sz = skip_to(format);
     if (sz) {
-      A_WRITE(fn,format,sz); len+=sz;
+      B_WRITE(fn,format,sz); len+=sz;
       format+=sz;
     }
     if (*format=='%') {
@@ -81,9 +86,15 @@ inn_printf:
       case 'h':
 	--flag_long;
 	goto inn_printf;
+#if __WORDSIZE != 64
+      case 'j':
+#endif
       case 'q':		/* BSD ... */
       case 'L':
 	++flag_long; /* fall through */
+#if __WORDSIZE == 64
+      case 'j':
+#endif
       case 'l':
 	++flag_long;
 	goto inn_printf;
@@ -112,12 +123,14 @@ inn_printf:
       case '9':
 	if(flag_dot) return -1;
 	width=strtoul(format-1,(char**)&s,10);
+	if (width>MAX_WIDTH) return -1;
 	if (ch=='0' && !flag_left) padwith='0';
 	format=s;
 	goto inn_printf;
 
       case '*':
 	width=va_arg(arg_ptr,int);
+	if (width>MAX_WIDTH) return -1; /* width is unsiged, so this catches <0, too */
 	goto inn_printf;
 
       case '.':
@@ -131,13 +144,14 @@ inn_printf:
 	  preci=tmp<0?0:tmp;
 	  format=s;
 	}
+	if (preci>MAX_WIDTH) return -1;
 	goto inn_printf;
 
       /* print a char or % */
       case 'c':
 	ch=(char)va_arg(arg_ptr,int);
       case '%':
-	A_WRITE(fn,&ch,1); ++len;
+	B_WRITE(fn,&ch,1); ++len;
 	break;
 
 #ifdef WANT_ERROR_PRINTF
@@ -145,7 +159,7 @@ inn_printf:
       case 'm':
 	s=strerror(_errno);
 	sz=strlen(s);
-	A_WRITE(fn,s,sz); len+=sz;
+	B_WRITE(fn,s,sz); len+=sz;
 	break;
 #endif
       /* print a string */
@@ -167,7 +181,7 @@ print_out:
 	int vs;
 	
 	if (! (width||preci) ) {
-	  A_WRITE(fn,s,sz); len+=sz;
+	  B_WRITE(fn,s,sz); len+=sz;
 	  break;
 	}
 	
@@ -182,35 +196,41 @@ print_out:
 	if (!flag_left) {
 	  if (flag_dot) {
 	    vs=preci>sz?preci:sz;
-	    len+=write_pad(fn,(signed int)width-(signed int)vs,' ');
+	    if (write_pad(&len,fn,(signed int)width-(signed int)vs,' '))
+	      return -1;
 	    if (todo) {
-	      A_WRITE(fn,sign,todo);
+	      B_WRITE(fn,sign,todo);
 	      len+=todo;
 	    }
-	    len+=write_pad(fn,(signed int)preci-(signed int)sz,'0');
+	    if (write_pad(&len,fn,(signed int)preci-(signed int)sz,'0'))
+	      return -1;
 	  } else {
 	    if (todo && padwith=='0') {
-	      A_WRITE(fn,sign,todo);
+	      B_WRITE(fn,sign,todo);
 	      len+=todo; todo=0;
 	    }
-	    len+=write_pad(fn,(signed int)width-(signed int)sz, padwith);
+	    if (write_pad(&len,fn,(signed int)width-(signed int)sz, padwith))
+	      return -1;
 	    if (todo) {
-	      A_WRITE(fn,sign,todo);
+	      B_WRITE(fn,sign,todo);
 	      len+=todo;
 	    }
 	  }
-	  A_WRITE(fn,s,sz); len+=sz;
+	  B_WRITE(fn,s,sz); len+=sz;
 	} else if (flag_left) {
 	  if (todo) {
-	    A_WRITE(fn,sign,todo);
+	    B_WRITE(fn,sign,todo);
 	    len+=todo;
 	  }
-	  len+=write_pad(fn,(signed int)preci-(signed int)sz, '0');
-	  A_WRITE(fn,s,sz); len+=sz;
+	  if (write_pad(&len,fn,(signed int)preci-(signed int)sz, '0'))
+	    return -1;
+	  B_WRITE(fn,s,sz); len+=sz;
 	  vs=preci>sz?preci:sz;
-	  len+=write_pad(fn,(signed int)width-(signed int)vs, ' ');
+	  if ((signed int)width-(signed int)vs<0) return -1;
+	  if (write_pad(&len,fn,(signed int)width-(signed int)vs, ' '))
+	    return -1;
 	} else {
-	  A_WRITE(fn,s,sz); len+=sz;
+	  B_WRITE(fn,s,sz); len+=sz;
 	}
 	break;
       }
@@ -264,8 +284,11 @@ num_printf:
 #endif
 	    number=va_arg(arg_ptr,long);
 	}
-	else
+	else {
 	  number=va_arg(arg_ptr,int);
+	  if (sizeof(int) != sizeof(long) && !flag_in_sign)
+	    number&=((unsigned int)-1);
+	}
 
 	if (flag_in_sign) {
 #ifdef WANT_LONGLONG_PRINTF
@@ -317,9 +340,9 @@ num_printf:
 	  if (width==0) width=1;
 	  if (!flag_dot) preci=6;
 	  if (flag_sign || d < +0.0) flag_in_sign=1;
-	  
-	  sz=__dtostr(d,s,sizeof(buf)-1,width,preci);
-	  
+
+	  sz=__dtostr(d,s,sizeof(buf)-1,width,preci,g);
+
 	  if (flag_dot) {
 	    char *tmp;
 	    if ((tmp=strchr(s,'.'))) {
@@ -366,4 +389,3 @@ num_printf:
 }
 
 link_warning("__v_printf","warning: the printf functions add several kilobytes of bloat.")
-
diff --git a/lib/cfgetospeed.c b/lib/cfgetospeed.c
index c330352..f375ace 100644
--- a/lib/cfgetospeed.c
+++ b/lib/cfgetospeed.c
@@ -1,8 +1,8 @@
 #include <termios.h>
 #include <sys/types.h>
 
-speed_t cfgetospeed(struct termios *termios_p) {
+speed_t cfgetospeed(const struct termios *termios_p) {
   return ((termios_p->c_cflag & (CBAUD|CBAUDEX)));
 }
 
-speed_t cfgetispeed(struct termios *termios_p)	__attribute__((weak,alias("cfgetospeed")));
+speed_t cfgetispeed(const struct termios *termios_p)	__attribute__((weak,alias("cfgetospeed")));
diff --git a/lib/ftw.c b/lib/ftw.c
index ad235d9..9928ec5 100644
--- a/lib/ftw.c
+++ b/lib/ftw.c
@@ -30,7 +30,10 @@ int ftw(const char*dir,int(*f)(const char*file,const struct stat*sb,int flag),in
 #endif
   if (chdir(dir)) return-1;
   cd=alloca(PATH_MAX+1);
-  if (!getcwd(cd,PATH_MAX) || !(d=opendir("."))) return -1;
+  if (!getcwd(cd,PATH_MAX) || !(d=opendir("."))) {
+    close(previous);
+    return -1;
+  }
   cd[PATH_MAX]='\0';
   cdl=strlen(cd);
 #if !defined(__dietlibc__) && !defined(__MINGW32__)
diff --git a/lib/ftw64.c b/lib/ftw64.c
index 632c284..fb59c53 100644
--- a/lib/ftw64.c
+++ b/lib/ftw64.c
@@ -6,7 +6,15 @@
 #include <dirent.h>
 #include <string.h>
 #include <stdlib.h>
+#include <fcntl.h>
+
+#ifdef __dietlibc__
 #include "dietdirent.h"
+#endif
+
+#ifndef O_DIRECTORY
+#define O_DIRECTORY 0
+#endif
 
 #ifdef __NO_STAT64
 int ftw64(const char*dir,int(*f)(const char*file,const struct stat* sb,int flag),int dpth) __THROW;
@@ -21,12 +29,23 @@ int ftw64(const char*dir,int(*f)(const char*file,const struct stat* sb,int flag)
   int r;
   unsigned int oldlen=0;
   char* filename = NULL;
-  if(chdir(dir))return-1;
+  int previous=open(".",O_RDONLY|O_DIRECTORY);
+#if !defined(__dietlibc__) && !defined(__MINGW32__)
+  int thisdir;
+#endif
+  if (chdir(dir)) return -1;
   cd=alloca(PATH_MAX+1);
-  if(!getcwd(cd,PATH_MAX))return-1;
+  if (!getcwd(cd,PATH_MAX) || !(d=opendir("."))) {
+    close(previous);
+    return -1;
+  }
   cd[PATH_MAX]='\0';
   cdl=strlen(cd);
-  if(!(d=opendir(".")))return-1;
+#if !defined(__dietlibc__) && !defined(__MINGW32__)
+  if ((thisdir=open(".",O_RDONLY|O_DIRECTORY))==-1) {
+    closedir(d); return -1;
+  }
+#endif
   while((de=readdir(d))){
     int flg;
     size_t nl;
@@ -41,12 +60,34 @@ int ftw64(const char*dir,int(*f)(const char*file,const struct stat* sb,int flag)
       if(S_ISLNK(sb.st_mode))flg=FTW_SL;else if(S_ISDIR(sb.st_mode))flg=FTW_D;else flg=FTW_F;
     }else flg=FTW_NS;
     r=f(filename,&sb,flg);
-    if(r){closedir(d);return r;}
+    if(r){
+err:
+#if !defined(__dietlibc__) && !defined(__MINGW32__)
+      close(thisdir);
+#endif
+      closedir(d);
+      fchdir(previous);
+      close(previous);
+      return r;
+    }
     if(flg==FTW_D&&dpth){
       r=ftw(filename,f,dpth-1);
+#ifndef __dietlibc__
+#ifdef __MINGW32__
+      chdir("..");
+#else
+      fchdir(thisdir);
+#endif
+#else
       fchdir(d->fd);
-      if (r){closedir(d);return r;}
+#endif
+      if (r) goto err;
     }
   }
+  fchdir(previous);
+  close(previous);
+#if !defined(__dietlibc__) && !defined(__MINGW32__)
+  close(thisdir);
+#endif
   return closedir(d);
 }
diff --git a/lib/if_nameindex.c b/lib/if_nameindex.c
index fc0e1c0..cad9001 100644
--- a/lib/if_nameindex.c
+++ b/lib/if_nameindex.c
@@ -8,17 +8,13 @@
 struct if_nameindex* if_nameindex(void) {
   struct ifconf ic;
   int fd,len,i;
-  struct if_nameindex* x,* y;
+  struct if_nameindex* x=0,* y;
   char *dest;
   fd=socket(AF_INET6,SOCK_DGRAM,0);
   if (fd<0) fd=socket(AF_INET,SOCK_DGRAM,0);
   ic.ifc_buf=0;
   ic.ifc_len=0;
-  if (ioctl(fd,SIOCGIFCONF,&ic)<0) {
-b0rken:
-    close(fd);
-    return 0;
-  }
+  if (ioctl(fd,SIOCGIFCONF,&ic)<0) goto b0rken;
   ic.ifc_buf=alloca((size_t)ic.ifc_len);
   if (ioctl(fd,SIOCGIFCONF,&ic)<0) goto b0rken;
   len=(ic.ifc_len/sizeof(struct ifreq));
@@ -36,5 +32,7 @@ b0rken:
     ++y;
   }
   y->if_name=0; y->if_index=0;
+b0rken:
+  close(fd);
   return x;
 }
diff --git a/lib/if_nametoindex.c b/lib/if_nametoindex.c
index c9dd1b0..215974c 100644
--- a/lib/if_nametoindex.c
+++ b/lib/if_nametoindex.c
@@ -10,6 +10,7 @@
 unsigned int if_nametoindex(const char* blub) {
   struct ifreq ifr;
   int fd;
+  int ret=0;
   char *tmp;
   int len=sizeof(ifr.ifr_name);
   fd=socket(AF_INET6,SOCK_DGRAM,0);
@@ -17,10 +18,8 @@ unsigned int if_nametoindex(const char* blub) {
   for (tmp=ifr.ifr_name; len>0; --len) {
     if ((*tmp++=*blub++)==0) break;
   }
-  if (ioctl(fd,SIOCGIFINDEX,&ifr)==0) {
-    close(fd);
-    return ifr.ifr_ifindex;
-  }
+  if (ioctl(fd,SIOCGIFINDEX,&ifr)==0)
+    ret=ifr.ifr_ifindex;
   close(fd);
-  return 0;
+  return ret;
 }
diff --git a/lib/putenv.c b/lib/putenv.c
index a48393e..cc28ebd 100644
--- a/lib/putenv.c
+++ b/lib/putenv.c
@@ -15,9 +15,11 @@ int putenv(const char *string) {
     len=strlen(string);
     remove=1;
   } else
-    len=tmp-string+1;
+    len=tmp-string;
   for (envc=0, ep=(const char**)environ; (ep && *ep); ++ep) {
-    if (*string == **ep && !memcmp(string,*ep,len)) {
+    if (*string == **ep &&
+	!memcmp(string,*ep,len) &&
+	(*ep)[len]=='=') {
       if (remove) {
 	for (; ep[1]; ++ep) ep[0]=ep[1];
 	ep[0]=0;
diff --git a/lib/qsort.c b/lib/qsort.c
index 82e15ff..84493c1 100644
--- a/lib/qsort.c
+++ b/lib/qsort.c
@@ -1,164 +1,50 @@
 #include <sys/cdefs.h>
 #include <stdlib.h>
-#include <assert.h>
 
-/* comments:
-     1. insertion sort sofort, nicht nachtrglich
-     2. threshold = 16
- */
-
-static inline void iswap(void *a,void *b,size_t size) {
-  register char *x=a;
-  register char *y=b;
-  register char *z=x+size;
-  while (x<z) {
-    register char tmp=*x;
+static void exch(char* base,size_t size,size_t a,size_t b) {
+  char* x=base+a*size;
+  char* y=base+b*size;
+  while (size) {
+    char z=*x;
     *x=*y;
-    *y=tmp;
-    ++x; ++y;
-  }
-}
-
-static inline void swap(void *base,size_t size,size_t a,size_t b) {
-  iswap((char*)base+a*size,(char*)base+b*size,size);
-}
-
-#if 0
-extern int array[];
-
-void dumparray() {
-  printf("array now {%d,%d,%d,%d,%d}\n",array[0],array[1],array[2],array[3],array[4]);
-}
-#endif
-
-void isort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
-void isort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)) {
-  size_t i;
-  while (__likely(nmemb>1)) {
-    char *min=base;
-    char *tmp=min+size;
-    for (i=1; i<nmemb; ++i) {
-      if (__unlikely(compar(tmp,min)<0))
-	min=tmp;
-      tmp+=size;
-    }
-    iswap(min,base,size);
-    base=(void*)((char*)base+size);
-    nmemb-=1;
+    *y=z;
+    --size; ++x; ++y;
   }
 }
 
-#if OLD_AND_SLOW_FOR_MAKE
-void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)) {
-#ifdef DEBUG
-  char *dbase=base;
-  char *dmax=base+(nmemb-1)*size;
-  char dmemb=nmemb;
-#endif
-//  static int level=0;
-  char* v;	/* pivot */
-  char* mid, *max, *min;
-  size_t lmemb;
-
-#if 0
-  int left,right;
-  left=(int*)base-array;
-  right=left+nmemb-1;
-  ++level;
-  { int i; for (i=0; i<level; ++i) printf("  "); }
-  printf("qsort: level %d; base=%p, %dx%d; array[%d..%d]\n",level,base,nmemb,size,left,right);
-  assert(left>=0 && right<=1000);
-#endif
-  if (nmemb<=8) {
-//    --level;
-    return isort(base,nmemb,size,compar);
-  }
-  {
-    mid=(char*)base+(nmemb/2)*size;
-    max=(char*)base+(nmemb-1)*size;
-
-    if (compar(base,max)<0)	/* a[left] < a[right] */
-      if (compar(base,mid)<0)	/* a[left] < a[med] */
-	if (compar(max,mid)<0)	/* a[left] < a[right] < a[med] */
-	  v=max;
-	else			/* a[left] < a[med] < a[right] */
-	  v=mid;
-      else			/* a[med] < a[left] < a[right] */
-	v=base;
-    else			/* a[right] < a[left] */
-      if (compar(base,mid)<0)	/* a[right] < a[left] < a[med] */
-	v=base;
-      else			/* a[right] < a[left] && a[med] < a[left] */
-	if (compar(max,mid)<0)	/* a[right] < a[med] < a[left] */
-	  v=mid;
-	else
-	  v=max;
-//    printf("%d %d %d -> median %d\n",*(int*)base,*(int*)mid,*(int*)max,*(int*)v);
-  }
-  if (v != max)
-    iswap(v,max,size);
-  v=max;
-  min=base; lmemb=0;
+/* Quicksort with 3-way partitioning, ala Sedgewick */
+/* Blame him for the scary variable names */
+/* http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf */
+static void quicksort(char* base,size_t size,ssize_t l,ssize_t r,
+		      int (*compar)(const void*,const void*)) {
+  ssize_t i=l-1, j=r, p=l-1, q=r, k;
+  char* v=base+r*size;
+  if (r<=l) return;
   for (;;) {
-    while (__likely(compar(min,v)<0)) { min+=size; ++lmemb; }
-    while (__likely(compar(max-=size,v)>0)) ;
-    if (min>=max) break;
-    iswap(min,max,size);
+    while (compar(base+(++i)*size,v)<0) ;
+    while (compar(v,base+(--j)*size)<0) if (j == l) break;
+    if (i >= j) break;
+    exch(base,size,i,j);
+    if (compar(base+i*size,v)==0) exch(base,size,++p,i);
+    if (compar(v,base+j*size)==0) exch(base,size,j,--q);
+  }
+  exch(base,size,i,r); j = i-1; ++i;
+  for (k=l; k<p; k++, j--) exch(base,size,k,j);
+  for (k=r-1; k>q; k--, i++) exch(base,size,i,k);
+  quicksort(base,size,l,j,compar);
+  quicksort(base,size,i,r,compar);
+}
+
+void qsort(void* base,size_t nmemb,size_t size,int (*compar)(const void*,const void*)) {
+  /* check for integer overflows */
+  if (nmemb >= (((size_t)-1)>>1) ||
+      size >= (((size_t)-1)>>1)) return;
+#if 0
+  if (sizeof(size_t) < sizeof(unsigned long long)) {
+    if ((unsigned long long)size * nmemb > (size_t)-1) return;
+  } else {
+    if (size*nmemb/nmemb != size) return;
   }
-  iswap(min,v,size);
-#ifdef DEBUG
-//    { int i; for (i=0; i<level; ++i) printf("  "); }
-//    printf("-=< base=%p, min=%p, nmemb=%d, lmemb=%d (%d)\n",base,min,nmemb,lmemb,(min-(char*)base)/size);
-    assert(lmemb==((min-(char*)base)/size));
-#endif
-  if (min>(char*)base+size) {
-#ifdef DEBUG
-    assert(base==dbase);
 #endif
-//    { int i; for (i=0; i<level; ++i) printf("  "); }
-//    printf("+-left %d [%d..%d] of [%d..%d]\n",level+1,left,left+lmemb,left,right);
-    qsort(base,lmemb,size,compar);
-  }
-  if (nmemb>lmemb+1) {
-//    { int i; for (i=0; i<level; ++i) printf("  "); }
-//    printf("+-right %d [%d..%d] of [%d..%d]\n",level+1,left+lmemb,right,left,right);
-    qsort(min+size,nmemb-lmemb-1,size,compar);
-  }
-//  --level;
-}
-#else
-
-static inline char* idx(void* base,size_t size,size_t x) {
-  return ((char*)base)+x*size;
+  quicksort(base,size,0,nmemb-1,compar);
 }
-
-static void Qsort(void *base, size_t nmemb, size_t size,long l,long r,
-		  int (*compar)(const void *, const void *)) {
-  long i,j,k,p,q;
-  char* v;
-  if (r-l<10) {
-    isort(idx(base,size,l),r-l+1,size,compar);
-    return;
-  }
-  v=idx(base,size,r);
-  i=l-1; j=r; p=l-1; q=r;
-  for (;;) {
-    while (compar(idx(base,size,++i),v)<0) ;
-    while (compar(idx(base,size,--j),v)>0) if (j==l) break;
-    if (i>=j) break;
-    swap(base,size,i,j);
-    if (compar(idx(base,size,i),v)==0) { ++p; swap(base,size,p,i); }
-    if (compar(idx(base,size,j),v)==0) { --q; swap(base,size,q,j); }
-  }
-  swap(base,size,i,r); j=i-1; ++i;
-  for (k=l; k<p; ++k,--j) swap(base,size,k,j);
-  for (k=r-1; k>q; --k,++i) swap(base,size,k,i);
-  if (j>l) Qsort(base,nmemb,size,l,j,compar);
-  if (r>i) Qsort(base,nmemb,size,i,r,compar);
-}
-
-void qsort(void *base, size_t nmemb, size_t size,
-	   int (*compar)(const void *, const void *)) {
-  Qsort(base,nmemb,size,0,nmemb-1,compar);
-}
-#endif
diff --git a/lib/stackgap.c b/lib/stackgap.c
index 286b3a8..4efd32b 100644
--- a/lib/stackgap.c
+++ b/lib/stackgap.c
@@ -2,14 +2,50 @@
 #include <fcntl.h>
 #include <alloca.h>
 #include <sys/time.h>
+#include <sys/tls.h>
 #include "dietfeatures.h"
 
 extern int main(int argc,char* argv[],char* envp[]);
 
-#ifdef WANT_SSP
+#if defined(WANT_SSP)
 extern unsigned long __guard;
 #endif
 
+#if defined(WANT_SSP) || defined(WANT_THREAD_SAFE)
+static tcbhead_t mainthread;
+
+static void setup_tls(void) {
+#if defined(__x86_64__)
+
+  mainthread.tcb=&mainthread;
+  mainthread.self=&mainthread;
+#if defined(WANT_SSP)
+  mainthread.stack_guard=__guard;
+#endif
+  arch_prctl(ARCH_SET_FS, &mainthread);
+
+#elif defined(__i386__)
+
+  static unsigned int sd[4];
+  mainthread.tcb=&mainthread;
+  mainthread.self=&mainthread;
+#if defined(WANT_SSP)
+  mainthread.stack_guard=__guard;
+#endif
+  sd[0]=-1;
+  sd[1]=(unsigned long int)&mainthread;
+  sd[2]=0xfffff; /* 4 GB limit */
+  sd[3]=0x51; /* bitfield, see struct user_desc in asm-i386/ldt.h */
+  if (set_thread_area(&sd)==0) {
+    asm volatile ("movw %w0, %%gs" :: "q" (sd[0]*8+3));
+  }
+
+#else
+#warning "no idea how to enable TLS on this platform, edit lib/stackgap.c"
+#endif
+}
+#endif
+
 int stackgap(int argc,char* argv[],char* envp[]);
 int stackgap(int argc,char* argv[],char* envp[]) {
 #ifdef WANT_SSP_XOR
@@ -34,6 +70,10 @@ int stackgap(int argc,char* argv[],char* envp[]) {
   gettimeofday (&tv, NULL);
   __guard ^= tv.tv_usec ^ tv.tv_sec ^ getpid();
 #endif
+
+#if defined(WANT_SSP) || defined(WANT_THREAD_SAFE)
+  setup_tls();
+#endif
   return main(argc,argv,envp);
 }
 
diff --git a/libcompat/getdelim.c b/libcompat/getdelim.c
index 2310410..060fd15 100644
--- a/libcompat/getdelim.c
+++ b/libcompat/getdelim.c
@@ -13,17 +13,18 @@ ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream) {
   }
   if (!*lineptr) *n=0;
   for (i=0; ; ) {
-    int x=fgetc(stream);
+    int x;
     if (i>=*n) {
       int tmp=*n+100;
       char* new=realloc(*lineptr,tmp);
       if (!new) return -1;
       *lineptr=new; *n=tmp;
     }
+    x=fgetc(stream);
     if (x==EOF) { if (!i) return -1; (*lineptr)[i]=0; return i; }
     (*lineptr)[i]=x;
     ++i;
-    if (x==delim) break;
+    if (x==delim || i>=*n) break;
   }
   (*lineptr)[i]=0;
   return i;
diff --git a/libcompat/getline.c b/libcompat/getline.c
index 809a0e6..6fdea03 100644
--- a/libcompat/getline.c
+++ b/libcompat/getline.c
@@ -1,5 +1,6 @@
 #define _GNU_SOURCE
 #include <stdio.h>
+#include <sys/types.h>
 #include "dietwarning.h"
 
 ssize_t getline(char **lineptr, size_t *n, FILE *stream) {
diff --git a/libcruft/dn_skipname.c b/libcruft/dn_skipname.c
new file mode 100644
index 0000000..7b946d9
--- /dev/null
+++ b/libcruft/dn_skipname.c
@@ -0,0 +1,19 @@
+#include <resolv.h>
+
+int dn_skipname(const unsigned char* cur,const unsigned char* eom) {
+  const unsigned char* orig=cur;
+  while (cur<eom) {
+    if ((*cur&0xc)==0xc) { /* compression */
+      if (cur+1<eom)
+	return cur-orig+2;
+      else
+	return -1;
+    } else
+      if (*cur==0) return cur-orig+1;
+      if (cur+*cur+1<eom)
+	cur+=*cur+1;
+      else
+	return -1;
+  }
+  return -1;
+}
diff --git a/libcruft/dnscruft.c b/libcruft/dnscruft.c
index 4fe971c..b6cdd84 100644
--- a/libcruft/dnscruft.c
+++ b/libcruft/dnscruft.c
@@ -45,9 +45,8 @@ void __dns_make_fd6(void) {
   tmp=socket(PF_INET6,SOCK_DGRAM,IPPROTO_UDP);
   if (tmp<0) return;
   fcntl(tmp,F_SETFD,FD_CLOEXEC);
+  memset(&si,0,sizeof(si));
   si.sin6_family=AF_INET6;
-  si.sin6_port=0;
-  memset(&si.sin6_addr,0,16);
   if (bind(tmp,(struct sockaddr*)&si,sizeof(si))) return;
   __dns_fd6=tmp;
 }
diff --git a/libcruft/dnscruft2.c b/libcruft/dnscruft2.c
index 524bb36..d9756ef 100644
--- a/libcruft/dnscruft2.c
+++ b/libcruft/dnscruft2.c
@@ -5,7 +5,6 @@
 #include <netdb.h>
 #include <stdlib.h>
 #include <arpa/inet.h>
-#include <sys/poll.h>
 #include <unistd.h>
 #include <errno.h>
 #include <arpa/nameser.h>
diff --git a/libcruft/getopt_long.c b/libcruft/getopt_long.c
index c54bf47..1d37db8 100644
--- a/libcruft/getopt_long.c
+++ b/libcruft/getopt_long.c
@@ -36,33 +36,46 @@ again:
     char* arg=argv[optind]+2;
     char* max=strchr(arg,'=');
     const struct option* o;
+    const struct option* match=0;
     if (!max) max=arg+strlen(arg);
     for (o=longopts; o->name; ++o) {
-      if (!strncmp(o->name,arg,(size_t)(max-arg))) {	/* match */
-	if (longindex) *longindex=o-longopts;
-	if (o->has_arg>0) {
-	  if (*max=='=')
-	    optarg=max+1;
-	  else {
-	    optarg=argv[optind+1];
-	    if (!optarg && o->has_arg==1) {	/* no argument there */
-	      if (*optstring==':') return ':';
-	      write(2,"argument required: `",20);
-	      write(2,arg,(size_t)(max-arg));
-	      write(2,"'.\n",3);
-	      ++optind;
-	      return '?';
-	    }
+      size_t tlen=max-arg;
+      if (!strncmp(o->name,arg,tlen)) {	/* match */
+	if (strlen(o->name)==tlen) {
+	  match=o;	/* perfect match, not just prefix */
+	  break;
+	}
+	if (!match)
+	  match=o;
+	else
+	  /* Another imperfect match. */
+	  match=(struct option*)-1;
+      }
+    }
+    if (match!=(struct option*)-1 && (o=match)) {
+      if (longindex) *longindex=o-longopts;
+      if (o->has_arg>0) {
+	if (*max=='=')
+	  optarg=max+1;
+	else {
+	  optarg=argv[optind+1];
+	  if (!optarg && o->has_arg==1) {	/* no argument there */
+	    if (*optstring==':') return ':';
+	    write(2,"argument required: `",20);
+	    write(2,arg,(size_t)(max-arg));
+	    write(2,"'.\n",3);
 	    ++optind;
+	    return '?';
 	  }
+	  ++optind;
 	}
-	++optind;
-	if (o->flag)
-	  *(o->flag)=o->val;
-	else
-	  return o->val;
-	return 0;
       }
+      ++optind;
+      if (o->flag)
+	*(o->flag)=o->val;
+      else
+	return o->val;
+      return 0;
     }
     if (*optstring==':') return ':';
     write(2,"invalid option `",16);
diff --git a/libcruft/getopt_long_only.c b/libcruft/getopt_long_only.c
index 2a1c307..021ea9a 100644
--- a/libcruft/getopt_long_only.c
+++ b/libcruft/getopt_long_only.c
@@ -34,33 +34,46 @@ again:
   {
     char* max=strchr(arg,'=');
     const struct option* o;
+    const struct option* match=0;
     if (!max) max=arg+strlen(arg);
     for (o=longopts; o->name; ++o) {
-      if (!strncmp(o->name,arg,(size_t)(max-arg))) {	/* match */
-	if (longindex) *longindex=o-longopts;
-	if (o->has_arg>0) {
-	  if (*max=='=')
-	    optarg=max+1;
-	  else {
-	    optarg=argv[optind+1];
-	    if (!optarg && o->has_arg==1) {	/* no argument there */
-	      if (*optstring==':') return ':';
-	      write(2,"argument required: `",20);
-	      write(2,arg,(size_t)(max-arg));
-	      write(2,"'.\n",3);
-	      ++optind;
-	      return '?';
-	    }
+      size_t tlen=max-arg;
+      if (!strncmp(o->name,arg,tlen)) {	/* match */
+	if (strlen(o->name)==tlen) {
+	  match=o;	/* perfect match, not just prefix */
+	  break;
+	}
+	if (!match)
+	  match=o;
+	else
+	  /* Another imperfect match. */
+	  match=(struct option*)-1;
+      }
+    }
+    if (match!=(struct option*)-1 && (o=match)) {
+      if (longindex) *longindex=o-longopts;
+      if (o->has_arg>0) {
+	if (*max=='=')
+	  optarg=max+1;
+	else {
+	  optarg=argv[optind+1];
+	  if (!optarg && o->has_arg==1) {	/* no argument there */
+	    if (*optstring==':') return ':';
+	    write(2,"argument required: `",20);
+	    write(2,arg,(size_t)(max-arg));
+	    write(2,"'.\n",3);
 	    ++optind;
+	    return '?';
 	  }
+	  ++optind;
 	}
-	++optind;
-	if (o->flag)
-	  *(o->flag)=o->val;
-	else
-	  return o->val;
-	return 0;
       }
+      ++optind;
+      if (o->flag)
+	*(o->flag)=o->val;
+      else
+	return o->val;
+      return 0;
     }
     if (argv[optind][1]!='-') goto shortopt;
     if (*optstring==':') return ':';
diff --git a/libcruft/res_mkquery.c b/libcruft/res_mkquery.c
index 049f341..1a55ba0 100644
--- a/libcruft/res_mkquery.c
+++ b/libcruft/res_mkquery.c
@@ -42,10 +42,14 @@ extern void __dns_readstartfiles(void);
 int res_mkquery(int op, const char *dname, int class, int type, char* data,
 		int datalen, const unsigned char* newrr, char* buf, int buflen) {
   unsigned char packet[512];
-  unsigned long len=0;
-  memmove(packet,dnspacket,12);
+  unsigned long len;
+
+  memcpy(packet,dnspacket,12);
+  len=rand();
+  packet[0]=len;
+  packet[1]=len>>8;
+  len=0;
   if ((_res.options&RES_RECURSE)==0) packet[2]=0;
-  *(unsigned short*)packet=rand();
   {
     unsigned char* x;
     const char* y,* tmp;
diff --git a/libcruft/res_query.c b/libcruft/res_query.c
index 1afd3aa..a6bda09 100644
--- a/libcruft/res_query.c
+++ b/libcruft/res_query.c
@@ -70,11 +70,10 @@ int res_query(const char *dname, int class, int type, unsigned char *answer, int
 	  if (pnpfd>=0) {
 	    int one=1;
 	    fcntl(pnpfd,F_SETFD,FD_CLOEXEC);
-	    if (v4pnp) {
-	      setsockopt(pnpfd,SOL_IP,IP_RECVTTL,&one,sizeof one);
-	      setsockopt(pnpfd,SOL_IP,IP_PKTINFO,&one,sizeof one);
-	    } else
+	    if (!v4pnp)
 	      setsockopt(pnpfd,IPPROTO_IPV6,IPV6_HOPLIMIT,&one,sizeof one);
+	    setsockopt(pnpfd,SOL_IP,IP_RECVTTL,&one,sizeof one);
+	    setsockopt(pnpfd,SOL_IP,IP_PKTINFO,&one,sizeof one);
 	  }
 	}
 #ifdef WANT_IPV6_DNS
@@ -84,22 +83,19 @@ int res_query(const char *dname, int class, int type, unsigned char *answer, int
 	  if (pnpfd!=-1) bind(pnpfd,(struct sockaddr*)&pnpsa6,sizeof(pnpsa6));
 	  pnpsa6.sin6_port=htons(5353);
 	  memcpy(&pnpsa6.sin6_addr,"\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfb",16);
-	} else {
-#endif
-	  memset(&pnpsa4,0,sizeof(pnpsa4));
-	  pnpsa4.sin_family=AF_INET;
-	  if (pnpfd!=-1) bind(pnpfd,(struct sockaddr*)&pnpsa4,sizeof(pnpsa4));
-	  pnpsa4.sin_port=htons(5353);
-	  memcpy(&pnpsa4.sin_addr,"\xe0\x00\x00\xfb",4);  /* 224.0.0.251 */
-#ifdef WANT_IPV6_DNS
 	}
 #endif
+	memset(&pnpsa4,0,sizeof(pnpsa4));
+	pnpsa4.sin_family=AF_INET;
+	if (pnpfd!=-1) bind(pnpfd,(struct sockaddr*)&pnpsa4,sizeof(pnpsa4));
+	pnpsa4.sin_port=htons(5353);
+	memcpy(&pnpsa4.sin_addr,"\xe0\x00\x00\xfb",4);  /* 224.0.0.251 */
 
 	duh[1].events=POLLIN;
 	duh[1].fd=pnpfd;
       } else {
 	duh[1].fd=-1;
-	duh[1].revents=0;
+	duh[1].events=0;
       }
 
 #endif
@@ -109,9 +105,8 @@ int res_query(const char *dname, int class, int type, unsigned char *answer, int
       last.tv_sec=0;
 #ifdef WANT_PLUGPLAY_DNS
       if (duh[1].fd!=-1) {
-	if (v4pnp)
-	  sendto(pnpfd,packet,size,0,(struct sockaddr*)(&pnpsa4),sizeof(pnpsa4));
-	else
+	sendto(pnpfd,packet,size,0,(struct sockaddr*)(&pnpsa4),sizeof(pnpsa4));
+	if (!v4pnp)
 	  sendto(pnpfd,packet,size,0,(struct sockaddr*)(&pnpsa6),sizeof(pnpsa6));
       }
       /* if it doesn't work, we don't care */
@@ -191,6 +186,8 @@ int res_query(const char *dname, int class, int type, unsigned char *answer, int
 	      /* as per standard, discard packets with TTL!=255 */
 	      continue;
 	    }
+	    /* work around stupid avahi bug */
+	    inpkg[2]=(inpkg[2]&~0x1) | (packet[2]&0x1);
 	  }
 #else
 	  int len=read(duh[0].fd,inpkg,sizeof(inpkg));
diff --git a/libcruft/tempnam.c b/libcruft/tempnam.c
index 01c20b4..07c0e90 100644
--- a/libcruft/tempnam.c
+++ b/libcruft/tempnam.c
@@ -19,6 +19,7 @@ char* tempnam(char* dir,char* template) {
   else
     strncpy(buf,"/tmp/",len);
   len=(sizeof(buf)-1)-strlen(buf);
+  if (len<1) return 0;
   if (template)
     strncat(buf,template, --len);
   else
diff --git a/libdl/_dl_int.h b/libdl/_dl_int.h
index 769e3bd..be61b7d 100644
--- a/libdl/_dl_int.h
+++ b/libdl/_dl_int.h
@@ -83,6 +83,7 @@ struct _dl_handle {
   char *	dyn_str_tab;	/* dyn_name table */
   Elf_Sym *	dyn_sym_tab;	/* dynamic symbol table */
   _dl_rel_t*	plt_rel;	/* PLT relocation table */
+  unsigned int*gnu_hash_tab;	/* GNU hash table */
 
   /* INIT / FINI */
   void (*init)(void);
@@ -108,6 +109,10 @@ struct r_debug {
 #define HASH_CHAIN_LEN(p)	(*((p)+1))
 #define HASH_CHAIN(p)		((p)+2+HASH_BUCKET_LEN(p))
 
+#define GNU_HASH_BUCKET_LEN(p)	(*((p)))
+#define GNU_HASH_BUCKET(p,n)	((p)[(n)+1])
+#define GNU_HASH_CHAIN(p,n)	((p)+(1+GNU_HASH_BUCKET_LEN(p)+(n)))
+
 /* _dl_alloc.c */
 #if 0
 extern struct _dl_handle* _dl_root_handle;
diff --git a/libdl/_dl_main.c b/libdl/_dl_main.c
index 36305ee..ba24920 100644
--- a/libdl/_dl_main.c
+++ b/libdl/_dl_main.c
@@ -931,6 +931,12 @@ static struct _dl_handle* _dl_dyn_scan(struct _dl_handle*dh,Elf_Dyn*_dynamic) {
       pf(__FUNCTION__); pf(": have dyn_str_tab @ "); ph((long)dh->dyn_str_tab); pf("\n");
 #endif
       break;
+    case DT_GNU_HASH:
+      dh->gnu_hash_tab = (unsigned int*)(dh->mem_base+_dynamic[i].d_un.d_ptr);
+#ifdef DEBUG
+      pf(__FUNCTION__); pf(": have GNU-hash @ "); ph((long)dh->gnu_hash_tab); pf("\n");
+#endif
+      break;
 
       /* DYNAMIC INIT/FINI (constructors/destructors) */
     case DT_FINI:
diff --git a/libdl/_dl_relocate.c b/libdl/_dl_relocate.c
index 886ec5c..f2951ea 100644
--- a/libdl/_dl_relocate.c
+++ b/libdl/_dl_relocate.c
@@ -46,7 +46,14 @@ static int _dl_apply_relocate(struct _dl_handle*dh,_dl_rel_t*rel) {
 
 #ifdef __i386__
   if (typ==R_386_32) {			/* 1 */
-    *loc=(unsigned long)(dh->mem_base+dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+    unsigned long value=(unsigned long)(dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+#ifdef DEBUG
+    pf(__func__); pf(" value "); ph(value); pf("\n");
+#endif
+    if (value)
+      *loc=(unsigned long)(dh->mem_base+value);
+    else
+      *loc=(unsigned long)_dl_sym(dh,ELF_R_SYM(rel->r_info));
   } else if (typ==R_386_COPY)  {	/* 5 */
     unsigned long len=dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_size;
     void*from=_dl_sym_next(dh,ELF_R_SYM(rel->r_info));
@@ -66,7 +73,11 @@ static int _dl_apply_relocate(struct _dl_handle*dh,_dl_rel_t*rel) {
 #endif
 #ifdef __arm__
   if (typ==R_ARM_ABS32) {		/*  2 */
-    *loc=(unsigned long)(dh->mem_base+dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+    unsigned long value=(unsigned long)(dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+    if (value)
+      *loc=(unsigned long)(dh->mem_base+value);
+    else
+      *loc=(unsigned long)_dl_sym(dh,ELF_R_SYM(rel->r_info));
   } else if (typ==R_ARM_COPY)  {	/* 20 */
     unsigned long len=dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_size;
     void*from=_dl_sym_next(dh,ELF_R_SYM(rel->r_info));
@@ -86,7 +97,11 @@ static int _dl_apply_relocate(struct _dl_handle*dh,_dl_rel_t*rel) {
 #endif
 #ifdef __x86_64__
   if (typ==R_X86_64_64) {			/* 1 */
-    *loc=(unsigned long)(dh->mem_base+dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+    unsigned long value=(unsigned long)(dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_value);
+    if (value)
+      *loc=(unsigned long)(dh->mem_base+value);
+    else
+      *loc=(unsigned long)_dl_sym(dh,ELF_R_SYM(rel->r_info));
   } else if (typ==R_X86_64_COPY)  {	/* 5 */
     unsigned long len=dh->dyn_sym_tab[ELF_R_SYM(rel->r_info)].st_size;
     void*from=_dl_sym_next(dh,ELF_R_SYM(rel->r_info));
diff --git a/libdl/dlsym.c b/libdl/dlsym.c
index a15579a..22c3bc8 100644
--- a/libdl/dlsym.c
+++ b/libdl/dlsym.c
@@ -1,52 +1,93 @@
 #include "_dl_int.h"
 
 #include "elf_hash.h"
+#include "gnu_hash.h"
 
-#ifdef __DIET_LD_SO__
-static
-#endif
-void *_dlsym(void* handle,const unsigned char* symbol) {
+static void*_dlsym_elfhash(struct _dl_handle*dh,const unsigned char*symbol) {
   unsigned long*sym=0;
-  if (handle) {
-    struct _dl_handle*dh=(struct _dl_handle*)handle;
-    unsigned int hash =elf_hash(symbol);
-    unsigned int bhash=hash%HASH_BUCKET_LEN(dh->hash_tab);
-    unsigned int*chain=HASH_CHAIN(dh->hash_tab);
-    unsigned int ind;
-    unsigned char*name=(unsigned char*)dh->dyn_str_tab;
+  unsigned int hash =elf_hash(symbol);
+  unsigned int bhash=hash%HASH_BUCKET_LEN(dh->hash_tab);
+  unsigned int*chain=HASH_CHAIN(dh->hash_tab);
+  unsigned char*name=(unsigned char*)dh->dyn_str_tab;
+  unsigned int ind=HASH_BUCKET(dh->hash_tab)[bhash];
 
 #ifdef DEBUG
-//    pf(__FUNCTION__); pf(": bucket("); ph(bhash); pf(",\""); pf(symbol); pf("\")\n");
+//  pf(__FUNCTION__); pf(": bucket("); ph(bhash); pf(",\""); pf(symbol); pf("\")\n");
+//  pf(__FUNCTION__); pf(": chain ("); ph(ind); pf(",\""); pf(symbol); pf("\")\n");
 #endif
 
-    ind=HASH_BUCKET(dh->hash_tab)[bhash];
+  while(ind) {
+    int ptr=dh->dyn_sym_tab[ind].st_name;
 #ifdef DEBUG
-//    pf(__FUNCTION__); pf(": chain ("); ph(ind); pf(",\""); pf(symbol); pf("\")\n");
+//    pf(__FUNCTION__); pf(": symbol(\""); pf(name+ptr); pf("\",\""); pf(symbol); pf("\")\n");
 #endif
-
-    while(ind) {
-      int ptr=dh->dyn_sym_tab[ind].st_name;
+    if (_dl_lib_strcmp(name+ptr,symbol)==0 && dh->dyn_sym_tab[ind].st_value!=0) {
+      if (dh->dyn_sym_tab[ind].st_shndx!=SHN_UNDEF) {
+	sym=(unsigned long*)(dh->mem_base+dh->dyn_sym_tab[ind].st_value);
+	break;	/* ok found ... */
+      }
+    }
+    ind=chain[ind];
+  }
+#ifdef DEBUG
+  pf(__FUNCTION__); pf(": symbol \""); pf(symbol); pf("\" @ "); ph((long)sym); pf("\n");
+#endif
+  return sym;
+}
+static void*_dlsym_gnuhash(struct _dl_handle*dh,const unsigned char*symbol) {
+  unsigned long*sym=0;
+  unsigned char*name=(unsigned char*)dh->dyn_str_tab;
+  unsigned int hash =gnu_hash(symbol);
+  unsigned int bhash=hash%GNU_HASH_BUCKET_LEN(dh->gnu_hash_tab);
+  unsigned int ind  =GNU_HASH_BUCKET(dh->gnu_hash_tab,bhash);
+#ifdef DEBUG
+  //pf(__FUNCTION__); pf(": bucket("); ph(bhash); pf(",\""); pf(symbol); pf("\")\n");
+  //pf(__FUNCTION__); pf(": chain ("); ph(ind); pf(",\""); pf(symbol); pf("\")\n");
+#endif
+  if (ind!=0xffffffff) {
+    unsigned int*chain=GNU_HASH_CHAIN(dh->gnu_hash_tab,ind);
+    unsigned int idx=chain[0];
+    unsigned int i,nr=chain[1];
+    chain+=2;
+    for (i=0;i<nr;++i) {
+      if (chain[i]==hash) {
+	unsigned int ptr=dh->dyn_sym_tab[idx+i].st_name;
 #ifdef DEBUG
-//      pf(__FUNCTION__); pf(": symbol(\""); pf(name+ptr); pf("\",\""); pf(symbol); pf("\")\n");
+	//pf(__FUNCTION__); pf(": symbol(\""); pf(name+ptr); pf("\",\""); pf(symbol); pf("\")\n");
 #endif
-      if (_dl_lib_strcmp(name+ptr,symbol)==0 && dh->dyn_sym_tab[ind].st_value!=0) {
-	if (dh->dyn_sym_tab[ind].st_shndx!=SHN_UNDEF) {
-	  sym=(unsigned long*)(dh->mem_base+dh->dyn_sym_tab[ind].st_value);
-	  break;	/* ok found ... */
+	if (_dl_lib_strcmp(name+ptr,symbol)==0 && dh->dyn_sym_tab[idx+i].st_value!=0) {
+	  if (dh->dyn_sym_tab[ind].st_shndx!=SHN_UNDEF) {
+	    sym=(unsigned long*)(dh->mem_base+dh->dyn_sym_tab[idx+i].st_value);
+	    break;
+	  }
 	}
       }
-      ind=chain[ind];
     }
+  }
 #ifdef DEBUG
-    pf(__FUNCTION__); pf(": symbol \""); pf(symbol); pf("\" @ "); ph((long)sym); pf("\n");
+  pf(__FUNCTION__); pf(": symbol \""); pf(symbol); pf("\" @ "); ph((long)sym); pf("\n");
 #endif
-  }
   return sym;
 }
 
 #ifdef __DIET_LD_SO__
 static
 #endif
+void *_dlsym(void* handle,const unsigned char* symbol) {
+  if (handle) {
+    struct _dl_handle*dh=(struct _dl_handle*)handle;
+    // if the GNU hash-table is present... use it.
+    if (dh->gnu_hash_tab)
+      return _dlsym_gnuhash(dh,symbol);
+    else
+      return _dlsym_elfhash(dh,symbol);
+  }
+  return 0;
+}
+
+#ifdef __DIET_LD_SO__
+static
+#endif
 void*_dl_sym_search_str(struct _dl_handle*dh_begin,const unsigned char*name) {
   void *sym=0;
   struct _dl_handle*tmp;
diff --git a/libdl/gnu_hash.h b/libdl/gnu_hash.h
new file mode 100644
index 0000000..b744021
--- /dev/null
+++ b/libdl/gnu_hash.h
@@ -0,0 +1,16 @@
+#ifndef __GNU_HASH_H__
+#define __GNU_HASH_H__
+
+#include <stdint.h>
+
+static uint_fast32_t gnu_hash(const unsigned char *s) {
+  unsigned char c;
+  uint_fast32_t h=5381;
+  for(c=*s;(c!='\0');c=*++s) {
+//    h=h*33+c;
+    h=((h<<5)+h)+c;
+  }
+  return (h&0xffffffff);
+}
+
+#endif
diff --git a/libpthread/pthread_cond_timedwait.c b/libpthread/pthread_cond_timedwait.c
index 303842b..38db46d 100644
--- a/libpthread/pthread_cond_timedwait.c
+++ b/libpthread/pthread_cond_timedwait.c
@@ -8,6 +8,7 @@ int pthread_cond_timedwait(pthread_cond_t*cond,pthread_mutex_t*mutex,
 		      const struct timespec*abstime) {
   _pthread_descr this=__thread_self();
   _pthread_descr*tmp;
+  int retval;
 
   if (mutex->owner!=this) return EINVAL;
 
@@ -25,7 +26,7 @@ int pthread_cond_timedwait(pthread_cond_t*cond,pthread_mutex_t*mutex,
   /* Aeh yeah / wait till condition-signal or timout (or cancel) */
   pthread_mutex_unlock(mutex);
 
-  __thread_suspend_till(this,1,abstime);
+  retval = __thread_suspend_till(this,1,abstime);
 
   pthread_mutex_lock(mutex);
 
@@ -40,7 +41,7 @@ int pthread_cond_timedwait(pthread_cond_t*cond,pthread_mutex_t*mutex,
 
   __NO_ASYNC_CANCEL_END_(this);
 
-  return 0;
+  return retval;
 }
 
 
diff --git a/libpthread/pthread_internal.c b/libpthread/pthread_internal.c
index cf5f418..3e435a3 100644
--- a/libpthread/pthread_internal.c
+++ b/libpthread/pthread_internal.c
@@ -204,10 +204,11 @@ static int __thread_cleanup(_pthread_descr td) {
 }
 
 /* suspend till timeout or restart signal / in NO_ASYNC_CANCEL */
-void __thread_suspend_till(_pthread_descr this,int cancel,const struct timespec*abstime) {
+int __thread_suspend_till(_pthread_descr this,int cancel,const struct timespec*abstime) {
   sigset_t newmask,oldmask;
   struct timeval tv;
   struct timespec reg;
+  int retval = 0;
 
   gettimeofday(&tv,0);
   reg.tv_nsec=abstime->tv_nsec-tv.tv_usec*1000;
@@ -225,9 +226,13 @@ void __thread_suspend_till(_pthread_descr this,int cancel,const struct timespec*
 
   while(this->p_sig!=PTHREAD_SIG_RESTART) {
     if (cancel && (this->cancelstate==PTHREAD_CANCEL_ENABLE) && this->canceled) break;
-    if (reg.tv_sec<0||__libc_nanosleep(&reg,&reg)==0) break;
+    if (reg.tv_sec<0||__libc_nanosleep(&reg,&reg)==0) {
+      retval = ETIMEDOUT;
+      break;
+    }
   }
   sigprocmask(SIG_SETMASK,&oldmask,0);
+  return retval;
 }
 
 /* suspend till restart signal */
diff --git a/libpthread/thread_internal.h b/libpthread/thread_internal.h
index f289a9b..e1d0704 100644
--- a/libpthread/thread_internal.h
+++ b/libpthread/thread_internal.h
@@ -126,7 +126,7 @@ int __thread_join_cleanup(struct _pthread_descr_struct*td);
 
 void __thread_restart(struct _pthread_descr_struct*td);
 void __thread_suspend(struct _pthread_descr_struct*td,int cancel);
-void __thread_suspend_till(struct _pthread_descr_struct*td,int cancel,const struct timespec*abstime);
+int __thread_suspend_till(struct _pthread_descr_struct*td,int cancel,const struct timespec*abstime);
 
 void __thread_testcancel(struct _pthread_descr_struct*td);
 int __thread_setcanceltype(int type,int*oldtype,struct _pthread_descr_struct*td);
diff --git a/librpc/clnt_simple.c b/librpc/clnt_simple.c
index 3c6fd74..a1a7e85 100644
--- a/librpc/clnt_simple.c
+++ b/librpc/clnt_simple.c
@@ -64,15 +64,20 @@ int callrpc (const char *host, const unsigned long prognum,
 	enum clnt_stat clnt_stat;
 	struct hostent *hp;
 	struct timeval timeout, tottimeout;
+	void* freeme=0;
 
 	if (crp == 0) {
 		crp = (struct callrpc_private *) calloc(1, sizeof(*crp));
 		if (crp == 0)
 			return (0);
-		callrpc_private = crp;
+		freeme = callrpc_private = crp;
 	}
 	if (crp->oldhost == NULL) {
 		crp->oldhost = malloc(256);
+		if (!crp->oldhost) {
+		  free(freeme);
+		  return 0;
+		}
 		crp->oldhost[0] = 0;
 		crp->socket = RPC_ANYSOCK;
 	}
diff --git a/librpc/svc_auth_unix.c b/librpc/svc_auth_unix.c
index aabf789..193e6ce 100644
--- a/librpc/svc_auth_unix.c
+++ b/librpc/svc_auth_unix.c
@@ -67,8 +67,8 @@ register struct rpc_msg *msg;
 		gid_t area_gids[NGRPS];
 	} *area;
 	unsigned int auth_len;
-	int str_len, gid_len;
-	register int i;
+	unsigned int str_len, gid_len;
+	register unsigned int i;
 
 	area = (struct area *) rqst->rq_clntcred;
 	aup = &area->area_aup;
diff --git a/libshell/dirname.c b/libshell/dirname.c
index ca2d8c2..4370502 100644
--- a/libshell/dirname.c
+++ b/libshell/dirname.c
@@ -26,7 +26,7 @@ char *dirname(char *path)
       continue;
     }
     if ( c!=path )
-      while ( *c==SLASH ) *c--=EOL; /* slashes in the middle */
+      while ( *c==SLASH && c>=path) *c--=EOL; /* slashes in the middle */
     else
       path[1]=EOL;                  /* slash is first symbol */
     return path;
diff --git a/libstdio/ftell.c b/libstdio/ftell.c
index 92099a8..9e53168 100644
--- a/libstdio/ftell.c
+++ b/libstdio/ftell.c
@@ -4,10 +4,11 @@
 
 long ftell_unlocked(FILE *stream) {
   off_t l;
-  if (fflush_unlocked(stream)) return -1;
-  l=lseek(stream->fd,0,SEEK_CUR);
-  if (l==-1) return -1;
-  return l-stream->ungotten;
+  if (stream->flags&3 || (l=lseek(stream->fd,0,SEEK_CUR))==-1) return -1;
+  if (stream->flags&BUFINPUT)
+    return l-(stream->bs-stream->bm)-stream->ungotten;
+  else
+    return l+stream->bm;
 }
 
 long ftell(FILE *stream) __attribute__((weak,alias("ftell_unlocked")));
diff --git a/libugly/ctime_r.c b/libugly/ctime_r.c
new file mode 100644
index 0000000..33afbdc
--- /dev/null
+++ b/libugly/ctime_r.c
@@ -0,0 +1,5 @@
+#include <time.h>
+
+char *ctime_r(const time_t *timep, char* buf) {
+  return asctime_r(localtime(timep),buf);
+}
diff --git a/libugly/getaddrinfo.c b/libugly/getaddrinfo.c
index 17156d8..059c688 100644
--- a/libugly/getaddrinfo.c
+++ b/libugly/getaddrinfo.c
@@ -28,9 +28,10 @@ int getaddrinfo(const char *node, const char *service, const struct addrinfo *hi
       struct hostent *H;
       int herrno=0;
       char buf[4096];
-      int lookupok=0;
+      int lookupok=0, i;
       char* interface;
       h.h_addr_list=(char**)buf+16;
+      h.h_addr_list[1]=0;
       if (node) {
 	if ((interface=strchr(node,'%'))) ++interface;
 	if (family==PF_INET6 && inet_pton(AF_INET,node,buf)) continue;
@@ -58,94 +59,82 @@ int getaddrinfo(const char *node, const char *service, const struct addrinfo *hi
 	lookupok=1;
       }
       if (lookupok) {
-	struct ai_v6 {
-	  struct addrinfo ai;
-	  union {
-	    struct sockaddr_in6 ip6;
-	    struct sockaddr_in ip4;
-	  } ip;
-	  char name[1];
-	} *foo;
-	unsigned short port;
-	int len=sizeof(struct ai_v6)+(h.h_name?strlen(h.h_name):0);
-	if (!(foo=malloc(len))) goto error;
-	foo->ai.ai_next=0;
-	foo->ai.ai_socktype=SOCK_STREAM;
-	foo->ai.ai_protocol=IPPROTO_TCP;
-	foo->ai.ai_addrlen=family==PF_INET6?sizeof(struct sockaddr_in6):sizeof(struct sockaddr_in);
-	foo->ai.ai_addr=(struct sockaddr*)&foo->ip;
-	if (family==PF_INET6) {
-	  memset(&foo->ip,0,sizeof(foo->ip));
-	  memmove(&foo->ip.ip6.sin6_addr,h.h_addr_list[0],16);
-	  if (interface) foo->ip.ip6.sin6_scope_id=if_nametoindex(interface);
-	} else {
-	  memmove(&foo->ip.ip4.sin_addr,h.h_addr_list[0],4);
-	}
-	foo->ip.ip6.sin6_family=foo->ai.ai_family=family;
+
+	for (i=0; h.h_addr_list[i]; ++i) {
+	  struct ai_v6 {
+	    struct addrinfo ai;
+	    union {
+	      struct sockaddr_in6 ip6;
+	      struct sockaddr_in ip4;
+	    } ip;
+	    char name[1];
+	  } *foo;
+	  unsigned short port;
+	  int len;
+
+	  len=sizeof(struct ai_v6)+(h.h_name?strlen(h.h_name):0);
+
+	  if (!(foo=malloc(len))) goto error;
+	  foo->ai.ai_next=0;
+	  foo->ai.ai_addrlen=family==PF_INET6?sizeof(struct sockaddr_in6):sizeof(struct sockaddr_in);
+	  foo->ai.ai_addr=(struct sockaddr*)&foo->ip;
+	  if (family==PF_INET6) {
+	    memset(&foo->ip,0,sizeof(foo->ip));
+	    memmove(&foo->ip.ip6.sin6_addr,h.h_addr_list[i],16);
+	    if (interface) foo->ip.ip6.sin6_scope_id=if_nametoindex(interface);
+	  } else {
+	    memmove(&foo->ip.ip4.sin_addr,h.h_addr_list[i],4);
+	  }
+	  foo->ip.ip6.sin6_family=foo->ai.ai_family=family;
 #ifdef WANT_PLUGPLAY_DNS
-	if (family==AF_INET6 && node) {
-	  int l=strlen(node);
-	  if (!strcmp(node-6,".local"))
-	    foo->ip.ip6.sin6_scope_id=__dns_plugplay_interface;
-	}
+	  if (family==AF_INET6 && node) {
+	    int l=strlen(node);
+	    if (l>6 && !strcmp(node+l-6,".local"))
+	      foo->ip.ip6.sin6_scope_id=__dns_plugplay_interface;
+	  }
 #endif
-	if (h.h_name) {
-	  foo->ai.ai_canonname=foo->name;
-	  memmove(foo->name,h.h_name,strlen(h.h_name)+1);
-	} else
-	  foo->ai.ai_canonname=0;
-	if (!hints || hints->ai_socktype!=SOCK_DGRAM) {	/* TCP is OK */
-	  char *x;
-	  port=htons(strtol(service?service:"0",&x,0));
-	  if (*x) {	/* service is not numeric :-( */
-	    struct servent* se;
-	    if ((se=getservbyname(service,"tcp"))) {	/* found a service. */
-	      port=se->s_port;
-blah1:
-	      if (family==PF_INET6)
-		foo->ip.ip6.sin6_port=port;
-	      else
-		foo->ip.ip4.sin_port=port;
-	      if (!*tmp) *tmp=&(foo->ai); else (*tmp)->ai_next=&(foo->ai);
-	      if (!(foo=malloc(len))) goto error;
-	      memmove(foo,*tmp,len);
-	      tmp=&(*tmp)->ai_next;
-	      foo->ai.ai_addr=(struct sockaddr*)&foo->ip;
-	      if (foo->ai.ai_canonname)
-		foo->ai.ai_canonname=foo->name;
-	    } else {
-	      freeaddrinfo(*res);
-	      return EAI_SERVICE;
+	  if (h.h_name) {
+	    foo->ai.ai_canonname=foo->name;
+	    memmove(foo->name,h.h_name,strlen(h.h_name)+1);
+	  } else
+	    foo->ai.ai_canonname=0;
+
+	  for (foo->ai.ai_socktype=SOCK_STREAM; ; foo->ai.ai_socktype=SOCK_DGRAM) {
+	    char* type,* x;
+	    if (foo->ai.ai_socktype==SOCK_STREAM) {	/* TCP */
+	      if (hints->ai_socktype==SOCK_DGRAM) continue;
+	      foo->ai.ai_protocol=IPPROTO_TCP;
+	      type="tcp";
+	    } else {	/* UDP */
+	      if (hints->ai_socktype==SOCK_STREAM) break;
+	      foo->ai.ai_protocol=IPPROTO_UDP;
+	      type="udp";
 	    }
-	  } else goto blah1;
-	}
-	foo->ai.ai_socktype=SOCK_DGRAM;
-	foo->ai.ai_protocol=IPPROTO_UDP;
-	if (!hints || hints->ai_socktype!=SOCK_STREAM) {	/* UDP is OK */
-	  char *x;
-	  port=htons(strtol(service?service:"0",&x,0));
-	  if (*x) {	/* service is not numeric :-( */
-	    struct servent* se;
-	    if ((se=getservbyname(service,"udp"))) {	/* found a service. */
-	      port=se->s_port;
-blah2:
-	      if (family==PF_INET6)
-		foo->ip.ip6.sin6_port=port;
-	      else
-		foo->ip.ip4.sin_port=port;
-	      if (!*tmp) *tmp=&(foo->ai); else (*tmp)->ai_next=&(foo->ai);
-	      if (!(foo=malloc(len))) goto error;
-	      memmove(foo,*tmp,len);
-	      tmp=&(*tmp)->ai_next;
-	      foo->ai.ai_addr=(struct sockaddr*)&foo->ip;
-	      foo->ai.ai_canonname=foo->name;
-	    } else {
-	      freeaddrinfo(*res);
-	      return EAI_SERVICE;
+	    port=htons(strtol(service?service:"0",&x,0));
+	    if (*x) {	/* service is not numeric :-( */
+	      struct servent* se;
+	      if ((se=getservbyname(service,type)))
+		port=se->s_port;
+	      else {
+		freeaddrinfo(*res);
+		return EAI_SERVICE;
+	      }
 	    }
-	  } else goto blah2;
+	    if (family==PF_INET6)
+	      foo->ip.ip6.sin6_port=port;
+	    else
+	      foo->ip.ip4.sin_port=port;
+	    if (!*tmp) *tmp=&(foo->ai); else (*tmp)->ai_next=&(foo->ai);
+	    if (!(foo=malloc(len))) goto error;
+	    memmove(foo,*tmp,len);
+	    tmp=&(*tmp)->ai_next;
+	    foo->ai.ai_addr=(struct sockaddr*)&foo->ip;
+	    if (foo->ai.ai_canonname)
+	      foo->ai.ai_canonname=foo->name;
+	    if (foo->ai.ai_socktype==SOCK_DGRAM) break;
+	  }
+	  free(foo);
 	}
-	free(foo);
       }
     }
     if (family==PF_INET) break;
diff --git a/libugly/iconv.c b/libugly/iconv.c
index ee5bd88..c2f94f9 100644
--- a/libugly/iconv.c
+++ b/libugly/iconv.c
@@ -91,7 +91,6 @@ utf16le:
       if (*outbytesleft<1) goto bloat;
       if (v>0xff) ++result;
       *out=(unsigned char)v;
-      ++j;
       break;
     case UCS_2:
       if (*outbytesleft<2) goto bloat;
diff --git a/libugly/strftime.c b/libugly/strftime.c
index c81c03d..56ae082 100644
--- a/libugly/strftime.c
+++ b/libugly/strftime.c
@@ -36,6 +36,7 @@ size_t  strftime ( char* dst, size_t max, const char* format, const struct tm* t
     unsigned long no;
     char          buf [5];
 
+    if (!max) return 0;
     for ( ; *format != '\0'; format++ ) {
 	if (*format == '%') {
 	    if (*++format == '%') {
diff --git a/libugly/strndup.c b/libugly/strndup.c
index 57633b9..57826ab 100644
--- a/libugly/strndup.c
+++ b/libugly/strndup.c
@@ -2,9 +2,16 @@
 /* *puke* */
 #include <string.h>
 #include <stdlib.h>
+#include "dietfeatures.h"
 
 char *strndup(const char *s,size_t n) {
+  /* This relies on the fact that our malloc(0) returns NULL.
+   * Otherwise this would be an exploitable integer overflow! */
+#ifdef WANT_MALLOC_ZERO
+  char *tmp=!(n+1)?0:(char *)malloc(n+1);
+#else
   char *tmp=(char *)malloc(n+1);
+#endif
   if (!tmp) return 0;
   strncpy(tmp,s,n);
   tmp[n]=0;
diff --git a/libugly/strptime.c b/libugly/strptime.c
index 24d6c4d..3cf35b3 100644
--- a/libugly/strptime.c
+++ b/libugly/strptime.c
@@ -3,6 +3,8 @@
 #include <string.h>
 #include <strings.h>
 
+extern const short  __spm [];
+
 static const char*  months [12] = { 
     "January", "February", "March", "April", "May", "June",
     "July", "August", "September", "October", "November", "December"
@@ -22,6 +24,7 @@ static int getint(const char** s,int max) {
 
 char* strptime(const char* s,const char* format, struct tm* tm) {
   int i,j;
+  register time_t  day;
   while (*format) {
     switch (*format) {
     case ' ': case '\t':
@@ -32,7 +35,7 @@ char* strptime(const char* s,const char* format, struct tm* tm) {
     case '%':
       ++format;
       switch (*format) {
-      case '%': if (*s=='%') ++s; else return (char*)s; break;
+      case '%': if (*s=='%') ++s; else return 0; break;
       case 'a': case 'A': /* weekday; we just skip */
 	for (i=0; i<3; ++i)
 	  if (isalpha(*s)) ++s;
@@ -44,7 +47,7 @@ char* strptime(const char* s,const char* format, struct tm* tm) {
 	      j=0;
 	  if (j) break;
 	}
-	if (!j) return (char*)s;
+	if (!j) return 0;
 	s+=j;
 	tm->tm_mon=i;
 	break;
@@ -53,12 +56,12 @@ char* strptime(const char* s,const char* format, struct tm* tm) {
 	break;
       case 'C':
 	i=getint(&s,2);
-	if (i==-1) return (char*)s;
+	if (i==-1) return 0;
 	tm->tm_year=(tm->tm_year%100)+(i*100);
 	break;
       case 'd': case 'e':
 	i=getint(&s,2);
-	if (i==-1 || i>31) return (char*)s;
+	if (i==-1 || i>31) return 0;
 	tm->tm_mday=i;
 	break;
       case 'D':
@@ -66,12 +69,12 @@ char* strptime(const char* s,const char* format, struct tm* tm) {
 	break;
       case 'H': case 'k':
 	i=getint(&s,2);
-	if (i==-1 || i>23) return (char*)s;
+	if (i==-1 || i>23) return 0;
 	tm->tm_hour=i;
 	break;
       case 'I': case 'l':
 	i=getint(&s,2);
-	if (i==-1 || i>12) return (char*)s;
+	if (i==-1 || i>12) return 0;
 	tm->tm_hour=(tm->tm_hour/12)*12+i;
 	break;
       case 'j':
@@ -79,12 +82,12 @@ char* strptime(const char* s,const char* format, struct tm* tm) {
 	break;
       case 'm':
 	i=getint(&s,2);
-	if (i<=0 || i>12) return (char*)s;
+	if (i<=0 || i>12) return 0;
 	tm->tm_mon=i-1;
 	break;
       case 'M':
 	i=getint(&s,2);
-	if (i==-1 || i>59) return (char*)s;
+	if (i==-1 || i>59) return 0;
 	tm->tm_min=i;
 	break;
       case 'n': case 't':
@@ -102,17 +105,17 @@ char* strptime(const char* s,const char* format, struct tm* tm) {
 	break;
       case 'S':
 	i=getint(&s,2);
-	if (i==-1 || i>60) return (char*)s;
+	if (i==-1 || i>60) return 0;
 	tm->tm_sec=i;
 	break;
       case 'T':
 	s=strptime(s,"%H:%M:%S",tm);
 	break;
       case 'U': case 'W':
-	if (getint(&s,2)==-1) return (char*)s;
+	if (getint(&s,2)==-1) return 0;
 	break;
       case 'w':
-	if (*s<'0' || *s>'6') return (char*)s;
+	if (*s<'0' || *s>'6') return 0;
 	++s;
 	break;
       case 'x':
@@ -123,22 +126,27 @@ char* strptime(const char* s,const char* format, struct tm* tm) {
 	break;
       case 'y':
 	i=getint(&s,2);
-	if (i<0) return (char*)s;
+	if (i<0) return 0;
 	tm->tm_year=(i<69)?i+100:i;
 	break;
       case 'Y':
 	i=getint(&s,5);
-	if (i==-1) return (char*)s;
+	if (i==-1) return 0;
 	tm->tm_year=i-1900;
 	break;
       }
       ++format;
       break;
     default:
-      if (*s != *format) return (char*)s;
+      if (*s != *format) return 0;
       ++format; ++s;
       break;
-      }
+    }
   }
+ 
+  day  = (tm->tm_year - 70) * 365 + (tm->tm_year - 69) / 4;
+  day += tm->tm_yday = __spm [tm->tm_mon] + tm->tm_mday-1 + (__isleap (tm->tm_year+1900) & (tm->tm_mon > 1));
+  tm->tm_wday = (day + 4) % 7;
+
   return (char*)s;
 }
diff --git a/libugly/strsignal.c b/libugly/strsignal.c
index d727775..609edba 100644
--- a/libugly/strsignal.c
+++ b/libugly/strsignal.c
@@ -3,7 +3,7 @@
 #include <signal.h>
 
 const char* strsignal(int sig) {
-  if (sig<=SIGRTMAX)
+  if ((unsigned int)sig<=SIGRTMAX)
     return sys_siglist[sig];
   else
     return "(unknown signal)";
diff --git a/mips/syscalls.h b/mips/syscalls.h
index cbda1c9..8acaf62 100644
--- a/mips/syscalls.h
+++ b/mips/syscalls.h
@@ -286,6 +286,32 @@
 #define __NR_add_key			(__NR_Linux + 280)
 #define __NR_request_key		(__NR_Linux + 281)
 #define __NR_keyctl			(__NR_Linux + 282)
+#define __NR_set_thread_area		(__NR_Linux + 283)
+#define __NR_inotify_init		(__NR_Linux + 284)
+#define __NR_inotify_add_watch		(__NR_Linux + 285)
+#define __NR_inotify_rm_watch		(__NR_Linux + 286)
+#define __NR_migrate_pages		(__NR_Linux + 287)
+#define __NR_openat			(__NR_Linux + 288)
+#define __NR_mkdirat			(__NR_Linux + 289)
+#define __NR_mknodat			(__NR_Linux + 290)
+#define __NR_fchownat			(__NR_Linux + 291)
+#define __NR_futimesat			(__NR_Linux + 292)
+#define __NR_fstatat			(__NR_Linux + 293)
+#define __NR_unlinkat			(__NR_Linux + 294)
+#define __NR_renameat			(__NR_Linux + 295)
+#define __NR_linkat			(__NR_Linux + 296)
+#define __NR_symlinkat			(__NR_Linux + 297)
+#define __NR_readlinkat			(__NR_Linux + 298)
+#define __NR_fchmodat			(__NR_Linux + 299)
+#define __NR_faccessat			(__NR_Linux + 300)
+#define __NR_pselect6			(__NR_Linux + 301)
+#define __NR_ppoll			(__NR_Linux + 302)
+#define __NR_unshare			(__NR_Linux + 303)
+#define __NR_splice			(__NR_Linux + 304)
+#define __NR_sync_file_range		(__NR_Linux + 305)
+#define __NR_tee			(__NR_Linux + 306)
+#define __NR_vmsplice			(__NR_Linux + 307)
+#define __NR_move_pages			(__NR_Linux + 308)
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff --git a/ppc/syscalls.h b/ppc/syscalls.h
index fe90338..5b8a557 100644
--- a/ppc/syscalls.h
+++ b/ppc/syscalls.h
@@ -276,6 +276,29 @@
 #define __NR_inotify_init	275
 #define __NR_inotify_add_watch	276
 #define __NR_inotify_rm_watch	277
+#define __NR_spu_run		278
+#define __NR_spu_create		279
+#define __NR_pselect6		280
+#define __NR_ppoll		281
+#define __NR_unshare		282
+#define __NR_splice		283
+#define __NR_tee		284
+#define __NR_vmsplice		285
+#define __NR_openat		286
+#define __NR_mkdirat		287
+#define __NR_mknodat		288
+#define __NR_fchownat		289
+#define __NR_futimesat		290
+#define __NR_fstatat64		291
+#define __NR_unlinkat		292
+#define __NR_renameat		293
+#define __NR_linkat		294
+#define __NR_symlinkat		295
+#define __NR_readlinkat		296
+#define __NR_fchmodat		297
+#define __NR_faccessat		298
+#define __NR_get_robust_list	299
+#define __NR_set_robust_list	300
 
 
 #define syscall_weak(name,wsym,sym) \
diff --git a/ppc64/syscalls.h b/ppc64/syscalls.h
index 0bab0d2..f59da5d 100644
--- a/ppc64/syscalls.h
+++ b/ppc64/syscalls.h
@@ -276,6 +276,29 @@
 #define __NR_inotify_init	275
 #define __NR_inotify_add_watch	276
 #define __NR_inotify_rm_watch	277
+#define __NR_spu_run		278
+#define __NR_spu_create		279
+#define __NR_pselect6		280
+#define __NR_ppoll		281
+#define __NR_unshare		282
+#define __NR_splice		283
+#define __NR_tee		284
+#define __NR_vmsplice		285
+#define __NR_openat		286
+#define __NR_mkdirat		287
+#define __NR_mknodat		288
+#define __NR_fchownat		289
+#define __NR_futimesat		290
+#define __NR_newfstatat		291
+#define __NR_unlinkat		292
+#define __NR_renameat		293
+#define __NR_linkat		294
+#define __NR_symlinkat		295
+#define __NR_readlinkat		296
+#define __NR_fchmodat		297
+#define __NR_faccessat		298
+#define __NR_get_robust_list	299
+#define __NR_set_robust_list	300
 
 
 
diff --git a/s390/syscalls.h b/s390/syscalls.h
index e89aaac..3c49488 100644
--- a/s390/syscalls.h
+++ b/s390/syscalls.h
@@ -271,6 +271,28 @@
 #define __NR_inotify_init	284
 #define __NR_inotify_add_watch	285
 #define __NR_inotify_rm_watch	286
+/* Number 287 is reserved for new sys_migrate_pages */
+#define __NR_openat		288
+#define __NR_mkdirat		289
+#define __NR_mknodat		290
+#define __NR_fchownat		291
+#define __NR_futimesat		292
+#define __NR_unlinkat		294
+#define __NR_renameat		295
+#define __NR_linkat		296
+#define __NR_symlinkat		297
+#define __NR_readlinkat		298
+#define __NR_fchmodat		299
+#define __NR_faccessat		300
+#define __NR_pselect6		301
+#define __NR_ppoll		302
+#define __NR_unshare		303
+#define __NR_set_robust_list	304
+#define __NR_get_robust_list	305
+#define __NR_splice		306
+#define __NR_sync_file_range	307
+#define __NR_tee		308
+#define __NR_vmsplice		309
 
 
 #define syscall_weak(name,wsym,sym) \
diff --git a/s390x/syscalls.h b/s390x/syscalls.h
index 1544c76..78acaed 100644
--- a/s390x/syscalls.h
+++ b/s390x/syscalls.h
@@ -271,6 +271,28 @@
 #define __NR_inotify_init	284
 #define __NR_inotify_add_watch	285
 #define __NR_inotify_rm_watch	286
+/* Number 287 is reserved for new sys_migrate_pages */
+#define __NR_openat		288
+#define __NR_mkdirat		289
+#define __NR_mknodat		290
+#define __NR_fchownat		291
+#define __NR_futimesat		292
+#define __NR_unlinkat		294
+#define __NR_renameat		295
+#define __NR_linkat		296
+#define __NR_symlinkat		297
+#define __NR_readlinkat		298
+#define __NR_fchmodat		299
+#define __NR_faccessat		300
+#define __NR_pselect6		301
+#define __NR_ppoll		302
+#define __NR_unshare		303
+#define __NR_set_robust_list	304
+#define __NR_get_robust_list	305
+#define __NR_splice		306
+#define __NR_sync_file_range	307
+#define __NR_tee		308
+#define __NR_vmsplice		309
 
 
 /* 
@@ -334,6 +356,7 @@
 #undef  __NR_fcntl64
 #undef  __NR_sendfile64
 #undef  __NR_fadvise64_64
+#undef  __NR_fstatat64
 
 #define __NR_select		142
 #define __NR_getrlimit		191	/* SuS compliant getrlimit */
@@ -356,6 +379,7 @@
 #define __NR_setgid  		214
 #define __NR_setfsuid  		215
 #define __NR_setfsgid  		216
+#define __NR_newfstatat		293
 
 #endif
 
diff --git a/sparc/syscalls.h b/sparc/syscalls.h
index d18c26d..fbfb20c 100644
--- a/sparc/syscalls.h
+++ b/sparc/syscalls.h
@@ -282,6 +282,24 @@
 #define __NR_add_key		281
 #define __NR_request_key	282
 #define __NR_keyctl		283
+#define __NR_openat		284
+#define __NR_mkdirat		285
+#define __NR_mknodat		286
+#define __NR_fchownat		287
+#define __NR_futimesat		288
+#define __NR_fstatat64		289
+#define __NR_unlinkat		290
+#define __NR_renameat		291
+#define __NR_linkat		292
+#define __NR_symlinkat		293
+#define __NR_readlinkat		294
+#define __NR_fchmodat		295
+#define __NR_faccessat		296
+#define __NR_pselect6		297
+#define __NR_ppoll		298
+#define __NR_unshare		299
+#define __NR_set_robust_list	300
+#define __NR_get_robust_list	301
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff --git a/sparc64/longjmp.S b/sparc64/longjmp.S
index fd15ca2..371a4a9 100644
--- a/sparc64/longjmp.S
+++ b/sparc64/longjmp.S
@@ -11,7 +11,7 @@ longjmp:
 .type	__libc_longjmp,function
 __libc_longjmp:
 	movrz	%o1, 1, %o1			/* never return 0 in setjmp */
-	stx	%o1, [ %o0+MC_G1 ]		/* save return value in context */
+	stx	%o1, [ %o0 + (4+MC_G1) * 8 ]    /* save return value in context */
 	ld	[ %o0+FLAG_SAVEMASK ], %o1	/* has setjmp saved the signalmask ? */
 	ta	0x6f				/* setcontext / restore context */
 .size	__libc_longjmp,.-__libc_longjmp
diff --git a/sparc64/syscalls.h b/sparc64/syscalls.h
index 4617eba..575ef80 100644
--- a/sparc64/syscalls.h
+++ b/sparc64/syscalls.h
@@ -281,6 +281,24 @@
 #define __NR_add_key		281
 #define __NR_request_key	282
 #define __NR_keyctl		283
+#define __NR_openat		284
+#define __NR_mkdirat		285
+#define __NR_mknodat		286
+#define __NR_fchownat		287
+#define __NR_futimesat		288
+#define __NR_fstatat64		289
+#define __NR_unlinkat		290
+#define __NR_renameat		291
+#define __NR_linkat		292
+#define __NR_symlinkat		293
+#define __NR_readlinkat		294
+#define __NR_fchmodat		295
+#define __NR_faccessat		296
+#define __NR_pselect6		297
+#define __NR_ppoll		298
+#define __NR_unshare		299
+#define __NR_set_robust_list	300
+#define __NR_get_robust_list	301
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff --git a/syscalls.s/__guard.S b/syscalls.s/__guard.S
index 394d05c..cc2a00d 100644
--- a/syscalls.s/__guard.S
+++ b/syscalls.s/__guard.S
@@ -1,3 +1,4 @@
+#include <endian.h>
 .data
 .type __guard,@object
 .global __guard
@@ -5,5 +6,9 @@
 .global __stack_chk_guard
 __guard:
 __stack_chk_guard:
+#if __WORDSIZE == 64
+.quad 0xaff00
+#else
 .long 0xaff00
+#endif
 
diff --git a/test/ftell.c b/test/ftell.c
new file mode 100644
index 0000000..2aa8d69
--- /dev/null
+++ b/test/ftell.c
@@ -0,0 +1,26 @@
+#include <stdio.h>
+#include <assert.h>
+
+int main() {
+  FILE* f = popen("/bin/echo testing","r");
+  int i=getc(f);
+  assert(ftell(f)==-1);
+  assert(getc(f) == 'e');
+  pclose(f);
+  f=fopen("/tmp/test","w");
+  assert(ftell(f)==0);
+  fputs("test",f);
+  assert(ftell(f)==4);
+  fclose(f);
+  f=fopen("/tmp/test","r");
+  assert(ftell(f)==0);
+  i=getc(f);
+  assert(ftell(f)==1);
+  ungetc(i,f);
+  assert(ftell(f)==0);
+  i=getc(f);
+  i=getc(f);
+  assert(ftell(f)==2);
+  fclose(f);
+  unlink("/tmp/test");
+}
diff --git a/test/getaddrinfo.c b/test/getaddrinfo.c
index 4ad41c6..d5ff321 100644
--- a/test/getaddrinfo.c
+++ b/test/getaddrinfo.c
@@ -13,7 +13,7 @@ int main() {
   memset(&hints,0,sizeof(hints));
   hints.ai_family=AF_UNSPEC;
   hints.ai_flags=0;
-  hints.ai_socktype=SOCK_STREAM;
+  hints.ai_socktype=0;
   if ((gaierr = getaddrinfo(NULL,"6010",&hints,&aitop)) != 0) {
     printf("error: %.100s\n",gai_strerror(gaierr));
     exit(0);
diff --git a/test/getopt.c b/test/getopt.c
index 96cf52e..31622fa 100644
--- a/test/getopt.c
+++ b/test/getopt.c
@@ -1,78 +1,79 @@
-       #include <stdio.h>     /* for printf */
-       #include <stdlib.h>    /* for exit */
-       #include <getopt.h>
+#include <stdio.h>     /* for printf */
+#include <stdlib.h>    /* for exit */
+#include <getopt.h>
 
-       int
-       main (int argc, char **argv) {
-           int c;
-           int digit_optind = 0;
+int
+main (int argc, char **argv) {
+  int c;
+  int digit_optind = 0;
 
-           while (1) {
-               int this_option_optind = optind ? optind : 1;
-               int option_index = 0;
-               static struct option long_options[] = {
-                   {"add", 1, 0, 0},
-                   {"append", 0, 0, 0},
-                   {"delete", 1, 0, 0},
-                   {"verbose", 0, 0, 0},
-                   {"create", 1, 0, 'c'},
-                   {"file", 1, 0, 0},
-                   {0, 0, 0, 0}
-               };
+  while (1) {
+    int this_option_optind = optind ? optind : 1;
+    int option_index = 0;
+    static struct option long_options[] = {
+      {"add-file", 1, 0, 0},
+      {"add", 1, 0, 0},
+      {"append", 0, 0, 0},
+      {"delete", 1, 0, 0},
+      {"verbose", 0, 0, 0},
+      {"create", 1, 0, 'c'},
+      {"file", 1, 0, 0},
+      {0, 0, 0, 0}
+    };
 
-               c = getopt_long_only (argc, argv, "abc:d:012",
-                        long_options, &option_index);
-               if (c == -1)
-                   break;
+    c = getopt_long_only (argc, argv, "abc:d:012",
+			  long_options, &option_index);
+    if (c == -1)
+	break;
 
-               switch (c) {
-               case 0:
-                   printf ("option %s", long_options[option_index].name);
-                   if (optarg)
-                       printf (" with arg %s", optarg);
-                   printf ("\n");
-                   break;
+    switch (c) {
+    case 0:
+      printf ("option %s", long_options[option_index].name);
+      if (optarg)
+	printf (" with arg %s", optarg);
+      printf ("\n");
+      break;
 
-               case '0':
-               case '1':
-               case '2':
-                   if (digit_optind != 0 && digit_optind != this_option_optind)
-                     printf ("digits occur in two different argv-elements.\n");
-                   digit_optind = this_option_optind;
-                   printf ("option %c\n", c);
-                   break;
+    case '0':
+    case '1':
+    case '2':
+      if (digit_optind != 0 && digit_optind != this_option_optind)
+	printf ("digits occur in two different argv-elements.\n");
+      digit_optind = this_option_optind;
+      printf ("option %c\n", c);
+      break;
 
-               case 'a':
-                   printf ("option a\n");
-                   break;
+    case 'a':
+      printf ("option a\n");
+      break;
 
-               case 'b':
-                   printf ("option b\n");
-                   break;
+    case 'b':
+      printf ("option b\n");
+      break;
 
-               case 'c':
-                   printf ("option c with value `%s'\n", optarg);
-                   break;
+    case 'c':
+      printf ("option c with value `%s'\n", optarg);
+      break;
 
-               case 'd':
-                   printf ("option d with value `%s'\n", optarg);
-                   break;
+    case 'd':
+      printf ("option d with value `%s'\n", optarg);
+      break;
 
-               case '?':
-                   break;
+    case '?':
+      break;
 
-               default:
-                   printf ("?? getopt returned character code 0%o ??\n", c);
-               }
-           }
+    default:
+      printf ("?? getopt returned character code 0%o ??\n", c);
+    }
+  }
 
-           if (optind < argc) {
-               printf ("non-option ARGV-elements: ");
-               while (optind < argc)
-                   printf ("%s ", argv[optind++]);
-               printf ("\n");
-           }
+  if (optind < argc) {
+    printf ("non-option ARGV-elements: ");
+    while (optind < argc)
+      printf ("%s ", argv[optind++]);
+    printf ("\n");
+  }
 
-           exit (0);
-       }
+  exit (0);
+}
 
diff --git a/test/qsort.c b/test/qsort.c
new file mode 100644
index 0000000..3b9247d
--- /dev/null
+++ b/test/qsort.c
@@ -0,0 +1,78 @@
+#define _BSD_SOURCE
+#define _GNU_SOURCE
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <inttypes.h>
+
+int compar(const void* a,const void* b) {
+  const unsigned char* A=*(void **)a;
+  const unsigned char* B=*(void **)b;
+  int l;
+  while (l=(*A-*B)) {
+    if (!*A) return 0;
+    ++A; ++B;
+  }
+  return l;
+}
+
+char** A;
+unsigned long a,n;
+
+#if defined (__i386__)
+#define RDTSC(dst) asm volatile ("rdtsc" : "=A" (dst))
+#elif defined (__x86_64__)
+#define RDTSC(dst) do {                                                        \
+  uint32_t l, h;                                                               \
+  asm volatile ("rdtsc" : "=a" (l), "=d" (h)); \
+  dst = (((uint64_t)h) << 32) | l;                             \
+} while (0)
+#else
+#error "Unimplemented rdtsc"
+#endif
+
+int main() {
+  char buf[2048];
+  unsigned long x,y;
+  while (fgets(buf,sizeof(buf),stdin)) {
+    buf[sizeof(buf)-1]=0;
+    if (n==a) {
+      a+=512;
+      A=realloc(A,a*sizeof(*A));
+      if (!A) {
+	printf("realloc to %lu elements failed!\n",a);
+	return 1;
+      }
+    }
+    if (!(A[n]=strdup(buf))) {
+      printf("strdup failed!\n");
+      return 1;
+    }
+    ++n;
+  }
+  printf("sorting %lu elements...\n",n);
+  {
+    char** B=malloc(n*sizeof(*A));
+    if (!B) {
+      printf("could not alloc %lu bytes!\n",n*sizeof(*A));
+      return 1;
+    }
+    memcpy(B,A,n*sizeof(*A));
+    qsort(A,n,sizeof(*A),compar);
+    memcpy(A,B,n*sizeof(*A));
+  }
+  RDTSC(x);
+  qsort(A,n,sizeof(*A),compar);
+  RDTSC(y);
+  printf("qsort took %lu cycles.\n",y-x);
+  {
+    unsigned int i;
+    for (i=0; i+1<n; ++i) {
+      if (compar(&A[i],&A[i+1])>0) {
+	printf(" -> not sorted!\n");
+	return 1;
+      }
+    }
+  }
+  return 0;
+}
diff --git a/x86_64/Makefile.add b/x86_64/Makefile.add
index 7d60185..71c6dcd 100644
--- a/x86_64/Makefile.add
+++ b/x86_64/Makefile.add
@@ -1,2 +1,3 @@
 CFLAGS := -Os -fstrict-aliasing -momit-leaf-frame-pointer -mfancy-math-387
 VPATH  := x86_64:syscalls.s:$(VPATH)
+LIBOBJ += $(OBJDIR)/arch_prctl.o
diff --git a/x86_64/arch_prctl.S b/x86_64/arch_prctl.S
new file mode 100644
index 0000000..6a841f2
--- /dev/null
+++ b/x86_64/arch_prctl.S
@@ -0,0 +1,3 @@
+#include "syscalls.h"
+
+syscall(arch_prctl,arch_prctl)
diff --git a/x86_64/dyn_syscalls.S b/x86_64/dyn_syscalls.S
index 4d97f19..282bae2 100644
--- a/x86_64/dyn_syscalls.S
+++ b/x86_64/dyn_syscalls.S
@@ -297,3 +297,5 @@ _unified_syscall:
 
 #define __errno_location __errno_location@PLT
 #include "x86_64/gettimeofday.S"
+
+#include "syscalls.s/__guard.S"
diff --git a/x86_64/getpriority.S b/x86_64/getpriority.S
new file mode 100644
index 0000000..9e56365
--- /dev/null
+++ b/x86_64/getpriority.S
@@ -0,0 +1,12 @@
+#include "syscalls.h"
+
+.text
+.global getpriority
+.type   getpriority,@function
+getpriority:
+     mov     $__NR_getpriority,%al
+     xorq    %rsi,%rsi
+     call    __unified_syscall
+     neg     %rax    /* the value is bios by 20 to avoid negative values */
+     add     $20,%rax
+     ret
diff --git a/x86_64/syscalls.h b/x86_64/syscalls.h
index 9247f52..ccee97d 100644
--- a/x86_64/syscalls.h
+++ b/x86_64/syscalls.h
@@ -301,6 +301,30 @@
 #define __NR_inotify_init	253
 #define __NR_inotify_add_watch	254
 #define __NR_inotify_rm_watch	255
+#define __NR_migrate_pages	256
+#define __NR_openat		257
+#define __NR_mkdirat		258
+#define __NR_mknodat		259
+#define __NR_fchownat		260
+#define __NR_futimesat		261
+#define __NR_newfstatat		262
+#define __NR_unlinkat		263
+#define __NR_renameat		264
+#define __NR_linkat		265
+#define __NR_symlinkat		266
+#define __NR_readlinkat		267
+#define __NR_fchmodat		268
+#define __NR_faccessat		269
+#define __NR_pselect6		270
+#define __NR_ppoll		271
+#define __NR_unshare		272
+#define __NR_set_robust_list	273
+#define __NR_get_robust_list	274
+#define __NR_splice		275
+#define __NR_tee		276
+#define __NR_sync_file_range	277
+#define __NR_vmsplice		278
+#define __NR_move_pages		279
 
 #ifdef __PIC__
 #define syscall_weak(name,wsym,sym) \
-- 
1.5.1.3

