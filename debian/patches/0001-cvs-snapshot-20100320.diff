From 63fb375c8d6b92e2780583be556a15da59641c15 Mon Sep 17 00:00:00 2001
From: Gerrit Pape <pape@smarden.org>
Date: Wed, 10 Feb 2010 09:58:52 +0000
Subject: [PATCH 01/13] cvs snapshot 20100320

---
 CHANGES                       |   12 +
 Makefile                      |    8 +
 PORTING                       |    1 +
 README                        |   11 +-
 TODO                          |    2 +
 diet.c                        |    2 +-
 dietfeatures.h                |    7 +-
 i386/memchr.S                 |   76 ++-
 i386/syscalls.h               |   11 +-
 i386/unified.S                |   13 +-
 include/elf.h                 |   60 ++-
 include/fcntl.h               |    7 +
 include/fenv.h                |  303 +++++++++
 include/netinet/in.h          |    4 +
 include/stdlib.h              |    2 +-
 include/sys/personality.h     |   58 +--
 include/sys/ptrace.h          |   55 ++
 include/sys/tls.h             |    8 +
 include/termios.h             |    1 +
 lib/posix_fallocate.c         |    7 +
 lib/stackgap.c                |   63 ++-
 lib/wcrtomb.c                 |   24 +-
 lib/wcsncmp.c                 |    7 +
 lib/wcsrtombs.c               |   38 ++
 lib/wcstombs.c                |    9 +
 libcruft/dnscruft2.c          |   16 +-
 libcruft/res_query.c          |    2 +-
 libpthread/pthread_create.c   |   33 +-
 libpthread/pthread_internal.c |   63 ++-
 libpthread/thread_internal.h  |    4 +-
 libregex/rx.c                 |   27 +-
 librpc/pmap_clnt.c            |    6 +-
 libugly/wmemmove.c            |   12 +
 mips/divdi3.c                 |   32 +-
 mips/longlong.h               | 1459 +++++++++++++++++++++++++++++++++++++++++
 parisc/clone.S                |    2 +-
 ppc64/__longjmp.S             |    4 +
 ppc64/setjmp.S                |    5 +
 syscalls.s/fallocate.S        |    5 +
 t.c                           |    2 +-
 test/regex.c                  |    2 +-
 test/wcsrtombs.c              |   22 +
 x86_64/memchr.S               |   40 ++
 x86_64/strlen.S               |   32 +
 x86_64/strnlen.S              |   20 +
 x86_64/syscalls.h             |   11 +
 46 files changed, 2413 insertions(+), 175 deletions(-)
 create mode 100644 include/fenv.h
 create mode 100644 lib/posix_fallocate.c
 create mode 100644 lib/wcsncmp.c
 create mode 100644 lib/wcsrtombs.c
 create mode 100644 lib/wcstombs.c
 create mode 100644 libugly/wmemmove.c
 create mode 100644 mips/longlong.h
 create mode 100644 syscalls.s/fallocate.S
 create mode 100644 test/wcsrtombs.c
 create mode 100644 x86_64/memchr.S
 create mode 100644 x86_64/strlen.S
 create mode 100644 x86_64/strnlen.S

diff --git a/CHANGES b/CHANGES
index 83fdbad..1c2711e 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,3 +1,15 @@
+0.33:
+  first stab at getting TLS to work in actual threads
+  use fs: to find current thread on x86_64
+  add fallocate, posix_fallocate
+  work around Ubuntu who added -fstack-protector to their gcc, which
+    added stack protector code to the function from the dietlibc startup
+    code that sets up the registers and segments used by the stack
+    protector mechanism.
+  fix sys/personality.h (Mathias Krause)
+  update sys/ptrace.h (Nikola Vladov)
+  fix fork+pthread closing fd 0 (Tim München)
+
 0.32:
   add mbsinit, mbrlen, mbtowc, wctomb, mbrtowc, wcrtomb, wcwidth
   add btowc, wctype, iswctype
diff --git a/Makefile b/Makefile
index adc2779..ddfd34b 100644
--- a/Makefile
+++ b/Makefile
@@ -155,6 +155,8 @@ $(OBJDIR) $(PICODIR):
 
 % :: %,v
 
+$(OBJDIR)/%.o: $(OBJDIR)
+
 ifeq ($(CC),tcc)
 $(OBJDIR)/%.o: %.S $(ARCH)/syscalls.h
 	$(CROSS)cpp $(INC) $< | $(CROSS)as -o $@
@@ -282,6 +284,9 @@ $(PICODIR)/libdl.so: libdl/_dl_main.c dietfeatures.h
 	$(LD_UNSET) $(CROSS)$(CC) -D__OD_CLEAN_ROOM -DNODIETREF -fPIC -nostdlib -shared -Bsymbolic -Wl,-Bsymbolic \
 		-o $@ $(SAFE_CFLAGS) $(INC) libdl/_dl_main.c -Wl,-soname=libdl.so
 
+$(OBJDIR)/pthread_create.o $(PICODIR)/pthread_create.o: dietfeatures.h
+$(OBJDIR)/pthread_internal.o $(PICODIR)/pthread_internal.o: dietfeatures.h
+
 #$(PICODIR)/libdl.so: $(DYN_LIBDL_OBJS) dietfeatures.h
 #	$(CROSS)$(CC) -nostdlib -shared -o $@ $(CFLAGS) -fPIC $(DYN_LIBDL_OBJS) -L$(PICODIR) -ldietc -Wl,-soname=libdl.so
 
@@ -519,7 +524,10 @@ $(LIBPTHREAD_OBJS): include/pthread.h
 $(OBJDIR)/fcntl64.o: dietfeatures.h
 
 # WANT_SSP
+# This facepalm brought to you by: Ubuntu!
 $(OBJDIR)/stackgap.o: dietfeatures.h
+	$(CROSS)$(CC) $(INC) $(CFLAGS) -c lib/stackgap.c -o $@ -D__dietlibc__ -fno-stack-protector
+	$(COMMENT) -$(CROSS)strip -x -R .comment -R .note $@
 
 # WANT_MALLOC_ZERO
 $(OBJDIR)/strndup.o: dietfeatures.h
diff --git a/PORTING b/PORTING
index 4e2a635..4c008a7 100644
--- a/PORTING
+++ b/PORTING
@@ -24,5 +24,6 @@ To port the diet libc to a new architecture, you need to:
   - edit diet.c to make it recognize the architecture and add proper
     CFLAGS
   - edit libcompat/syscall.S
+  - edit include/fenv.h
 
 (I may have missed a few)
diff --git a/README b/README
index 2a1fa33..5c29f8a 100644
--- a/README
+++ b/README
@@ -37,13 +37,10 @@ appropriate location, too:
 	# cp diet.1 /usr/local/man/man1
 
 After you compiled the diet libc successfully, I invite you to check out
-the embedded utils (http://www.fefe.de/embutils/) and the diet libc
-binary repository (ftp://foobar.math.fu-berlin.de/pub/dietlibc/), too.
-The embedded utils are small replacements for common utilities like mv,
-chown, ls, and even a small tar that can extract tar files.  The binary
-repository contains a few utilities I linked against the diet libc, for
-example gzip, bzip2 and fdisk.
+the embedded utils (http://www.fefe.de/embutils/).  The embedded utils
+are small replacements for common utilities like mv, chown, ls, and even
+a small tar that can extract tar files.
 
 
 The license for the diet libc is the GNU General Public License, version
-2 (as included in the file COPYING).
+2 (as included in the file COPYING) or later.
diff --git a/TODO b/TODO
index 8002a84..6988144 100644
--- a/TODO
+++ b/TODO
@@ -33,3 +33,5 @@ set_thread_area -> set up TLD, for stack guard
 
 lsearch, lfind, hsearch, tsearch
 
+add option to detect valgrind (strstr for "valgrind" in getenv("LD_PRELOAD")),
+  then set a flag and disable optimizations that trigger warnings
diff --git a/diet.c b/diet.c
index 3677b4c..e7fd3e8 100644
--- a/diet.c
+++ b/diet.c
@@ -136,7 +136,7 @@ int main(int argc,char *argv[]) {
     char *tmp=strchr(cc,0)-2;
     char *tmp2,*tmp3;
     if (tmp<cc) goto donttouch;
-    if (!strstr(cc,"cc")) goto donttouch;
+    if (!strstr(cc,"cc") && !strstr(cc,"clang")) goto donttouch;
     if ((tmp2=strstr(cc,"linux-"))) {	/* cross compiling? */
       int len=strlen(platform);
       --tmp2;
diff --git a/dietfeatures.h b/dietfeatures.h
index 7ba02ec..63e388c 100644
--- a/dietfeatures.h
+++ b/dietfeatures.h
@@ -22,10 +22,10 @@
 /* this is only for meaningful for ttyname and sysconf_cpus so far */
 #define SLASH_PROC_OK
 
-/* use errno_location instead of errno */
+/* use errno_location instead of errno; NEEDED FOR MULTI-THREADING! */
 #define WANT_THREAD_SAFE
 
-/* support __thread */
+/* support __thread; NEEDED FOR MULTI-THREADING! */
 #define WANT_TLS
 
 /* make the startcode, etc. dynamic aware ({con,de}structors) */
@@ -115,6 +115,9 @@
 /* ProPolice is part of gcc 4.1 and up, there were patches for earlier
  * versions.  To make use of this, compile your application with
  * -fstack-protector. */
+/* If you compile dietlibc without WANT_SSP and then try to link code
+ * compiled with -fstack-protector against it, the binary will segfault
+ * when calling that code. */
 #if (__GNUC__>4) || ((__GNUC__==4) && (__GNUC_MINOR__>=1))
 #define WANT_SSP
 #endif
diff --git a/i386/memchr.S b/i386/memchr.S
index 7d04f99..0d7bef0 100644
--- a/i386/memchr.S
+++ b/i386/memchr.S
@@ -1,24 +1,68 @@
 .text
-.align 0
 .global memchr
-.type	 memchr,@function
+.type memchr,@function
 memchr:
-	pushl %edi
-	movl 8(%esp),%edi
-	movl 12(%esp),%eax
-	movl 16(%esp),%ecx
-	cld
-	jecxz .Lnotfound
+	push %edi
+	mov 8(%esp),%edi	/* edi = ptr */
+	movzxb 12(%esp),%eax
+	mov 16(%esp),%ecx
+	imul $0x01010101,%eax	/* eax = simd vector, 8 x ch */
+	push %esi
+	push %ebx
+	jecxz .Lnull
+	add %edi,%ecx		/* ecx == max ptr */
 
-	repne scasb
+1:	/* compare byte-wise until alignment */
+	test $3,%edi
+	jz 1f
+	cmp %al,(%edi)
+	jz .Lfound
+	inc %edi
+	jmp 1b
+
+1:	/* compare word-wise */
+	cmp %edi,%ecx
+	jb .Lnull
+	mov (%edi),%edx
+	xor %eax,%edx		/* in the input vector, change the byte we want to 0 */
+	mov %edx,%ebx
+	sub $0x01010101,%ebx
+	not %edx
+	and %ebx,%edx
+	shr $7,%edx
+	and $0x01010101,%edx	/* this sequence did !! to every byte in edx */
+	jnz 1f
+	add $4,%edi
+	jmp 1b
+
+1:	/* there is a nonzero byte in %edx, try lower half */
+	test %dx,%dx
+	jnz 1f
+	/* not in lower half, swap halves */
+	shr $16,%edx
+	add $2,%edi
+1:
+	test %dl,%dl
+	jnz 1f
+	/* no match in lower byte */
+	mov %dh,%dl
+	inc %edi
+1:
 
-	je .Lfound
-.Lnotfound:
-	xorl %edi, %edi
-	incl %edi
 .Lfound:
-	movl %edi, %eax
-	decl %eax
+	cmp %edi,%ecx
+	jb .Lnull
+	mov %edi,%eax
+	pop %ebx
+	pop %esi
+	pop %edi
+	ret
 
-	popl %edi
+.Lnull:
+	xor %eax,%eax
+	pop %ebx
+	pop %esi
+	pop %edi
 	ret
+.Lhere:
+.size memchr,.Lhere-memchr
diff --git a/i386/syscalls.h b/i386/syscalls.h
index 328f8c8..09edb12 100644
--- a/i386/syscalls.h
+++ b/i386/syscalls.h
@@ -325,7 +325,16 @@
 #define __NR_fallocate		324
 #define __NR_timerfd_settime	325
 #define __NR_timerfd_gettime	326
-
+#define __NR_signalfd4		327
+#define __NR_eventfd2		328
+#define __NR_epoll_create1	329
+#define __NR_dup3		330
+#define __NR_pipe2		331
+#define __NR_inotify_init1	332
+#define __NR_preadv		333
+#define __NR_pwritev		334
+#define __NR_rt_tgsigqueueinfo	335
+#define __NR_perf_event_open	336
 
 #define syscall_weak(name,wsym,sym) \
 .text; \
diff --git a/i386/unified.S b/i386/unified.S
index 0a26647..0a8aec4 100644
--- a/i386/unified.S
+++ b/i386/unified.S
@@ -33,15 +33,17 @@ __unified_syscall:
 	push	%edi
 	push	%esi
 	push	%ebx
+	push	%ebp
 	movl	%esp,%edi
 	/* we use movl instead of pop because otherwise a signal would
 	   destroy the stack frame and crash the program, although it
 	   would save a few bytes. */
-	movl	0x10(%edi),%ebx
-	movl	0x14(%edi),%ecx
-	movl	0x18(%edi),%edx
-	movl	0x1c(%edi),%esi
-	movl	0x20(%edi),%edi
+	movl	5*4(%edi),%ebx
+	movl	6*4(%edi),%ecx
+	movl	7*4(%edi),%edx
+	movl	8*4(%edi),%esi
+	movl	10*4(%edi),%ebp
+	movl	9*4(%edi),%edi
 #ifdef WANT_SYSENTER
 	call	*.Lvsyscall /* 0xffffe000 */
 #else
@@ -60,6 +62,7 @@ __unified_syscall:
 	sbb	%eax,%eax               # eax = eax - eax - CY = -1
 #endif
 .Lnoerror:
+	pop	%ebp
 	pop	%ebx
 	pop	%esi
 	pop	%edi
diff --git a/include/elf.h b/include/elf.h
index 6bfd3d6..5197548 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -527,25 +527,47 @@ typedef struct
 
 /* Legal values for p_type (segment type).  */
 
-#define	PT_NULL		0		/* Program header table entry unused */
-#define PT_LOAD		1		/* Loadable program segment */
-#define PT_DYNAMIC	2		/* Dynamic linking information */
-#define PT_INTERP	3		/* Program interpreter */
-#define PT_NOTE		4		/* Auxiliary information */
-#define PT_SHLIB	5		/* Reserved */
-#define PT_PHDR		6		/* Entry for header table itself */
-#define PT_TLS		7		/* Thread-local storage segment */
-#define	PT_NUM		8		/* Number of defined types */
-#define PT_LOOS		0x60000000	/* Start of OS-specific */
-#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
-#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
-#define PT_LOSUNW	0x6ffffffa
-#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
-#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
-#define PT_HISUNW	0x6fffffff
-#define PT_HIOS		0x6fffffff	/* End of OS-specific */
-#define PT_LOPROC	0x70000000	/* Start of processor-specific */
-#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
+enum {
+  PT_NULL = 0,			/* Program header table entry unused */
+  PT_LOAD = 1,			/* Loadable program segment */
+  PT_DYNAMIC = 2,		/* Dynamic linking information */
+  PT_INTERP = 3,		/* Program interpreter */
+  PT_NOTE = 4,			/* Auxiliary information */
+  PT_SHLIB = 5,			/* Reserved */
+  PT_PHDR = 6,			/* Entry for header table itself */
+  PT_TLS = 7,			/* Thread-local storage segment */
+  PT_NUM = 8,			/* Number of defined types */
+  PT_LOOS = 0x60000000,		/* Start of OS-specific */
+  PT_GNU_EH_FRAME = 0x6474e550,	/* GCC .eh_frame_hdr segment */
+  PT_GNU_STACK = 0x6474e551,	/* Indicates stack executability */
+  PT_LOSUNW = 0x6ffffffa,
+  PT_SUNWBSS = 0x6ffffffa,	/* Sun Specific segment */
+  PT_SUNWSTACK = 0x6ffffffb,	/* Stack segment */
+  PT_HISUNW = 0x6fffffff,
+  PT_HIOS = 0x6fffffff,		/* End of OS-specific */
+  PT_LOPROC = 0x70000000,	/* Start of processor-specific */
+  PT_HIPROC = 0x7fffffff	/* End of processor-specific */
+};
+
+#define PT_NULL PT_NULL
+#define PT_LOAD PT_LOAD
+#define PT_DYNAMIC PT_DYNAMIC
+#define PT_INTERP PT_INTERP
+#define PT_NOTE PT_NOTE
+#define PT_SHLIB PT_SHLIB
+#define PT_PHDR PT_PHDR
+#define PT_TLS PT_TLS
+#define PT_NUM PT_NUM
+#define PT_LOOS PT_LOOS
+#define PT_GNU_EH_FRAME PT_GNU_EH_FRAME
+#define PT_GNU_STACK PT_GNU_STACK
+#define PT_LOSUNW PT_LOSUNW
+#define PT_SUNWBSS PT_SUNWBSS
+#define PT_SUNWSTACK PT_SUNWSTACK
+#define PT_HISUNW PT_HISUNW
+#define PT_HIOS PT_HIOS
+#define PT_LOPROC PT_LOPROC
+#define PT_HIPROC PT_HIPROC
 
 /* Legal values for p_flags (segment flags).  */
 
diff --git a/include/fcntl.h b/include/fcntl.h
index dd0ee36..510826c 100644
--- a/include/fcntl.h
+++ b/include/fcntl.h
@@ -643,6 +643,10 @@ long vmsplice(int fd, const struct iovec *iov, unsigned long nr_segs, unsigned i
 long splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags) __THROW;
 
 int sync_file_range(int fd, off64_t offset, off64_t nbytes, unsigned int flags) __THROW;
+
+#define FALLOC_FL_KEEP_SIZE 1
+
+int fallocate(int fd, int mode, loff_t offset, loff_t len) __THROW;
 #endif
 
 #ifdef _ATFILE_SOURCE
@@ -668,6 +672,9 @@ int mkfifoat(int dirfd, const char *pathname, mode_t mode);
 int utimensat(int dirfd, const char *pathname, struct timespec* t);
 #endif
 
+#if defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE - 0) >= 600
+int posix_fallocate(int fd, off64_t offset, off64_t len) __THROW;
+#endif
 
 __END_DECLS
 
diff --git a/include/fenv.h b/include/fenv.h
new file mode 100644
index 0000000..6c66553
--- /dev/null
+++ b/include/fenv.h
@@ -0,0 +1,303 @@
+#ifndef _FENV_H
+#define _FENV_H
+
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+
+#if defined(__i386__)
+
+enum
+  {
+    FE_INVALID = 0x01,
+#define FE_INVALID      FE_INVALID
+    __FE_DENORM = 0x02,
+    FE_DIVBYZERO = 0x04,
+#define FE_DIVBYZERO    FE_DIVBYZERO
+    FE_OVERFLOW = 0x08,
+#define FE_OVERFLOW     FE_OVERFLOW
+    FE_UNDERFLOW = 0x10,
+#define FE_UNDERFLOW    FE_UNDERFLOW
+    FE_INEXACT = 0x20
+#define FE_INEXACT      FE_INEXACT
+  };
+
+#define FE_ALL_EXCEPT \
+        (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {
+    FE_TONEAREST = 0,
+#define FE_TONEAREST    FE_TONEAREST
+    FE_DOWNWARD = 0x400,
+#define FE_DOWNWARD     FE_DOWNWARD
+    FE_UPWARD = 0x800,
+#define FE_UPWARD       FE_UPWARD
+    FE_TOWARDZERO = 0xc00
+#define FE_TOWARDZERO   FE_TOWARDZERO
+  };
+
+#define FE_DFL_ENV      ((__const fenv_t *) -1)
+
+/* Type representing exception flags.  */
+typedef unsigned short int fexcept_t;
+
+/* Type representing floating-point environment.  This function corresponds
+   to the layout of the block written by the `fstenv'.  */
+typedef struct {
+  unsigned short int __control_word;
+  unsigned short int __unused1;
+  unsigned short int __status_word;
+  unsigned short int __unused2;
+  unsigned short int __tags;
+  unsigned short int __unused3;
+  unsigned int __eip;
+  unsigned short int __cs_selector;
+  unsigned int __opcode:11;
+  unsigned int __unused4:5;
+  unsigned int __data_offset;
+  unsigned short int __data_selector;
+  unsigned short int __unused5;
+} fenv_t;
+
+#elif defined(__ia64__)
+
+enum
+  {
+    FE_INEXACT =        1UL << 5,
+#define FE_INEXACT      FE_INEXACT
+
+    FE_UNDERFLOW =      1UL << 4,
+#define FE_UNDERFLOW    FE_UNDERFLOW
+
+    FE_OVERFLOW =       1UL << 3,
+#define FE_OVERFLOW     FE_OVERFLOW
+
+    FE_DIVBYZERO =      1UL << 2,
+#define FE_DIVBYZERO    FE_DIVBYZERO
+
+    FE_UNNORMAL =       1UL << 1,
+#define FE_UNNORMAL     FE_UNNORMAL
+
+    FE_INVALID =        1UL << 0,
+#define FE_INVALID      FE_INVALID
+
+    FE_ALL_EXCEPT =
+        (FE_INEXACT | FE_UNDERFLOW | FE_OVERFLOW | FE_DIVBYZERO | FE_UNNORMAL | FE_INVALID)
+#define FE_ALL_EXCEPT   FE_ALL_EXCEPT
+  };
+
+enum
+  {
+    FE_TOWARDZERO =     3,
+#define FE_TOWARDZERO   FE_TOWARDZERO
+
+    FE_UPWARD =         2,
+#define FE_UPWARD       FE_UPWARD
+
+    FE_DOWNWARD =       1,
+#define FE_DOWNWARD     FE_DOWNWARD
+
+    FE_TONEAREST =      0,
+#define FE_TONEAREST    FE_TONEAREST
+  };
+
+#define FE_DFL_ENV      ((__const fenv_t *) 0xc009804c0270033fUL)
+
+typedef unsigned long int fexcept_t;
+typedef unsigned long int fenv_t;
+
+#elif defined(__powerpc__)
+
+enum
+  {
+    FE_INEXACT = 1 << (31 - 6),
+#define FE_INEXACT      FE_INEXACT
+    FE_DIVBYZERO = 1 << (31 - 5),
+#define FE_DIVBYZERO    FE_DIVBYZERO
+    FE_UNDERFLOW = 1 << (31 - 4),
+#define FE_UNDERFLOW    FE_UNDERFLOW
+    FE_OVERFLOW = 1 << (31 - 3),
+#define FE_OVERFLOW     FE_OVERFLOW
+
+    /* ... except for FE_INVALID, for which we use bit 31. FE_INVALID
+       actually corresponds to bits 7 through 12 and 21 through 23
+       in the FPSCR, but we can't use that because the current draft
+       says that it must be a power of 2.  Instead we use bit 2 which
+       is the summary bit for all the FE_INVALID exceptions, which
+       kind of makes sense.  */
+    FE_INVALID = 1 << (31 - 2),
+#define FE_INVALID      FE_INVALID
+  };
+
+#define FE_ALL_EXCEPT \
+        (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {
+    FE_TONEAREST = 0,
+#define FE_TONEAREST    FE_TONEAREST
+    FE_TOWARDZERO = 1,
+#define FE_TOWARDZERO   FE_TOWARDZERO
+    FE_UPWARD = 2,
+#define FE_UPWARD       FE_UPWARD
+    FE_DOWNWARD = 3
+#define FE_DOWNWARD     FE_DOWNWARD
+  };
+
+typedef unsigned int fexcept_t;
+typedef double fenv_t;
+extern const fenv_t __fe_dfl_env;
+#define FE_DFL_ENV      (&__fe_dfl_env)
+
+#elif defined(__s390__)
+
+enum
+  {
+    FE_INVALID = 0x80,
+#define FE_INVALID      FE_INVALID
+    FE_DIVBYZERO = 0x40,
+#define FE_DIVBYZERO    FE_DIVBYZERO
+    FE_OVERFLOW = 0x20,
+#define FE_OVERFLOW     FE_OVERFLOW
+    FE_UNDERFLOW = 0x10,
+#define FE_UNDERFLOW    FE_UNDERFLOW
+    FE_INEXACT = 0x08
+#define FE_INEXACT      FE_INEXACT
+  };
+
+#define FE_ALL_EXCEPT \
+        (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {
+    FE_TONEAREST = 0,
+#define FE_TONEAREST    FE_TONEAREST
+    FE_DOWNWARD = 0x3,
+#define FE_DOWNWARD     FE_DOWNWARD
+    FE_UPWARD = 0x2,
+#define FE_UPWARD       FE_UPWARD
+    FE_TOWARDZERO = 0x1
+#define FE_TOWARDZERO   FE_TOWARDZERO
+  };
+
+#define FE_DFL_ENV      ((__const fenv_t *) -1)
+
+typedef unsigned int fexcept_t; /* size of fpc */
+typedef struct
+{
+  fexcept_t fpc;
+  void *ieee_instruction_pointer;
+  /* failing instruction for ieee exceptions */
+} fenv_t;
+
+#elif defined(__sparc__)
+
+enum
+  {    
+    FE_INVALID =        (1 << 9),
+#define FE_INVALID      FE_INVALID
+    FE_OVERFLOW =       (1 << 8),
+#define FE_OVERFLOW     FE_OVERFLOW
+    FE_UNDERFLOW =      (1 << 7),
+#define FE_UNDERFLOW    FE_UNDERFLOW
+    FE_DIVBYZERO =      (1 << 6),
+#define FE_DIVBYZERO    FE_DIVBYZERO
+    FE_INEXACT =        (1 << 5)
+#define FE_INEXACT      FE_INEXACT
+  };
+
+#define FE_ALL_EXCEPT \
+        (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {      
+    FE_TONEAREST =      (0U << 30),
+#define FE_TONEAREST    FE_TONEAREST
+    FE_TOWARDZERO =     (1U << 30),
+#define FE_TOWARDZERO   FE_TOWARDZERO
+    FE_UPWARD =         (2U << 30),
+#define FE_UPWARD       FE_UPWARD
+    FE_DOWNWARD =       (3U << 30)
+#define FE_DOWNWARD     FE_DOWNWARD
+  };
+
+#define __FE_ROUND_MASK (3U << 30)
+#define FE_DFL_ENV      ((__const fenv_t *) -1)
+
+typedef unsigned long int fexcept_t;
+typedef unsigned long int fenv_t;
+
+#elif defined(__x86_64__)
+
+enum
+  {    
+    FE_INVALID = 0x01,  
+#define FE_INVALID      FE_INVALID
+    __FE_DENORM = 0x02,
+    FE_DIVBYZERO = 0x04,
+#define FE_DIVBYZERO    FE_DIVBYZERO
+    FE_OVERFLOW = 0x08,
+#define FE_OVERFLOW     FE_OVERFLOW
+    FE_UNDERFLOW = 0x10,
+#define FE_UNDERFLOW    FE_UNDERFLOW
+    FE_INEXACT = 0x20
+#define FE_INEXACT      FE_INEXACT
+  };
+
+#define FE_ALL_EXCEPT \
+        (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  { 
+    FE_TONEAREST = 0,
+#define FE_TONEAREST    FE_TONEAREST
+    FE_DOWNWARD = 0x400,
+#define FE_DOWNWARD     FE_DOWNWARD
+    FE_UPWARD = 0x800,
+#define FE_UPWARD       FE_UPWARD
+    FE_TOWARDZERO = 0xc00
+#define FE_TOWARDZERO   FE_TOWARDZERO
+  };
+
+#define FE_DFL_ENV      ((__const fenv_t *) -1)
+
+typedef unsigned short int fexcept_t;
+
+typedef struct {
+  unsigned short int __control_word;
+  unsigned short int __unused1;
+  unsigned short int __status_word;
+  unsigned short int __unused2;
+  unsigned short int __tags;
+  unsigned short int __unused3;
+  unsigned int __eip;
+  unsigned short int __cs_selector;
+  unsigned int __opcode:11;
+  unsigned int __unused4:5;
+  unsigned int __data_offset;
+  unsigned short int __data_selector;
+  unsigned short int __unused5;
+  unsigned int __mxcsr;
+} fenv_t;
+
+#else
+
+#error unsupported platform, edit include/fenv.h
+#endif
+
+int  feclearexcept(int);
+int  fegetexceptflag(fexcept_t *, int);
+int  feraiseexcept(int);
+int  fesetexceptflag(const fexcept_t *, int);
+int  fetestexcept(int);
+int  fegetround(void);
+int  fesetround(int);
+int  fegetenv(fenv_t *);
+int  feholdexcept(fenv_t *);
+int  fesetenv(const fenv_t *);
+int  feupdateenv(const fenv_t *);
+
+__END_DECLS
+
+#endif
diff --git a/include/netinet/in.h b/include/netinet/in.h
index ff07ccd..7daa24b 100644
--- a/include/netinet/in.h
+++ b/include/netinet/in.h
@@ -41,6 +41,10 @@ enum {
 #define IPPROTO_AH IPPROTO_AH
   IPPROTO_COMP   = 108,                /* Compression Header protocol */
 #define IPPROTO_COMP IPPROTO_COMP
+    IPPROTO_SCTP = 132,	   /* Stream Control Transmission Protocol.  */
+#define IPPROTO_SCTP		IPPROTO_SCTP
+    IPPROTO_UDPLITE = 136, /* UDP-Lite protocol.  */
+#define IPPROTO_UDPLITE		IPPROTO_UDPLITE
   IPPROTO_RAW	 = 255,		/* Raw IP packets			*/
 #define IPPROTO_RAW IPPROTO_RAW
   IPPROTO_MAX
diff --git a/include/stdlib.h b/include/stdlib.h
index d1e1569..a7d2573 100644
--- a/include/stdlib.h
+++ b/include/stdlib.h
@@ -93,7 +93,7 @@ char *ptsname (int fd) __THROW;
 
 #define RAND_MAX 	0x7ffffffe
 
-#define MB_CUR_MAX 1
+#define MB_CUR_MAX 5
 
 /* now these functions are the greatest bullshit I have ever seen.
  * The ISO people must be out of their minds. */
diff --git a/include/sys/personality.h b/include/sys/personality.h
index b6103ff..5106b75 100644
--- a/include/sys/personality.h
+++ b/include/sys/personality.h
@@ -1,16 +1,7 @@
 #ifndef _PERSONALITY_H
 #define _PERSONALITY_H
 
-/*
- * Handling of different ABIs (personalities).
- */
-
-struct exec_domain;
-struct pt_regs;
-
-extern int		register_exec_domain(struct exec_domain *);
-extern int		unregister_exec_domain(struct exec_domain *);
-extern int		__set_personality(unsigned long);
+#include <sys/cdefs.h>
 
 /*
  * Flags for bug emulation.
@@ -33,12 +24,6 @@ enum {
 };
 
 /*
- * Security-relevant compatibility flags that must be
- * cleared upon setuid or setgid exec:
- */
-#define PER_CLEAR_ON_SETID (READ_IMPLIES_EXEC|ADDR_NO_RANDOMIZE)
-
-/*
  * Personality types.
  *
  * These go in the low byte.  Avoid using the top bit, it will
@@ -71,44 +56,11 @@ enum {
 	PER_MASK =		0x00ff,
 };
 
+__BEGIN_DECLS
 
-/*
- * Description of an execution domain.
- * 
- * The first two members are refernced from assembly source
- * and should stay where they are unless explicitly needed.
- */
-typedef void (*handler_t)(int, struct pt_regs *);
+/* Set different ABIs (personalities).  */
+extern int personality (unsigned long int __persona) __THROW;
 
-struct exec_domain {
-	const char		*name;		/* name of the execdomain */
-	handler_t		handler;	/* handler for syscalls */
-	unsigned char		pers_low;	/* lowest personality */
-	unsigned char		pers_high;	/* highest personality */
-	unsigned long		*signal_map;	/* signal mapping */
-	unsigned long		*signal_invmap;	/* reverse signal mapping */
-	struct map_segment	*err_map;	/* error mapping */
-	struct map_segment	*socktype_map;	/* socket type mapping */
-	struct map_segment	*sockopt_map;	/* socket option mapping */
-	struct map_segment	*af_map;	/* address family mapping */
-	struct module		*module;	/* module context of the ed. */
-	struct exec_domain	*next;		/* linked list (internal) */
-};
-
-/*
- * Return the base personality without flags.
- */
-#define personality(pers)	(pers & PER_MASK)
-
-/*
- * Personality of the currently running process.
- */
-#define get_personality		(current->personality)
-
-/*
- * Change personality of the currently running process.
- */
-#define set_personality(pers) \
-	((current->personality == pers) ? 0 : __set_personality(pers))
+__END_DECLS
 
 #endif /* _PERSONALITY_H */
diff --git a/include/sys/ptrace.h b/include/sys/ptrace.h
index d339fd0..91adddc 100644
--- a/include/sys/ptrace.h
+++ b/include/sys/ptrace.h
@@ -24,6 +24,31 @@ __BEGIN_DECLS
 
 #define PTRACE_SYSCALL		  24
 
+/* 0x4200-0x4300 are reserved for architecture-independent additions.  */
+#define PTRACE_SETOPTIONS	0x4200
+#define PTRACE_GETEVENTMSG	0x4201
+#define PTRACE_GETSIGINFO	0x4202
+#define PTRACE_SETSIGINFO	0x4203
+
+/* options set using PTRACE_SETOPTIONS */
+#define PTRACE_O_TRACESYSGOOD	0x00000001
+#define PTRACE_O_TRACEFORK	0x00000002
+#define PTRACE_O_TRACEVFORK	0x00000004
+#define PTRACE_O_TRACECLONE	0x00000008
+#define PTRACE_O_TRACEEXEC	0x00000010
+#define PTRACE_O_TRACEVFORKDONE	0x00000020
+#define PTRACE_O_TRACEEXIT	0x00000040
+
+#define PTRACE_O_MASK		0x0000007f
+
+/* Wait extended result codes for the above trace options.  */
+#define PTRACE_EVENT_FORK	1
+#define PTRACE_EVENT_VFORK	2
+#define PTRACE_EVENT_CLONE	3
+#define PTRACE_EVENT_EXEC	4
+#define PTRACE_EVENT_VFORK_DONE	5
+#define PTRACE_EVENT_EXIT	6
+
 #define PT_TRACE_ME		PTRACE_TRACEME
 #define PT_READ_I		PTRACE_PEEKTEXT
 #define PT_READ_D		PTRACE_PEEKDATA
@@ -95,6 +120,36 @@ struct pt_regs {
 /* options set using PTRACE_SETOPTIONS */
 #define PTRACE_O_TRACESYSGOOD     0x00000001
 
+#elif defined(__x86_64__)
+
+struct pt_regs {
+	unsigned long r15;
+	unsigned long r14;
+	unsigned long r13;
+	unsigned long r12;
+	unsigned long rbp;
+	unsigned long rbx;
+/* arguments: non interrupts/non tracing syscalls only save upto here*/
+	unsigned long r11;
+	unsigned long r10;
+	unsigned long r9;
+	unsigned long r8;
+	unsigned long rax;
+	unsigned long rcx;
+	unsigned long rdx;
+	unsigned long rsi;
+	unsigned long rdi;
+	unsigned long orig_rax;
+/* end of arguments */
+/* cpu exception frame or undefined */
+	unsigned long rip;
+	unsigned long cs;
+	unsigned long eflags;
+	unsigned long rsp;
+	unsigned long ss;
+/* top of stack page */
+};
+
 #elif defined(__s390__)
 
 #define PT_PSWMASK  0x00
diff --git a/include/sys/tls.h b/include/sys/tls.h
index d4bd9f6..7db014c 100644
--- a/include/sys/tls.h
+++ b/include/sys/tls.h
@@ -23,11 +23,19 @@ typedef struct
   dtv_t *dtv;
   void *self;           /* Pointer to the thread descriptor.  */
   int multiple_threads;
+#ifdef __x86_64__
+  int gscope_flag;
+#endif
   uintptr_t sysinfo;
   uintptr_t stack_guard;
   uintptr_t pointer_guard;
+#ifdef __i386__
+  int gscope_flag;
+#endif
 } tcbhead_t;
 
+tcbhead_t* __get_cur_tcb(void) __THROW;
+
 #if defined(__i386__)
 
 struct user_desc {
diff --git a/include/termios.h b/include/termios.h
index 3f18d45..6cb3d43 100644
--- a/include/termios.h
+++ b/include/termios.h
@@ -239,6 +239,7 @@ struct termios {
 #define IXANY	0004000
 #define IXOFF	0010000
 #define IMAXBEL	0020000
+#define IUTF8	0040000
 
 /* c_oflag bits */
 #define OPOST	0000001
diff --git a/lib/posix_fallocate.c b/lib/posix_fallocate.c
new file mode 100644
index 0000000..ef9f985
--- /dev/null
+++ b/lib/posix_fallocate.c
@@ -0,0 +1,7 @@
+#define _GNU_SOURCE
+#define _XOPEN_SOURCE 600
+#include <fcntl.h>
+
+int posix_fallocate(int fd, off64_t offset, off64_t len) {
+  return fallocate(fd,0,offset,len);
+}
diff --git a/lib/stackgap.c b/lib/stackgap.c
index e974e2c..0e22dc0 100644
--- a/lib/stackgap.c
+++ b/lib/stackgap.c
@@ -1,3 +1,12 @@
+/* Warning: this code sets up the machine registers and segments needed
+ * for -fstack-protector to work.  If you compile this function with
+ * -fstack-protector, it will reference those registers before they are
+ * set up properly, causing a segmentation fault.  Ubuntu adds
+ * -fstack-protector to their gcc default options, so this breaks.  I
+ * added a workaround to the Makefile to make sure this code is always
+ * compiled with -fno-stack-protector for this reason.  Or, as a friend
+ * put it: yo dawg. I herd u liek stack protektion. :-)
+ */
 #include <unistd.h>
 #include <fcntl.h>
 #include <alloca.h>
@@ -13,6 +22,10 @@ extern int main(int argc,char* argv[],char* envp[]);
 extern unsigned long __guard;
 #endif
 
+#ifdef __i386__
+int __modern_linux;
+#endif
+
 #ifdef WANT_TLS
 /* __tdatasize is the size of the initialized thread local data section
  * __tmemsize is the size of the complete thread local data section
@@ -29,19 +42,19 @@ static void findtlsdata(long* auxvec) {
 #else
   Elf32_Phdr* x=0;
 #endif
-  size_t i,n;
+  size_t i,n=0;
   while (*auxvec) {
-    if (auxvec[0]==3) {
+    if (auxvec[0]==3) {	/* AT_PHDR */
       x=(void*)auxvec[1];
-      break;
+      if (n) break;
+    } else if (auxvec[0]==5) { /* AT_PHNUM */
+      n=auxvec[1];
+      if (x) break;
     }
     auxvec+=2;
   } /* if we don't find the entry, the kernel let us down */
-  if (!x) return;	/* a kernel this old does not support thread local storage anyway */
-  if (x->p_type!=PT_PHDR) return;	/* should start with PT_PHDR */
-  /* if it doesn't, assume there is no thread local storage */
-  n=x->p_memsz/sizeof(*x);
-  for (i=1; i<n; ++i)
+  if (!x || !n) return;	/* a kernel this old does not support thread local storage anyway */
+  for (i=0; i<n; ++i)
     if (x[i].p_type==PT_TLS) {
       __tdataptr=(void*)x[i].p_vaddr;
       __tdatasize=x[i].p_filesz;
@@ -54,11 +67,15 @@ static void findtlsdata(long* auxvec) {
 #endif
 
 #if defined(WANT_SSP) || defined(WANT_TLS)
-static tcbhead_t mainthread;
+tcbhead_t* __tcb_mainthread;
+
+void __setup_tls(tcbhead_t*);
 
-static void setup_tls(tcbhead_t* mainthread) {
-  mainthread->tcb=&mainthread;
-  mainthread->self=&mainthread;
+void __setup_tls(tcbhead_t* mainthread) {
+  mainthread->tcb=mainthread;
+  mainthread->dtv=0;
+  mainthread->self=0;
+  mainthread->multiple_threads=0;
 #if defined(WANT_SSP)
   mainthread->stack_guard=__guard;
 #endif
@@ -69,14 +86,17 @@ static void setup_tls(tcbhead_t* mainthread) {
 
 #elif defined(__i386__)
 
-  static unsigned int sd[4];
+  unsigned int sd[4];
   sd[0]=-1;
   sd[1]=(unsigned long int)mainthread;
   sd[2]=0xfffff; /* 4 GB limit */
   sd[3]=0x51; /* bitfield, see struct user_desc in asm-i386/ldt.h */
-  if (set_thread_area((struct user_desc*)(void*)&sd)==0) {
-    asm volatile ("movw %w0, %%gs" :: "q" (sd[0]*8+3));
-  }
+  if (__modern_linux>=0)
+    if (set_thread_area((struct user_desc*)(void*)&sd)==0) {
+      asm volatile ("movw %w0, %%gs" :: "q" (sd[0]*8+3));
+      __modern_linux=1;
+    } else
+      __modern_linux=-1;
 
 #elif defined(__alpha__) || defined(__s390__)
   __builtin_set_thread_pointer(mainthread);
@@ -133,12 +153,19 @@ int stackgap(int argc,char* argv[],char* envp[]) {
 #endif
 #endif
 
-#if defined(WANT_SSP) || defined(WANT_TLS)
+#ifdef WANT_TLS
   findtlsdata(auxvec);
+  if (__unlikely(__tmemsize+sizeof(tcbhead_t)<sizeof(tcbhead_t)) ||
+      __unlikely(__tmemsize>512*1024*1024) ||
+      __unlikely(__tmemsize<__tdatasize))
+    return 111;
   tlsdata=alloca(__tmemsize+sizeof(tcbhead_t));
   memcpy(tlsdata,__tdataptr,__tdatasize);
   memset(tlsdata+__tdatasize,0,__tmemsize-__tdatasize);
-  setup_tls((tcbhead_t*)(tlsdata+__tmemsize));
+  __setup_tls(__tcb_mainthread=(tcbhead_t*)(tlsdata+__tmemsize));
+#elif defined(WANT_SSP)
+  tlsdata=alloca(sizeof(tcbhead_t));
+  __setup_tls(__tcb_mainthread=(tcbhead_t*)(tlsdata));
 #endif
   return main(argc,argv,envp);
 }
diff --git a/lib/wcrtomb.c b/lib/wcrtomb.c
index adf7bfa..4c1c9ac 100644
--- a/lib/wcrtomb.c
+++ b/lib/wcrtomb.c
@@ -13,19 +13,23 @@ size_t wcrtomb(char *s, wchar_t wc, mbstate_t *ps) {
   case CT_UTF8:
     if (!s) return (wc>=0x80);
     {
+      char c;
       unsigned int bits,j,k;
-      if (wc>=0x04000000) { bits=30; *s=0xFC; j=6; } else
-      if (wc>=0x00200000) { bits=24; *s=0xF8; j=5; } else
-      if (wc>=0x00010000) { bits=18; *s=0xF0; j=4; } else
-      if (wc>=0x00000800) { bits=12; *s=0xE0; j=3; } else
-      if (wc>=0x00000080) { bits=6; *s=0xC0; j=2; } else
+      if (wc>=0x04000000) { bits=30; c=0xFC; j=6; } else
+      if (wc>=0x00200000) { bits=24; c=0xF8; j=5; } else
+      if (wc>=0x00010000) { bits=18; c=0xF0; j=4; } else
+      if (wc>=0x00000800) { bits=12; c=0xE0; j=3; } else
+      if (wc>=0x00000080) { bits=6; c=0xC0; j=2; } else
 			{ *s=wc; return 1; }
-      *s |= (unsigned char)(wc>>bits);
-      for (k=1; k<j; ++k) {
-	bits-=6;
-	s[k]=0x80+((wc>>bits)&0x3f);
+      c |= (unsigned char)(wc>>bits);
+      if (s) {
+	*s=c;
+	for (k=1; k<j; ++k) {
+	  bits-=6;
+	  s[k]=0x80+((wc>>bits)&0x3f);
+	}
       }
-      return k;
+      return j;
     }
   }
   return 0;
diff --git a/lib/wcsncmp.c b/lib/wcsncmp.c
new file mode 100644
index 0000000..6f11377
--- /dev/null
+++ b/lib/wcsncmp.c
@@ -0,0 +1,7 @@
+#include <wchar.h>
+
+int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n) {
+  size_t i;
+  for (i=0; i<n && s1[i]==s2[i]; ++i) ;
+  return s1[i]-s2[i];
+}
diff --git a/lib/wcsrtombs.c b/lib/wcsrtombs.c
new file mode 100644
index 0000000..6785799
--- /dev/null
+++ b/lib/wcsrtombs.c
@@ -0,0 +1,38 @@
+#include <stdlib.h>
+#include <wchar.h>
+#include "dietlocale.h"
+#include <wchar.h>
+#include <errno.h>
+#include <string.h>
+
+size_t wcsrtombs(char *dest, const wchar_t **src, size_t len, mbstate_t *ps) {
+  wchar_t c;
+  char buf[MB_CUR_MAX];
+  size_t cur;
+  char* max;
+  if (!src || !*src) {
+inval:
+    errno=EINVAL;
+    return -1;
+  }
+  if (!dest) {
+    len=-1;
+    max=dest+len;
+  }
+  for (cur=0; (c=**src); ++*src) {
+    size_t n;
+    char* s=__likely(len-cur>=MB_CUR_MAX)?(dest?dest+cur:NULL):buf;
+    n=wcrtomb(s,c,ps);
+    if (n==(size_t)-1) return -1;
+    if (dest && s==buf) {
+      /* check if we fit */
+      if (len<n) return cur;
+      memcpy(dest+cur,buf,n);
+    }
+    cur+=n;
+  }
+  if (dest && len>cur) dest[cur]=0;
+keinplatz:
+  return cur;
+}
+
diff --git a/lib/wcstombs.c b/lib/wcstombs.c
new file mode 100644
index 0000000..ab90d85
--- /dev/null
+++ b/lib/wcstombs.c
@@ -0,0 +1,9 @@
+#include <wchar.h>
+#include "dietlocale.h"
+#include <wchar.h>
+#include <errno.h>
+#include <string.h>
+
+size_t wcstombs(char *dest, const wchar_t **src, size_t len) {
+  return wcsrtombs(dest,src,len,NULL);
+}
diff --git a/libcruft/dnscruft2.c b/libcruft/dnscruft2.c
index d9756ef..299082d 100644
--- a/libcruft/dnscruft2.c
+++ b/libcruft/dnscruft2.c
@@ -48,14 +48,16 @@ int __dns_gethostbyx_r(const char* name, struct hostent* result,
     result->h_addrtype=AF_INET6;
     result->h_length=16;
   }
-  result->h_aliases=(char**)(buf+8*sizeof(char*));
+  result->h_aliases=(char**)(buf+9*sizeof(char*));
   result->h_addr_list=(char**)buf;
   result->h_aliases[0]=0;
 
-  cur=buf+16*sizeof(char*);
+  cur=buf+18*sizeof(char*);
   max=buf+buflen;
   names=ips=0;
 
+  if (buflen<128) goto invalidpacket;
+
   if ((size=res_query(name,C_IN,lookfor,(unsigned char*)inpkg,512))<0) {
 invalidpacket:
     *h_errnop=HOST_NOT_FOUND;
@@ -75,6 +77,7 @@ invalidpacket:
       if (tmp>inpkg+size) goto invalidpacket;
       q=((unsigned short)inpkg[6]<<8)+inpkg[7];
       if (q<1) goto nodata;
+      if (q>8) q=8;
       while (q>0) {
 	int decofs=__dns_decodename((unsigned char*)inpkg,(size_t)(tmp-(char*)inpkg),Name,256,(unsigned char*)inpkg+size);
 	if (decofs<0) break;
@@ -110,10 +113,11 @@ invalidpacket:
 	    result->h_name=cur;
 	  else
 	    result->h_aliases[names-1]=cur;
-	  result->h_aliases[names]=0;
-	  if (names<8) ++names;
-/*		cur+=slen+1; */
-	  cur+=(slen|3)+1;
+	  if (!names || strcmp(cur,result->h_name)) {
+	    cur+=(slen|3)+1;
+	    ++names;
+	  }
+	  result->h_aliases[names-1]=0;
 	  result->h_addr_list[ips++] = cur;
 	  if (lookfor==1) /* A */ {
 	    memcpy(cur,tmp,4);
diff --git a/libcruft/res_query.c b/libcruft/res_query.c
index d1e4b73..41f9410 100644
--- a/libcruft/res_query.c
+++ b/libcruft/res_query.c
@@ -207,8 +207,8 @@ int res_query(const char *dname, int class, int type, unsigned char *answer, int
 	    } else
 	      continue;
 /* ignore NXDOMAIN from the multicast socket */
-nxdomain:
 #endif
+nxdomain:
 	    h_errno=HOST_NOT_FOUND;
 	    return -1;
 	  }		/* error */
diff --git a/libpthread/pthread_create.c b/libpthread/pthread_create.c
index fcfc37e..12d3115 100644
--- a/libpthread/pthread_create.c
+++ b/libpthread/pthread_create.c
@@ -6,6 +6,12 @@
 #include <pthread.h>
 #include "thread_internal.h"
 
+#ifdef WANT_TLS
+#include <sys/tls.h>
+
+extern size_t __tmemsize;
+#endif
+
 int pthread_attr_init(pthread_attr_t*attr) {
   memset(attr,0,sizeof(pthread_attr_t));
   attr->__stacksize=PTHREAD_STACK_SIZE;
@@ -22,11 +28,22 @@ int pthread_attr_destroy(pthread_attr_t *attr) __attribute__((alias("pthread_att
 
 int pthread_create(pthread_t*thread,const pthread_attr_t*d_attr,
 		void*(*start_routine)(void*),void*arg) {
+#if 0
+  /* first try the linux 2.6 way */
+  if (__likely(__modern_linux>=0)) {
+    /* try new way; if it fails, assume old kernel */
+  }
+#endif
   struct __thread_descr request;
   pthread_attr_t attr;
-  _pthread_descr td,this=__thread_self();
+  _pthread_descr td,this;
+  this=__thread_self();
   char*stack;
   int ret;
+#ifdef WANT_TLS
+  size_t origsize;
+  size_t additional;
+#endif
 
   if (thread==0) kill(getpid(),SIGSEGV);
   if (start_routine==0) return EINVAL;
@@ -38,6 +55,19 @@ int pthread_create(pthread_t*thread,const pthread_attr_t*d_attr,
   else
     pthread_attr_init(&attr);
 
+#ifdef WANT_TLS
+  origsize=attr.__stacksize;
+  additional=__tmemsize+sizeof(tcbhead_t);
+  additional=(additional+15)&-16;
+  if (additional < sizeof(tcbhead_t) ||
+      origsize < sizeof(struct _pthread_descr_struct) ||
+      origsize+additional < origsize) {
+    ret=EINVAL;
+    goto func_out;
+  }
+  attr.__stacksize=origsize+additional;
+#endif
+
   {
     register char*stb,*st=0;
     if ((stack=attr.__stackaddr)==0) {
@@ -48,6 +78,7 @@ int pthread_create(pthread_t*thread,const pthread_attr_t*d_attr,
 	goto func_out;
       }
     }
+
     stb=stack;
 #ifdef __parisc__
     td=(_pthread_descr)stack;
diff --git a/libpthread/pthread_internal.c b/libpthread/pthread_internal.c
index 70761b9..8e3313f 100644
--- a/libpthread/pthread_internal.c
+++ b/libpthread/pthread_internal.c
@@ -10,6 +10,8 @@
 #include <sched.h>
 #include <sys/resource.h>
 
+#include <stdlib.h>
+
 #include <pthread.h>
 #include "thread_internal.h"
 
@@ -19,6 +21,10 @@
 #include <stdio.h>
 #endif
 
+#ifdef WANT_TLS
+#include <sys/tls.h>
+#endif
+
 #define INTR_RETRY(e) ({ long ret; do ret=(long)(e); while ((ret==-1)&&(_errno_==EINTR)); ret; })
 
 #define __NO_ASYNC_CANCEL_STOP }
@@ -34,7 +40,7 @@ static pthread_once_t __thread_started=PTHREAD_ONCE_INIT;
 
 static unsigned long __thread_pagesize;
 
-static int __manager_pipe[2];
+static int __manager_pipe[2]={-1,-1};
 #define mgr_recv_fd __manager_pipe[0]
 #define mgr_send_fd __manager_pipe[1]
 
@@ -115,6 +121,16 @@ _pthread_descr __thread_self(void) {
   asm("ear %0,%%a0" : "=d"(cur) );	/* a0 (access register 0) is used as thread pointer */
 #elif defined(__ia64__)
   asm("mov %0 = r13" : "=r"(cur) );	/* r13 (tp) is used as thread pointer */
+#elif defined(__x86_64__)
+  asm("mov %%fs:(16),%0" : "=r"(cur));
+#elif defined(__i386__)
+  if (__likely(__modern_linux==1))
+    asm("mov %%gs:(8),%0" : "=r"(cur));
+  else {
+    /* old cruft O(n*) */
+    cur=__thread_find_(getpid());
+    if (cur) UNLOCK(cur);
+  }
 #else	/* other */
   /* all other archs:
    * search the thread depending on the PID O(n*) */
@@ -336,6 +352,21 @@ static inline _pthread_descr __thread_set_register(void*arg) {
 #endif
   return (_pthread_descr)arg;
 }
+
+#ifdef WANT_TLS
+extern size_t __tdatasize, __tmemsize;
+extern void* __tdataptr;
+extern void __setup_tls(tcbhead_t* thread);
+#endif
+
+#ifdef WANT_SSP
+extern unsigned long __guard;
+#endif
+
+#if defined(WANT_TLS) || defined(WANT_SSP)
+extern tcbhead_t* __tcb_mainthread;
+#endif
+
 /* thread start helper */
 static void* __managed_start(void*arg) {
 #if defined(__sparc__)
@@ -345,7 +376,33 @@ static void* __managed_start(void*arg) {
 #else
   _pthread_descr td;
 #endif
+#if defined(WANT_TLS) || defined(WANT_SSP)
+  __tcb_mainthread->multiple_threads=1;
+  tcbhead_t* me=alloca(sizeof(tcbhead_t)
+#ifdef WANT_TLS
+		                        +__tmemsize);
+/*  printf("allocating %lu bytes (%lu + %lu)\n",sizeof(tcbhead_t)+__tmemsize,sizeof(tcbhead_t),__tmemsize); */
+  memcpy(me,__tdataptr,__tdatasize);
+  memset(((char*)me)+__tdatasize,0,__tmemsize-__tdatasize);
+  me=(tcbhead_t*)(((char*)me) + __tmemsize);
+#endif
+  __setup_tls(me);
+  me->multiple_threads=1;
+
+#ifdef WANT_SSP
+  me->pointer_guard=__guard ^ (uintptr_t)me;
+#endif
+  me->self=arg;
+  td=arg;
+  __thread_set_register(me);
+
+#else
   td=__thread_set_register(arg);
+#endif
+
+#ifdef WANT_TLS
+#endif
+
   td->pid=getpid();
 #ifdef DEBUG
   printf("__managed_start: %d pre suspend\n",td->pid);
@@ -419,8 +476,8 @@ int pthread_getschedparam(pthread_t th,int*policy,struct sched_param*param) {
 
 void __thread_manager_close(void) {
   __thread_started=PTHREAD_ONCE_INIT;
-  close(mgr_recv_fd);
-  close(mgr_send_fd);
+  if (mgr_recv_fd>=0) close(mgr_recv_fd);
+  if (mgr_send_fd>=0) close(mgr_send_fd);
   /* FIXME: missing: resource deallocation (free of unused thread stacks) */
   /* reinit of main thread struct */
   memset(_thread_hash_tid,0,sizeof(_thread_hash_tid));
diff --git a/libpthread/thread_internal.h b/libpthread/thread_internal.h
index e1d0704..ad382ba 100644
--- a/libpthread/thread_internal.h
+++ b/libpthread/thread_internal.h
@@ -13,6 +13,9 @@
 #error "the diet libc is not compiled with thread safeness enabled!"
 #endif
 
+extern int __modern_linux;	/* can be -1 (old linux), 0 (unknown), or 1 (new linux). */
+/* if 1, assume 2.6 kernel with TLS and futexes et al */
+
 #undef errno
 #define _errno_ (*__errno_location())
 
@@ -85,7 +88,6 @@ struct _pthread_descr_struct {
   int h_errno;
   struct res_state __res;
 #endif
-
 } __attribute__((aligned(32)));
 #define thread_sig_mask jmp_exit->__saved_mask
 
diff --git a/libregex/rx.c b/libregex/rx.c
index 8b60952..8ba4d45 100644
--- a/libregex/rx.c
+++ b/libregex/rx.c
@@ -243,12 +243,21 @@ match:
     return plus+matchlen;
 }
 
+static int closebracket(const char* s,const regex_t* r) {
+  if (r->cflags&REG_EXTENDED)
+    return *s==')';
+  else
+    return (*s=='\\' && s[1]==')');
+}
+
 static const char* parseatom(struct atom*__restrict__ a,const char*__restrict__ s,regex_t*__restrict__ rx) {
   const char *tmp;
   a->m=(matcher)matchatom;
   a->bnum=-1;
   switch (*s) {
   case '(':
+    if ((rx->cflags&REG_EXTENDED)==0) goto handle_char;
+openbracket:
     a->bnum=++rx->brackets;
     if (s[1]==')') {
       a->type=EMPTY;
@@ -256,11 +265,13 @@ static const char* parseatom(struct atom*__restrict__ a,const char*__restrict__
     }
     a->type=REGEX;
     tmp=parseregex(&a->u.r,s+1,rx);
-    if (*tmp==')')
-      return tmp+1;
+    if (closebracket(tmp,rx))
+      return tmp+1+((rx->cflags&REG_EXTENDED)==0);
+  case ')':
+    if ((rx->cflags&REG_EXTENDED)==0) goto handle_char;
+    /* fall through */
   case 0:
   case '|':
-  case ')':
     return s;
   case '[':
     a->type=BRACKET;
@@ -288,9 +299,13 @@ static const char* parseatom(struct atom*__restrict__ a,const char*__restrict__
       a->type=BACKREF;
       a->u.c=*s-'0';
       break;
+    } else if ((rx->cflags&REG_EXTENDED)==0) {
+      if (*s=='(') goto openbracket; else
+      if (*s==')') return s-1;
     }
     /* fall through */
   default:
+handle_char:
     a->type=CHAR;
     if (rx->cflags&REG_ICASE) {
       a->u.c=tolower(*s);
@@ -483,7 +498,7 @@ static const char* parseregex(struct regex*__restrict__ r,const char*__restrict_
   }
   for (;;) {
     tmp=parsebranch(&b,s,p,&r->pieces);
-    if (tmp==s && *s!=')') return s;
+    if (tmp==s && !closebracket(s,p)) return s;
 //    printf("r->b from %p to ",r->b);
     {
       struct branch* tmp;
@@ -493,13 +508,13 @@ static const char* parseregex(struct regex*__restrict__ r,const char*__restrict_
     }
 //    printf("%p (size %d)\n",r->b,r->num*sizeof(b));
     r->b[r->num-1]=b;
-    if (*s==')') {
+    if (closebracket(s,p)) {
       r->b[r->num-1].m=matchempty;
       return s;
     }
 //    printf("assigned branch %d at %p\n",r->num-1,r->b);
     s=tmp;
-    if (*s==')') return s;
+    if (closebracket(s,p)) return s;
     if (*s=='|') ++s;
   }
   return tmp;
diff --git a/librpc/pmap_clnt.c b/librpc/pmap_clnt.c
index 9dbf3f6..f6bf03e 100644
--- a/librpc/pmap_clnt.c
+++ b/librpc/pmap_clnt.c
@@ -52,11 +52,7 @@ static struct timeval tottimeout = { 60, 0 };
  * Set a mapping between program,version and port.
  * Calls the pmap service remotely to do the mapping.
  */
-bool_t pmap_set(program, version, protocol, port)
-unsigned long program;
-unsigned long version;
-int protocol;
-unsigned short port;
+bool_t pmap_set(const unsigned long program, const unsigned long version, int protocol, unsigned short port)
 {
 	struct sockaddr_in myaddress;
 	int socket = -1;
diff --git a/libugly/wmemmove.c b/libugly/wmemmove.c
new file mode 100644
index 0000000..b4bd589
--- /dev/null
+++ b/libugly/wmemmove.c
@@ -0,0 +1,12 @@
+#include <wchar.h>
+
+wchar_t *wmemmove(wchar_t *dest, const wchar_t *src, size_t n) {
+  size_t i;
+  if (src<dest && dest<src+n)
+    for (i=0; i<n; ++i)
+      dest[n-i-1]=src[n-i-1];
+  else
+    for (i=0; i<n; ++i)
+      dest[i]=src[i];
+  return dest;
+}
diff --git a/mips/divdi3.c b/mips/divdi3.c
index df6a5d2..18d8a2b 100644
--- a/mips/divdi3.c
+++ b/mips/divdi3.c
@@ -23,21 +23,6 @@
 
 #if __WORDSIZE == 32
 
-typedef unsigned int UQItype	__attribute__ ((mode (QI)));
-typedef          int SItype	__attribute__ ((mode (SI)));
-typedef unsigned int USItype	__attribute__ ((mode (SI)));
-typedef          int DItype	__attribute__ ((mode (DI)));
-typedef unsigned int UDItype	__attribute__ ((mode (DI)));
-#define Wtype SItype
-#define HWtype SItype
-#define DWtype DItype
-#define UWtype USItype
-#define UHWtype USItype
-#define UDWtype UDItype
-#define W_TYPE_SIZE 32
-
-#include "longlong.h"
-
 const
 unsigned char __clz_tab[] =
 {
@@ -51,6 +36,21 @@ unsigned char __clz_tab[] =
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
 };
 
+#include "mips/longlong.h"
+
+typedef unsigned int UQItype	__attribute__ ((mode (QI)));
+typedef          int SItype	__attribute__ ((mode (SI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+typedef          int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+#define Wtype SItype
+#define HWtype SItype
+#define DWtype DItype
+#define UWtype USItype
+#define UHWtype USItype
+#define UDWtype UDItype
+#define W_TYPE_SIZE 32
+
 #if __BYTE_ORDER == __BIG_ENDIAN
 struct DWstruct { Wtype high, low;};
 #elif __BYTE_ORDER == __LITTLE_ENDIAN
@@ -318,7 +318,7 @@ __moddi3 (DWtype u, DWtype v)
     }
   if (v < 0)
     v = -v;
-  __udivmoddi4 (u, v, &w);
+  __udivmoddi4 (u, v, (UDWtype *) &w);
   if (c)
     w = -w;
   return w;
diff --git a/mips/longlong.h b/mips/longlong.h
new file mode 100644
index 0000000..2daab0f
--- /dev/null
+++ b/mips/longlong.h
@@ -0,0 +1,1459 @@
+/* longlong.h -- definitions for mixed size 32/64 bit arithmetic.
+   Copyright (C) 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* You have to define the following before including this file:
+
+   UWtype -- An unsigned type, default type for operations (typically a "word")
+   UHWtype -- An unsigned type, at least half the size of UWtype.
+   UDWtype -- An unsigned type, at least twice as large a UWtype
+   W_TYPE_SIZE -- size in bits of UWtype
+
+   UQItype -- Unsigned 8 bit type.
+   SItype, USItype -- Signed and unsigned 32 bit types.
+   DItype, UDItype -- Signed and unsigned 64 bit types.
+
+   On a 32 bit machine UWtype should typically be USItype;
+   on a 64 bit machine, UWtype should typically be UDItype.  */
+
+#define __BITS4 (W_TYPE_SIZE / 4)
+#define __ll_B ((UWtype) 1 << (W_TYPE_SIZE / 2))
+#define __ll_lowpart(t) ((UWtype) (t) & (__ll_B - 1))
+#define __ll_highpart(t) ((UWtype) (t) >> (W_TYPE_SIZE / 2))
+
+#ifndef W_TYPE_SIZE
+#define W_TYPE_SIZE	32
+#define UWtype		USItype
+#define UHWtype		USItype
+#define UDWtype		UDItype
+#endif
+
+/* Define auxiliary asm macros.
+
+   1) umul_ppmm(high_prod, low_prod, multiplier, multiplicand) multiplies two
+   UWtype integers MULTIPLIER and MULTIPLICAND, and generates a two UWtype
+   word product in HIGH_PROD and LOW_PROD.
+
+   2) __umulsidi3(a,b) multiplies two UWtype integers A and B, and returns a
+   UDWtype product.  This is just a variant of umul_ppmm.
+
+   3) udiv_qrnnd(quotient, remainder, high_numerator, low_numerator,
+   denominator) divides a UDWtype, composed by the UWtype integers
+   HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and places the quotient
+   in QUOTIENT and the remainder in REMAINDER.  HIGH_NUMERATOR must be less
+   than DENOMINATOR for correct operation.  If, in addition, the most
+   significant bit of DENOMINATOR must be 1, then the pre-processor symbol
+   UDIV_NEEDS_NORMALIZATION is defined to 1.
+
+   4) sdiv_qrnnd(quotient, remainder, high_numerator, low_numerator,
+   denominator).  Like udiv_qrnnd but the numbers are signed.  The quotient
+   is rounded towards 0.
+
+   5) count_leading_zeros(count, x) counts the number of zero-bits from the
+   msb to the first nonzero bit in the UWtype X.  This is the number of
+   steps X needs to be shifted left to set the msb.  Undefined for X == 0,
+   unless the symbol COUNT_LEADING_ZEROS_0 is defined to some value.
+
+   6) count_trailing_zeros(count, x) like count_leading_zeros, but counts
+   from the least significant end.
+
+   7) add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1,
+   high_addend_2, low_addend_2) adds two UWtype integers, composed by
+   HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and LOW_ADDEND_2
+   respectively.  The result is placed in HIGH_SUM and LOW_SUM.  Overflow
+   (i.e. carry out) is not stored anywhere, and is lost.
+
+   8) sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend,
+   high_subtrahend, low_subtrahend) subtracts two two-word UWtype integers,
+   composed by HIGH_MINUEND_1 and LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and
+   LOW_SUBTRAHEND_2 respectively.  The result is placed in HIGH_DIFFERENCE
+   and LOW_DIFFERENCE.  Overflow (i.e. carry out) is not stored anywhere,
+   and is lost.
+
+   If any of these macros are left undefined for a particular CPU,
+   C macros are used.  */
+
+/* The CPUs come in alphabetical order below.
+
+   Please add support for more CPUs here, or improve the current support
+   for the CPUs below!
+   (E.g. WE32100, IBM360.)  */
+
+#if defined (__GNUC__) && !defined (NO_ASM)
+
+/* We sometimes need to clobber "cc" with gcc2, but that would not be
+   understood by gcc1.  Use cpp to avoid major code duplication.  */
+#if __GNUC__ < 2
+#define __CLOBBER_CC
+#define __AND_CLOBBER_CC
+#else /* __GNUC__ >= 2 */
+#define __CLOBBER_CC : "cc"
+#define __AND_CLOBBER_CC , "cc"
+#endif /* __GNUC__ < 2 */
+
+#if defined (__alpha) && W_TYPE_SIZE == 64
+#define umul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    UDItype __m0 = (m0), __m1 = (m1);					\
+    (ph) = __builtin_alpha_umulh (__m0, __m1);				\
+    (pl) = __m0 * __m1;							\
+  } while (0)
+#define UMUL_TIME 46
+#ifndef LONGLONG_STANDALONE
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  do { UDItype __r;							\
+    (q) = __udiv_qrnnd (&__r, (n1), (n0), (d));				\
+    (r) = __r;								\
+  } while (0)
+extern UDItype __udiv_qrnnd (UDItype *, UDItype, UDItype, UDItype);
+#define UDIV_TIME 220
+#endif /* LONGLONG_STANDALONE */
+#ifdef __alpha_cix__
+#define count_leading_zeros(COUNT,X)	((COUNT) = __builtin_clzl (X))
+#define count_trailing_zeros(COUNT,X)	((COUNT) = __builtin_ctzl (X))
+#define COUNT_LEADING_ZEROS_0 64
+#else
+#define count_leading_zeros(COUNT,X) \
+  do {									\
+    UDItype __xr = (X), __t, __a;					\
+    __t = __builtin_alpha_cmpbge (0, __xr);				\
+    __a = __clz_tab[__t ^ 0xff] - 1;					\
+    __t = __builtin_alpha_extbl (__xr, __a);				\
+    (COUNT) = 64 - (__clz_tab[__t] + __a*8);				\
+  } while (0)
+#define count_trailing_zeros(COUNT,X) \
+  do {									\
+    UDItype __xr = (X), __t, __a;					\
+    __t = __builtin_alpha_cmpbge (0, __xr);				\
+    __t = ~__t & -~__t;							\
+    __a = ((__t & 0xCC) != 0) * 2;					\
+    __a += ((__t & 0xF0) != 0) * 4;					\
+    __a += ((__t & 0xAA) != 0);						\
+    __t = __builtin_alpha_extbl (__xr, __a);				\
+    __a <<= 3;								\
+    __t &= -__t;							\
+    __a += ((__t & 0xCC) != 0) * 2;					\
+    __a += ((__t & 0xF0) != 0) * 4;					\
+    __a += ((__t & 0xAA) != 0);						\
+    (COUNT) = __a;							\
+  } while (0)
+#endif /* __alpha_cix__ */
+#endif /* __alpha */
+
+#if defined (__arc__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add.f	%1, %4, %5\n\tadc	%0, %2, %3"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%r" ((USItype) (ah)),					\
+	     "rIJ" ((USItype) (bh)),					\
+	     "%r" ((USItype) (al)),					\
+	     "rIJ" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub.f	%1, %4, %5\n\tsbc	%0, %2, %3"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "r" ((USItype) (ah)),					\
+	     "rIJ" ((USItype) (bh)),					\
+	     "r" ((USItype) (al)),					\
+	     "rIJ" ((USItype) (bl)))
+/* Call libgcc routine.  */
+#define umul_ppmm(w1, w0, u, v) \
+do {									\
+  DWunion __w;								\
+  __w.ll = __umulsidi3 (u, v);						\
+  w1 = __w.s.high;							\
+  w0 = __w.s.low;							\
+} while (0)
+#define __umulsidi3 __umulsidi3
+UDItype __umulsidi3 (USItype, USItype);
+#endif
+
+#if defined (__arm__) && !defined (__thumb__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("adds	%1, %4, %5\n\tadc	%0, %2, %3"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%r" ((USItype) (ah)),					\
+	     "rI" ((USItype) (bh)),					\
+	     "%r" ((USItype) (al)),					\
+	     "rI" ((USItype) (bl)) __CLOBBER_CC)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("subs	%1, %4, %5\n\tsbc	%0, %2, %3"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "r" ((USItype) (ah)),					\
+	     "rI" ((USItype) (bh)),					\
+	     "r" ((USItype) (al)),					\
+	     "rI" ((USItype) (bl)) __CLOBBER_CC)
+#define umul_ppmm(xh, xl, a, b) \
+{register USItype __t0, __t1, __t2;					\
+  __asm__ ("%@ Inlined umul_ppmm\n"					\
+	   "	mov	%2, %5, lsr #16\n"				\
+	   "	mov	%0, %6, lsr #16\n"				\
+	   "	bic	%3, %5, %2, lsl #16\n"				\
+	   "	bic	%4, %6, %0, lsl #16\n"				\
+	   "	mul	%1, %3, %4\n"					\
+	   "	mul	%4, %2, %4\n"					\
+	   "	mul	%3, %0, %3\n"					\
+	   "	mul	%0, %2, %0\n"					\
+	   "	adds	%3, %4, %3\n"					\
+	   "	addcs	%0, %0, #65536\n"				\
+	   "	adds	%1, %1, %3, lsl #16\n"				\
+	   "	adc	%0, %0, %3, lsr #16"				\
+	   : "=&r" ((USItype) (xh)),					\
+	     "=r" ((USItype) (xl)),					\
+	     "=&r" (__t0), "=&r" (__t1), "=r" (__t2)			\
+	   : "r" ((USItype) (a)),					\
+	     "r" ((USItype) (b)) __CLOBBER_CC );}
+#define UMUL_TIME 20
+#define UDIV_TIME 100
+#endif /* __arm__ */
+
+#if defined(__arm__)
+/* Let gcc decide how best to implement count_leading_zeros.  */
+#define count_leading_zeros(COUNT,X)	((COUNT) = __builtin_clz (X))
+#define COUNT_LEADING_ZEROS_0 32
+#endif
+
+#if defined (__CRIS__) && __CRIS_arch_version >= 3
+#define count_leading_zeros(COUNT, X) ((COUNT) = __builtin_clz (X))
+#if __CRIS_arch_version >= 8
+#define count_trailing_zeros(COUNT, X) ((COUNT) = __builtin_ctz (X))
+#endif
+#endif /* __CRIS__ */
+
+#if defined (__hppa) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add %4,%5,%1\n\taddc %2,%3,%0"				\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%rM" ((USItype) (ah)),					\
+	     "rM" ((USItype) (bh)),					\
+	     "%rM" ((USItype) (al)),					\
+	     "rM" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub %4,%5,%1\n\tsubb %2,%3,%0"				\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "rM" ((USItype) (ah)),					\
+	     "rM" ((USItype) (bh)),					\
+	     "rM" ((USItype) (al)),					\
+	     "rM" ((USItype) (bl)))
+#if defined (_PA_RISC1_1)
+#define umul_ppmm(w1, w0, u, v) \
+  do {									\
+    union								\
+      {									\
+	UDItype __f;							\
+	struct {USItype __w1, __w0;} __w1w0;				\
+      } __t;								\
+    __asm__ ("xmpyu %1,%2,%0"						\
+	     : "=x" (__t.__f)						\
+	     : "x" ((USItype) (u)),					\
+	       "x" ((USItype) (v)));					\
+    (w1) = __t.__w1w0.__w1;						\
+    (w0) = __t.__w1w0.__w0;						\
+     } while (0)
+#define UMUL_TIME 8
+#else
+#define UMUL_TIME 30
+#endif
+#define UDIV_TIME 40
+#define count_leading_zeros(count, x) \
+  do {									\
+    USItype __tmp;							\
+    __asm__ (								\
+       "ldi		1,%0\n"						\
+"	extru,=		%1,15,16,%%r0		; Bits 31..16 zero?\n"	\
+"	extru,tr	%1,15,16,%1		; No.  Shift down, skip add.\n"\
+"	ldo		16(%0),%0		; Yes.  Perform add.\n"	\
+"	extru,=		%1,23,8,%%r0		; Bits 15..8 zero?\n"	\
+"	extru,tr	%1,23,8,%1		; No.  Shift down, skip add.\n"\
+"	ldo		8(%0),%0		; Yes.  Perform add.\n"	\
+"	extru,=		%1,27,4,%%r0		; Bits 7..4 zero?\n"	\
+"	extru,tr	%1,27,4,%1		; No.  Shift down, skip add.\n"\
+"	ldo		4(%0),%0		; Yes.  Perform add.\n"	\
+"	extru,=		%1,29,2,%%r0		; Bits 3..2 zero?\n"	\
+"	extru,tr	%1,29,2,%1		; No.  Shift down, skip add.\n"\
+"	ldo		2(%0),%0		; Yes.  Perform add.\n"	\
+"	extru		%1,30,1,%1		; Extract bit 1.\n"	\
+"	sub		%0,%1,%0		; Subtract it.\n"	\
+	: "=r" (count), "=r" (__tmp) : "1" (x));			\
+  } while (0)
+#endif
+
+#if (defined (__i370__) || defined (__s390__) || defined (__mvs__)) && W_TYPE_SIZE == 32
+#define smul_ppmm(xh, xl, m0, m1) \
+  do {									\
+    union {DItype __ll;							\
+	   struct {USItype __h, __l;} __i;				\
+	  } __x;							\
+    __asm__ ("lr %N0,%1\n\tmr %0,%2"					\
+	     : "=&r" (__x.__ll)						\
+	     : "r" (m0), "r" (m1));					\
+    (xh) = __x.__i.__h; (xl) = __x.__i.__l;				\
+  } while (0)
+#define sdiv_qrnnd(q, r, n1, n0, d) \
+  do {									\
+    union {DItype __ll;							\
+	   struct {USItype __h, __l;} __i;				\
+	  } __x;							\
+    __x.__i.__h = n1; __x.__i.__l = n0;					\
+    __asm__ ("dr %0,%2"							\
+	     : "=r" (__x.__ll)						\
+	     : "0" (__x.__ll), "r" (d));				\
+    (q) = __x.__i.__l; (r) = __x.__i.__h;				\
+  } while (0)
+#endif
+
+#if (defined (__i386__) || defined (__i486__)) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add{l} {%5,%1|%1,%5}\n\tadc{l} {%3,%0|%0,%3}"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%0" ((USItype) (ah)),					\
+	     "g" ((USItype) (bh)),					\
+	     "%1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub{l} {%5,%1|%1,%5}\n\tsbb{l} {%3,%0|%0,%3}"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "g" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("mul{l} %3"							\
+	   : "=a" ((USItype) (w0)),					\
+	     "=d" ((USItype) (w1))					\
+	   : "%0" ((USItype) (u)),					\
+	     "rm" ((USItype) (v)))
+#define udiv_qrnnd(q, r, n1, n0, dv) \
+  __asm__ ("div{l} %4"							\
+	   : "=a" ((USItype) (q)),					\
+	     "=d" ((USItype) (r))					\
+	   : "0" ((USItype) (n0)),					\
+	     "1" ((USItype) (n1)),					\
+	     "rm" ((USItype) (dv)))
+#define count_leading_zeros(count, x)	((count) = __builtin_clz (x))
+#define count_trailing_zeros(count, x)	((count) = __builtin_ctz (x))
+#define UMUL_TIME 40
+#define UDIV_TIME 40
+#endif /* 80x86 */
+
+#if (defined (__x86_64__) || defined (__i386__)) && W_TYPE_SIZE == 64
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add{q} {%5,%1|%1,%5}\n\tadc{q} {%3,%0|%0,%3}"		\
+	   : "=r" ((UDItype) (sh)),					\
+	     "=&r" ((UDItype) (sl))					\
+	   : "%0" ((UDItype) (ah)),					\
+	     "rme" ((UDItype) (bh)),					\
+	     "%1" ((UDItype) (al)),					\
+	     "rme" ((UDItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub{q} {%5,%1|%1,%5}\n\tsbb{q} {%3,%0|%0,%3}"		\
+	   : "=r" ((UDItype) (sh)),					\
+	     "=&r" ((UDItype) (sl))					\
+	   : "0" ((UDItype) (ah)),					\
+	     "rme" ((UDItype) (bh)),					\
+	     "1" ((UDItype) (al)),					\
+	     "rme" ((UDItype) (bl)))
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("mul{q} %3"							\
+	   : "=a" ((UDItype) (w0)),					\
+	     "=d" ((UDItype) (w1))					\
+	   : "%0" ((UDItype) (u)),					\
+	     "rm" ((UDItype) (v)))
+#define udiv_qrnnd(q, r, n1, n0, dv) \
+  __asm__ ("div{q} %4"							\
+	   : "=a" ((UDItype) (q)),					\
+	     "=d" ((UDItype) (r))					\
+	   : "0" ((UDItype) (n0)),					\
+	     "1" ((UDItype) (n1)),					\
+	     "rm" ((UDItype) (dv)))
+#define count_leading_zeros(count, x)	((count) = __builtin_clzl (x))
+#define count_trailing_zeros(count, x)	((count) = __builtin_ctzl (x))
+#define UMUL_TIME 40
+#define UDIV_TIME 40
+#endif /* x86_64 */
+
+#if defined (__i960__) && W_TYPE_SIZE == 32
+#define umul_ppmm(w1, w0, u, v) \
+  ({union {UDItype __ll;						\
+	   struct {USItype __l, __h;} __i;				\
+	  } __xx;							\
+  __asm__ ("emul	%2,%1,%0"					\
+	   : "=d" (__xx.__ll)						\
+	   : "%dI" ((USItype) (u)),					\
+	     "dI" ((USItype) (v)));					\
+  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})
+#define __umulsidi3(u, v) \
+  ({UDItype __w;							\
+    __asm__ ("emul	%2,%1,%0"					\
+	     : "=d" (__w)						\
+	     : "%dI" ((USItype) (u)),					\
+	       "dI" ((USItype) (v)));					\
+    __w; })
+#endif /* __i960__ */
+
+#if defined (__M32R__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  /* The cmp clears the condition bit.  */ \
+  __asm__ ("cmp %0,%0\n\taddx %1,%5\n\taddx %0,%3"			\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "r" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "r" ((USItype) (bl))					\
+	   : "cbit")
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  /* The cmp clears the condition bit.  */ \
+  __asm__ ("cmp %0,%0\n\tsubx %1,%5\n\tsubx %0,%3"			\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "r" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "r" ((USItype) (bl))					\
+	   : "cbit")
+#endif /* __M32R__ */
+
+#if defined (__mc68000__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add%.l %5,%1\n\taddx%.l %3,%0"				\
+	   : "=d" ((USItype) (sh)),					\
+	     "=&d" ((USItype) (sl))					\
+	   : "%0" ((USItype) (ah)),					\
+	     "d" ((USItype) (bh)),					\
+	     "%1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub%.l %5,%1\n\tsubx%.l %3,%0"				\
+	   : "=d" ((USItype) (sh)),					\
+	     "=&d" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "d" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+
+/* The '020, '030, '040, '060 and CPU32 have 32x32->64 and 64/32->32q-32r.  */
+#if (defined (__mc68020__) && !defined (__mc68060__))
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("mulu%.l %3,%1:%0"						\
+	   : "=d" ((USItype) (w0)),					\
+	     "=d" ((USItype) (w1))					\
+	   : "%0" ((USItype) (u)),					\
+	     "dmi" ((USItype) (v)))
+#define UMUL_TIME 45
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  __asm__ ("divu%.l %4,%1:%0"						\
+	   : "=d" ((USItype) (q)),					\
+	     "=d" ((USItype) (r))					\
+	   : "0" ((USItype) (n0)),					\
+	     "1" ((USItype) (n1)),					\
+	     "dmi" ((USItype) (d)))
+#define UDIV_TIME 90
+#define sdiv_qrnnd(q, r, n1, n0, d) \
+  __asm__ ("divs%.l %4,%1:%0"						\
+	   : "=d" ((USItype) (q)),					\
+	     "=d" ((USItype) (r))					\
+	   : "0" ((USItype) (n0)),					\
+	     "1" ((USItype) (n1)),					\
+	     "dmi" ((USItype) (d)))
+
+#elif defined (__mcoldfire__) /* not mc68020 */
+
+#define umul_ppmm(xh, xl, a, b) \
+  __asm__ ("| Inlined umul_ppmm\n"					\
+	   "	move%.l	%2,%/d0\n"					\
+	   "	move%.l	%3,%/d1\n"					\
+	   "	move%.l	%/d0,%/d2\n"					\
+	   "	swap	%/d0\n"						\
+	   "	move%.l	%/d1,%/d3\n"					\
+	   "	swap	%/d1\n"						\
+	   "	move%.w	%/d2,%/d4\n"					\
+	   "	mulu	%/d3,%/d4\n"					\
+	   "	mulu	%/d1,%/d2\n"					\
+	   "	mulu	%/d0,%/d3\n"					\
+	   "	mulu	%/d0,%/d1\n"					\
+	   "	move%.l	%/d4,%/d0\n"					\
+	   "	clr%.w	%/d0\n"						\
+	   "	swap	%/d0\n"						\
+	   "	add%.l	%/d0,%/d2\n"					\
+	   "	add%.l	%/d3,%/d2\n"					\
+	   "	jcc	1f\n"						\
+	   "	add%.l	%#65536,%/d1\n"					\
+	   "1:	swap	%/d2\n"						\
+	   "	moveq	%#0,%/d0\n"					\
+	   "	move%.w	%/d2,%/d0\n"					\
+	   "	move%.w	%/d4,%/d2\n"					\
+	   "	move%.l	%/d2,%1\n"					\
+	   "	add%.l	%/d1,%/d0\n"					\
+	   "	move%.l	%/d0,%0"					\
+	   : "=g" ((USItype) (xh)),					\
+	     "=g" ((USItype) (xl))					\
+	   : "g" ((USItype) (a)),					\
+	     "g" ((USItype) (b))					\
+	   : "d0", "d1", "d2", "d3", "d4")
+#define UMUL_TIME 100
+#define UDIV_TIME 400
+#else /* not ColdFire */
+/* %/ inserts REGISTER_PREFIX, %# inserts IMMEDIATE_PREFIX.  */
+#define umul_ppmm(xh, xl, a, b) \
+  __asm__ ("| Inlined umul_ppmm\n"					\
+	   "	move%.l	%2,%/d0\n"					\
+	   "	move%.l	%3,%/d1\n"					\
+	   "	move%.l	%/d0,%/d2\n"					\
+	   "	swap	%/d0\n"						\
+	   "	move%.l	%/d1,%/d3\n"					\
+	   "	swap	%/d1\n"						\
+	   "	move%.w	%/d2,%/d4\n"					\
+	   "	mulu	%/d3,%/d4\n"					\
+	   "	mulu	%/d1,%/d2\n"					\
+	   "	mulu	%/d0,%/d3\n"					\
+	   "	mulu	%/d0,%/d1\n"					\
+	   "	move%.l	%/d4,%/d0\n"					\
+	   "	eor%.w	%/d0,%/d0\n"					\
+	   "	swap	%/d0\n"						\
+	   "	add%.l	%/d0,%/d2\n"					\
+	   "	add%.l	%/d3,%/d2\n"					\
+	   "	jcc	1f\n"						\
+	   "	add%.l	%#65536,%/d1\n"					\
+	   "1:	swap	%/d2\n"						\
+	   "	moveq	%#0,%/d0\n"					\
+	   "	move%.w	%/d2,%/d0\n"					\
+	   "	move%.w	%/d4,%/d2\n"					\
+	   "	move%.l	%/d2,%1\n"					\
+	   "	add%.l	%/d1,%/d0\n"					\
+	   "	move%.l	%/d0,%0"					\
+	   : "=g" ((USItype) (xh)),					\
+	     "=g" ((USItype) (xl))					\
+	   : "g" ((USItype) (a)),					\
+	     "g" ((USItype) (b))					\
+	   : "d0", "d1", "d2", "d3", "d4")
+#define UMUL_TIME 100
+#define UDIV_TIME 400
+
+#endif /* not mc68020 */
+
+/* The '020, '030, '040 and '060 have bitfield insns.
+   cpu32 disguises as a 68020, but lacks them.  */
+#if defined (__mc68020__) && !defined (__mcpu32__)
+#define count_leading_zeros(count, x) \
+  __asm__ ("bfffo %1{%b2:%b2},%0"					\
+	   : "=d" ((USItype) (count))					\
+	   : "od" ((USItype) (x)), "n" (0))
+/* Some ColdFire architectures have a ff1 instruction supported via
+   __builtin_clz. */
+#elif defined (__mcfisaaplus__) || defined (__mcfisac__)
+#define count_leading_zeros(count,x) ((count) = __builtin_clz (x))
+#define COUNT_LEADING_ZEROS_0 32
+#endif
+#endif /* mc68000 */
+
+#if defined (__m88000__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("addu.co %1,%r4,%r5\n\taddu.ci %0,%r2,%r3"			\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%rJ" ((USItype) (ah)),					\
+	     "rJ" ((USItype) (bh)),					\
+	     "%rJ" ((USItype) (al)),					\
+	     "rJ" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("subu.co %1,%r4,%r5\n\tsubu.ci %0,%r2,%r3"			\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "rJ" ((USItype) (ah)),					\
+	     "rJ" ((USItype) (bh)),					\
+	     "rJ" ((USItype) (al)),					\
+	     "rJ" ((USItype) (bl)))
+#define count_leading_zeros(count, x) \
+  do {									\
+    USItype __cbtmp;							\
+    __asm__ ("ff1 %0,%1"						\
+	     : "=r" (__cbtmp)						\
+	     : "r" ((USItype) (x)));					\
+    (count) = __cbtmp ^ 31;						\
+  } while (0)
+#define COUNT_LEADING_ZEROS_0 63 /* sic */
+#if defined (__mc88110__)
+#define umul_ppmm(wh, wl, u, v) \
+  do {									\
+    union {UDItype __ll;						\
+	   struct {USItype __h, __l;} __i;				\
+	  } __xx;							\
+    __asm__ ("mulu.d	%0,%1,%2"					\
+	     : "=r" (__xx.__ll)						\
+	     : "r" ((USItype) (u)),					\
+	       "r" ((USItype) (v)));					\
+    (wh) = __xx.__i.__h;						\
+    (wl) = __xx.__i.__l;						\
+  } while (0)
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  ({union {UDItype __ll;						\
+	   struct {USItype __h, __l;} __i;				\
+	  } __xx;							\
+  USItype __q;								\
+  __xx.__i.__h = (n1); __xx.__i.__l = (n0);				\
+  __asm__ ("divu.d %0,%1,%2"						\
+	   : "=r" (__q)							\
+	   : "r" (__xx.__ll),						\
+	     "r" ((USItype) (d)));					\
+  (r) = (n0) - __q * (d); (q) = __q; })
+#define UMUL_TIME 5
+#define UDIV_TIME 25
+#else
+#define UMUL_TIME 17
+#define UDIV_TIME 150
+#endif /* __mc88110__ */
+#endif /* __m88000__ */
+
+#if defined (__mips__) && W_TYPE_SIZE == 32
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    UDItype __x = (UDItype) (USItype) (u) * (USItype) (v);		\
+    (w1) = (USItype) (__x >> 32);					\
+    (w0) = (USItype) (__x);						\
+  } while (0)
+#define UMUL_TIME 10
+#define UDIV_TIME 100
+
+#if (__mips == 32 || __mips == 64) && ! __mips16
+#define count_leading_zeros(COUNT,X)	((COUNT) = __builtin_clz (X))
+#define COUNT_LEADING_ZEROS_0 32
+#endif
+#endif /* __mips__ */
+
+#if defined (__ns32000__) && W_TYPE_SIZE == 32
+#define umul_ppmm(w1, w0, u, v) \
+  ({union {UDItype __ll;						\
+	   struct {USItype __l, __h;} __i;				\
+	  } __xx;							\
+  __asm__ ("meid %2,%0"							\
+	   : "=g" (__xx.__ll)						\
+	   : "%0" ((USItype) (u)),					\
+	     "g" ((USItype) (v)));					\
+  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})
+#define __umulsidi3(u, v) \
+  ({UDItype __w;							\
+    __asm__ ("meid %2,%0"						\
+	     : "=g" (__w)						\
+	     : "%0" ((USItype) (u)),					\
+	       "g" ((USItype) (v)));					\
+    __w; })
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  ({union {UDItype __ll;						\
+	   struct {USItype __l, __h;} __i;				\
+	  } __xx;							\
+  __xx.__i.__h = (n1); __xx.__i.__l = (n0);				\
+  __asm__ ("deid %2,%0"							\
+	   : "=g" (__xx.__ll)						\
+	   : "0" (__xx.__ll),						\
+	     "g" ((USItype) (d)));					\
+  (r) = __xx.__i.__l; (q) = __xx.__i.__h; })
+#define count_trailing_zeros(count,x) \
+  do {									\
+    __asm__ ("ffsd     %2,%0"						\
+            : "=r" ((USItype) (count))					\
+            : "0" ((USItype) 0),					\
+              "r" ((USItype) (x)));					\
+  } while (0)
+#endif /* __ns32000__ */
+
+/* FIXME: We should test _IBMR2 here when we add assembly support for the
+   system vendor compilers.
+   FIXME: What's needed for gcc PowerPC VxWorks?  __vxworks__ is not good
+   enough, since that hits ARM and m68k too.  */
+#if (defined (_ARCH_PPC)	/* AIX */				\
+     || defined (_ARCH_PWR)	/* AIX */				\
+     || defined (_ARCH_COM)	/* AIX */				\
+     || defined (__powerpc__)	/* gcc */				\
+     || defined (__POWERPC__)	/* BEOS */				\
+     || defined (__ppc__)	/* Darwin */				\
+     || (defined (PPC) && ! defined (CPU_FAMILY)) /* gcc 2.7.x GNU&SysV */    \
+     || (defined (PPC) && defined (CPU_FAMILY)    /* VxWorks */               \
+         && CPU_FAMILY == PPC)                                                \
+     ) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  do {									\
+    if (__builtin_constant_p (bh) && (bh) == 0)				\
+      __asm__ ("{a%I4|add%I4c} %1,%3,%4\n\t{aze|addze} %0,%2"		\
+	     : "=r" (sh), "=&r" (sl) : "r" (ah), "%r" (al), "rI" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == ~(USItype) 0)		\
+      __asm__ ("{a%I4|add%I4c} %1,%3,%4\n\t{ame|addme} %0,%2"		\
+	     : "=r" (sh), "=&r" (sl) : "r" (ah), "%r" (al), "rI" (bl));\
+    else								\
+      __asm__ ("{a%I5|add%I5c} %1,%4,%5\n\t{ae|adde} %0,%2,%3"		\
+	     : "=r" (sh), "=&r" (sl)					\
+	     : "%r" (ah), "r" (bh), "%r" (al), "rI" (bl));		\
+  } while (0)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  do {									\
+    if (__builtin_constant_p (ah) && (ah) == 0)				\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{sfze|subfze} %0,%2"	\
+	       : "=r" (sh), "=&r" (sl) : "r" (bh), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (ah) && (ah) == ~(USItype) 0)		\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{sfme|subfme} %0,%2"	\
+	       : "=r" (sh), "=&r" (sl) : "r" (bh), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == 0)			\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{ame|addme} %0,%2"		\
+	       : "=r" (sh), "=&r" (sl) : "r" (ah), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == ~(USItype) 0)		\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{aze|addze} %0,%2"		\
+	       : "=r" (sh), "=&r" (sl) : "r" (ah), "rI" (al), "r" (bl));\
+    else								\
+      __asm__ ("{sf%I4|subf%I4c} %1,%5,%4\n\t{sfe|subfe} %0,%3,%2"	\
+	       : "=r" (sh), "=&r" (sl)					\
+	       : "r" (ah), "r" (bh), "rI" (al), "r" (bl));		\
+  } while (0)
+#define count_leading_zeros(count, x) \
+  __asm__ ("{cntlz|cntlzw} %0,%1" : "=r" (count) : "r" (x))
+#define COUNT_LEADING_ZEROS_0 32
+#if defined (_ARCH_PPC) || defined (__powerpc__) || defined (__POWERPC__) \
+  || defined (__ppc__)                                                    \
+  || (defined (PPC) && ! defined (CPU_FAMILY)) /* gcc 2.7.x GNU&SysV */       \
+  || (defined (PPC) && defined (CPU_FAMILY)    /* VxWorks */                  \
+         && CPU_FAMILY == PPC)
+#define umul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    USItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("mulhwu %0,%1,%2" : "=r" (ph) : "%r" (m0), "r" (m1));	\
+    (pl) = __m0 * __m1;							\
+  } while (0)
+#define UMUL_TIME 15
+#define smul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    SItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("mulhw %0,%1,%2" : "=r" (ph) : "%r" (m0), "r" (m1));	\
+    (pl) = __m0 * __m1;							\
+  } while (0)
+#define SMUL_TIME 14
+#define UDIV_TIME 120
+#elif defined (_ARCH_PWR)
+#define UMUL_TIME 8
+#define smul_ppmm(xh, xl, m0, m1) \
+  __asm__ ("mul %0,%2,%3" : "=r" (xh), "=q" (xl) : "r" (m0), "r" (m1))
+#define SMUL_TIME 4
+#define sdiv_qrnnd(q, r, nh, nl, d) \
+  __asm__ ("div %0,%2,%4" : "=r" (q), "=q" (r) : "r" (nh), "1" (nl), "r" (d))
+#define UDIV_TIME 100
+#endif
+#endif /* 32-bit POWER architecture variants.  */
+
+/* We should test _IBMR2 here when we add assembly support for the system
+   vendor compilers.  */
+#if (defined (_ARCH_PPC64) || defined (__powerpc64__)) && W_TYPE_SIZE == 64
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  do {									\
+    if (__builtin_constant_p (bh) && (bh) == 0)				\
+      __asm__ ("{a%I4|add%I4c} %1,%3,%4\n\t{aze|addze} %0,%2"		\
+	     : "=r" (sh), "=&r" (sl) : "r" (ah), "%r" (al), "rI" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == ~(UDItype) 0)		\
+      __asm__ ("{a%I4|add%I4c} %1,%3,%4\n\t{ame|addme} %0,%2"		\
+	     : "=r" (sh), "=&r" (sl) : "r" (ah), "%r" (al), "rI" (bl));\
+    else								\
+      __asm__ ("{a%I5|add%I5c} %1,%4,%5\n\t{ae|adde} %0,%2,%3"		\
+	     : "=r" (sh), "=&r" (sl)					\
+	     : "%r" (ah), "r" (bh), "%r" (al), "rI" (bl));		\
+  } while (0)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  do {									\
+    if (__builtin_constant_p (ah) && (ah) == 0)				\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{sfze|subfze} %0,%2"	\
+	       : "=r" (sh), "=&r" (sl) : "r" (bh), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (ah) && (ah) == ~(UDItype) 0)		\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{sfme|subfme} %0,%2"	\
+	       : "=r" (sh), "=&r" (sl) : "r" (bh), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == 0)			\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{ame|addme} %0,%2"		\
+	       : "=r" (sh), "=&r" (sl) : "r" (ah), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == ~(UDItype) 0)		\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{aze|addze} %0,%2"		\
+	       : "=r" (sh), "=&r" (sl) : "r" (ah), "rI" (al), "r" (bl));\
+    else								\
+      __asm__ ("{sf%I4|subf%I4c} %1,%5,%4\n\t{sfe|subfe} %0,%3,%2"	\
+	       : "=r" (sh), "=&r" (sl)					\
+	       : "r" (ah), "r" (bh), "rI" (al), "r" (bl));		\
+  } while (0)
+#define count_leading_zeros(count, x) \
+  __asm__ ("cntlzd %0,%1" : "=r" (count) : "r" (x))
+#define COUNT_LEADING_ZEROS_0 64
+#define umul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    UDItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("mulhdu %0,%1,%2" : "=r" (ph) : "%r" (m0), "r" (m1));	\
+    (pl) = __m0 * __m1;							\
+  } while (0)
+#define UMUL_TIME 15
+#define smul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    DItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("mulhd %0,%1,%2" : "=r" (ph) : "%r" (m0), "r" (m1));	\
+    (pl) = __m0 * __m1;							\
+  } while (0)
+#define SMUL_TIME 14  /* ??? */
+#define UDIV_TIME 120 /* ??? */
+#endif /* 64-bit PowerPC.  */
+
+#if defined (__ibm032__) /* RT/ROMP */ && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("a %1,%5\n\tae %0,%3"					\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%0" ((USItype) (ah)),					\
+	     "r" ((USItype) (bh)),					\
+	     "%1" ((USItype) (al)),					\
+	     "r" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("s %1,%5\n\tse %0,%3"					\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "r" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "r" ((USItype) (bl)))
+#define umul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    USItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ (								\
+       "s	r2,r2\n"						\
+"	mts	r10,%2\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	cas	%0,r2,r0\n"						\
+"	mfs	r10,%1"							\
+	     : "=r" ((USItype) (ph)),					\
+	       "=r" ((USItype) (pl))					\
+	     : "%r" (__m0),						\
+		"r" (__m1)						\
+	     : "r2");							\
+    (ph) += ((((SItype) __m0 >> 31) & __m1)				\
+	     + (((SItype) __m1 >> 31) & __m0));				\
+  } while (0)
+#define UMUL_TIME 20
+#define UDIV_TIME 200
+#define count_leading_zeros(count, x) \
+  do {									\
+    if ((x) >= 0x10000)							\
+      __asm__ ("clz	%0,%1"						\
+	       : "=r" ((USItype) (count))				\
+	       : "r" ((USItype) (x) >> 16));				\
+    else								\
+      {									\
+	__asm__ ("clz	%0,%1"						\
+		 : "=r" ((USItype) (count))				\
+		 : "r" ((USItype) (x)));					\
+	(count) += 16;							\
+      }									\
+  } while (0)
+#endif
+
+#if defined(__sh__) && !__SHMEDIA__ && W_TYPE_SIZE == 32
+#ifndef __sh1__
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ (								\
+       "dmulu.l	%2,%3\n\tsts%M1	macl,%1\n\tsts%M0	mach,%0"	\
+	   : "=r<" ((USItype)(w1)),					\
+	     "=r<" ((USItype)(w0))					\
+	   : "r" ((USItype)(u)),					\
+	     "r" ((USItype)(v))						\
+	   : "macl", "mach")
+#define UMUL_TIME 5
+#endif
+
+/* This is the same algorithm as __udiv_qrnnd_c.  */
+#define UDIV_NEEDS_NORMALIZATION 1
+
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  do {									\
+    extern UWtype __udiv_qrnnd_16 (UWtype, UWtype)			\
+                        __attribute__ ((visibility ("hidden")));	\
+    /* r0: rn r1: qn */ /* r0: n1 r4: n0 r5: d r6: d1 */ /* r2: __m */	\
+    __asm__ (								\
+	"mov%M4 %4,r5\n"						\
+"	swap.w %3,r4\n"							\
+"	swap.w r5,r6\n"							\
+"	jsr @%5\n"							\
+"	shll16 r6\n"							\
+"	swap.w r4,r4\n"							\
+"	jsr @%5\n"							\
+"	swap.w r1,%0\n"							\
+"	or r1,%0"							\
+	: "=r" (q), "=&z" (r)						\
+	: "1" (n1), "r" (n0), "rm" (d), "r" (&__udiv_qrnnd_16)		\
+	: "r1", "r2", "r4", "r5", "r6", "pr");				\
+  } while (0)
+
+#define UDIV_TIME 80
+
+#define sub_ddmmss(sh, sl, ah, al, bh, bl)				\
+  __asm__ ("clrt;subc %5,%1; subc %4,%0"				\
+	   : "=r" (sh), "=r" (sl)					\
+	   : "0" (ah), "1" (al), "r" (bh), "r" (bl))
+
+#endif /* __sh__ */
+
+#if defined (__SH5__) && __SHMEDIA__ && W_TYPE_SIZE == 32
+#define __umulsidi3(u,v) ((UDItype)(USItype)u*(USItype)v)
+#define count_leading_zeros(count, x) \
+  do									\
+    {									\
+      UDItype x_ = (USItype)(x);					\
+      SItype c_;							\
+									\
+      __asm__ ("nsb %1, %0" : "=r" (c_) : "r" (x_));			\
+      (count) = c_ - 31;						\
+    }									\
+  while (0)
+#define COUNT_LEADING_ZEROS_0 32
+#endif
+
+#if defined (__sparc__) && !defined (__arch64__) && !defined (__sparcv9) \
+    && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("addcc %r4,%5,%1\n\taddx %r2,%3,%0"				\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%rJ" ((USItype) (ah)),					\
+	     "rI" ((USItype) (bh)),					\
+	     "%rJ" ((USItype) (al)),					\
+	     "rI" ((USItype) (bl))					\
+	   __CLOBBER_CC)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("subcc %r4,%5,%1\n\tsubx %r2,%3,%0"				\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "rJ" ((USItype) (ah)),					\
+	     "rI" ((USItype) (bh)),					\
+	     "rJ" ((USItype) (al)),					\
+	     "rI" ((USItype) (bl))					\
+	   __CLOBBER_CC)
+#if defined (__sparc_v8__)
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("umul %2,%3,%1;rd %%y,%0"					\
+	   : "=r" ((USItype) (w1)),					\
+	     "=r" ((USItype) (w0))					\
+	   : "r" ((USItype) (u)),					\
+	     "r" ((USItype) (v)))
+#define udiv_qrnnd(__q, __r, __n1, __n0, __d) \
+  __asm__ ("mov %2,%%y;nop;nop;nop;udiv %3,%4,%0;umul %0,%4,%1;sub %3,%1,%1"\
+	   : "=&r" ((USItype) (__q)),					\
+	     "=&r" ((USItype) (__r))					\
+	   : "r" ((USItype) (__n1)),					\
+	     "r" ((USItype) (__n0)),					\
+	     "r" ((USItype) (__d)))
+#else
+#if defined (__sparclite__)
+/* This has hardware multiply but not divide.  It also has two additional
+   instructions scan (ffs from high bit) and divscc.  */
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("umul %2,%3,%1;rd %%y,%0"					\
+	   : "=r" ((USItype) (w1)),					\
+	     "=r" ((USItype) (w0))					\
+	   : "r" ((USItype) (u)),					\
+	     "r" ((USItype) (v)))
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  __asm__ ("! Inlined udiv_qrnnd\n"					\
+"	wr	%%g0,%2,%%y	! Not a delayed write for sparclite\n"	\
+"	tst	%%g0\n"							\
+"	divscc	%3,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%0\n"						\
+"	rd	%%y,%1\n"						\
+"	bl,a 1f\n"							\
+"	add	%1,%4,%1\n"						\
+"1:	! End of inline udiv_qrnnd"					\
+	   : "=r" ((USItype) (q)),					\
+	     "=r" ((USItype) (r))					\
+	   : "r" ((USItype) (n1)),					\
+	     "r" ((USItype) (n0)),					\
+	     "rI" ((USItype) (d))					\
+	   : "g1" __AND_CLOBBER_CC)
+#define UDIV_TIME 37
+#define count_leading_zeros(count, x) \
+  do {                                                                  \
+  __asm__ ("scan %1,1,%0"                                               \
+           : "=r" ((USItype) (count))                                   \
+           : "r" ((USItype) (x)));					\
+  } while (0)
+/* Early sparclites return 63 for an argument of 0, but they warn that future
+   implementations might change this.  Therefore, leave COUNT_LEADING_ZEROS_0
+   undefined.  */
+#else
+/* SPARC without integer multiplication and divide instructions.
+   (i.e. at least Sun4/20,40,60,65,75,110,260,280,330,360,380,470,490) */
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("! Inlined umul_ppmm\n"					\
+"	wr	%%g0,%2,%%y	! SPARC has 0-3 delay insn after a wr\n"\
+"	sra	%3,31,%%o5	! Don't move this insn\n"		\
+"	and	%2,%%o5,%%o5	! Don't move this insn\n"		\
+"	andcc	%%g0,0,%%g1	! Don't move this insn\n"		\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,0,%%g1\n"						\
+"	add	%%g1,%%o5,%0\n"						\
+"	rd	%%y,%1"							\
+	   : "=r" ((USItype) (w1)),					\
+	     "=r" ((USItype) (w0))					\
+	   : "%rI" ((USItype) (u)),					\
+	     "r" ((USItype) (v))						\
+	   : "g1", "o5" __AND_CLOBBER_CC)
+#define UMUL_TIME 39		/* 39 instructions */
+/* It's quite necessary to add this much assembler for the sparc.
+   The default udiv_qrnnd (in C) is more than 10 times slower!  */
+#define udiv_qrnnd(__q, __r, __n1, __n0, __d) \
+  __asm__ ("! Inlined udiv_qrnnd\n"					\
+"	mov	32,%%g1\n"						\
+"	subcc	%1,%2,%%g0\n"						\
+"1:	bcs	5f\n"							\
+"	 addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb\n"	\
+"	sub	%1,%2,%1	! this kills msb of n\n"		\
+"	addx	%1,%1,%1	! so this can't give carry\n"		\
+"	subcc	%%g1,1,%%g1\n"						\
+"2:	bne	1b\n"							\
+"	 subcc	%1,%2,%%g0\n"						\
+"	bcs	3f\n"							\
+"	 addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb\n"	\
+"	b	3f\n"							\
+"	 sub	%1,%2,%1	! this kills msb of n\n"		\
+"4:	sub	%1,%2,%1\n"						\
+"5:	addxcc	%1,%1,%1\n"						\
+"	bcc	2b\n"							\
+"	 subcc	%%g1,1,%%g1\n"						\
+"! Got carry from n.  Subtract next step to cancel this carry.\n"	\
+"	bne	4b\n"							\
+"	 addcc	%0,%0,%0	! shift n1n0 and a 0-bit in lsb\n"	\
+"	sub	%1,%2,%1\n"						\
+"3:	xnor	%0,0,%0\n"						\
+"	! End of inline udiv_qrnnd"					\
+	   : "=&r" ((USItype) (__q)),					\
+	     "=&r" ((USItype) (__r))					\
+	   : "r" ((USItype) (__d)),					\
+	     "1" ((USItype) (__n1)),					\
+	     "0" ((USItype) (__n0)) : "g1" __AND_CLOBBER_CC)
+#define UDIV_TIME (3+7*32)	/* 7 instructions/iteration. 32 iterations.  */
+#endif /* __sparclite__ */
+#endif /* __sparc_v8__ */
+#endif /* sparc32 */
+
+#if ((defined (__sparc__) && defined (__arch64__)) || defined (__sparcv9)) \
+    && W_TYPE_SIZE == 64
+#define add_ssaaaa(sh, sl, ah, al, bh, bl)				\
+  __asm__ ("addcc %r4,%5,%1\n\t"					\
+   	   "add %r2,%3,%0\n\t"						\
+   	   "bcs,a,pn %%xcc, 1f\n\t"					\
+   	   "add %0, 1, %0\n"						\
+	   "1:"								\
+	   : "=r" ((UDItype)(sh)),				      	\
+	     "=&r" ((UDItype)(sl))				      	\
+	   : "%rJ" ((UDItype)(ah)),				     	\
+	     "rI" ((UDItype)(bh)),				      	\
+	     "%rJ" ((UDItype)(al)),				     	\
+	     "rI" ((UDItype)(bl))				       	\
+	   __CLOBBER_CC)
+
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) 				\
+  __asm__ ("subcc %r4,%5,%1\n\t"					\
+   	   "sub %r2,%3,%0\n\t"						\
+   	   "bcs,a,pn %%xcc, 1f\n\t"					\
+   	   "sub %0, 1, %0\n\t"						\
+	   "1:"								\
+	   : "=r" ((UDItype)(sh)),				      	\
+	     "=&r" ((UDItype)(sl))				      	\
+	   : "rJ" ((UDItype)(ah)),				     	\
+	     "rI" ((UDItype)(bh)),				      	\
+	     "rJ" ((UDItype)(al)),				     	\
+	     "rI" ((UDItype)(bl))				       	\
+	   __CLOBBER_CC)
+
+#define umul_ppmm(wh, wl, u, v)						\
+  do {									\
+	  UDItype tmp1, tmp2, tmp3, tmp4;				\
+	  __asm__ __volatile__ (					\
+		   "srl %7,0,%3\n\t"					\
+		   "mulx %3,%6,%1\n\t"					\
+		   "srlx %6,32,%2\n\t"					\
+		   "mulx %2,%3,%4\n\t"					\
+		   "sllx %4,32,%5\n\t"					\
+		   "srl %6,0,%3\n\t"					\
+		   "sub %1,%5,%5\n\t"					\
+		   "srlx %5,32,%5\n\t"					\
+		   "addcc %4,%5,%4\n\t"					\
+		   "srlx %7,32,%5\n\t"					\
+		   "mulx %3,%5,%3\n\t"					\
+		   "mulx %2,%5,%5\n\t"					\
+		   "sethi %%hi(0x80000000),%2\n\t"			\
+		   "addcc %4,%3,%4\n\t"					\
+		   "srlx %4,32,%4\n\t"					\
+		   "add %2,%2,%2\n\t"					\
+		   "movcc %%xcc,%%g0,%2\n\t"				\
+		   "addcc %5,%4,%5\n\t"					\
+		   "sllx %3,32,%3\n\t"					\
+		   "add %1,%3,%1\n\t"					\
+		   "add %5,%2,%0"					\
+	   : "=r" ((UDItype)(wh)),					\
+	     "=&r" ((UDItype)(wl)),					\
+	     "=&r" (tmp1), "=&r" (tmp2), "=&r" (tmp3), "=&r" (tmp4)	\
+	   : "r" ((UDItype)(u)),					\
+	     "r" ((UDItype)(v))						\
+	   __CLOBBER_CC);						\
+  } while (0)
+#define UMUL_TIME 96
+#define UDIV_TIME 230
+#endif /* sparc64 */
+
+#if defined (__vax__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("addl2 %5,%1\n\tadwc %3,%0"					\
+	   : "=g" ((USItype) (sh)),					\
+	     "=&g" ((USItype) (sl))					\
+	   : "%0" ((USItype) (ah)),					\
+	     "g" ((USItype) (bh)),					\
+	     "%1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("subl2 %5,%1\n\tsbwc %3,%0"					\
+	   : "=g" ((USItype) (sh)),					\
+	     "=&g" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "g" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+#define umul_ppmm(xh, xl, m0, m1) \
+  do {									\
+    union {								\
+	UDItype __ll;							\
+	struct {USItype __l, __h;} __i;					\
+      } __xx;								\
+    USItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("emul %1,%2,$0,%0"						\
+	     : "=r" (__xx.__ll)						\
+	     : "g" (__m0),						\
+	       "g" (__m1));						\
+    (xh) = __xx.__i.__h;						\
+    (xl) = __xx.__i.__l;						\
+    (xh) += ((((SItype) __m0 >> 31) & __m1)				\
+	     + (((SItype) __m1 >> 31) & __m0));				\
+  } while (0)
+#define sdiv_qrnnd(q, r, n1, n0, d) \
+  do {									\
+    union {DItype __ll;							\
+	   struct {SItype __l, __h;} __i;				\
+	  } __xx;							\
+    __xx.__i.__h = n1; __xx.__i.__l = n0;				\
+    __asm__ ("ediv %3,%2,%0,%1"						\
+	     : "=g" (q), "=g" (r)					\
+	     : "g" (__xx.__ll), "g" (d));				\
+  } while (0)
+#endif /* __vax__ */
+
+#if defined (__xtensa__) && W_TYPE_SIZE == 32
+/* This code is not Xtensa-configuration-specific, so rely on the compiler
+   to expand builtin functions depending on what configuration features
+   are available.  This avoids library calls when the operation can be
+   performed in-line.  */
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    DWunion __w;							\
+    __w.ll = __builtin_umulsidi3 (u, v);				\
+    w1 = __w.s.high;							\
+    w0 = __w.s.low;							\
+  } while (0)
+#define __umulsidi3(u, v)		__builtin_umulsidi3 (u, v)
+#define count_leading_zeros(COUNT, X)	((COUNT) = __builtin_clz (X))
+#define count_trailing_zeros(COUNT, X)	((COUNT) = __builtin_ctz (X))
+#endif /* __xtensa__ */
+
+#if defined (__z8000__) && W_TYPE_SIZE == 16
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add	%H1,%H5\n\tadc	%H0,%H3"				\
+	   : "=r" ((unsigned int)(sh)),					\
+	     "=&r" ((unsigned int)(sl))					\
+	   : "%0" ((unsigned int)(ah)),					\
+	     "r" ((unsigned int)(bh)),					\
+	     "%1" ((unsigned int)(al)),					\
+	     "rQR" ((unsigned int)(bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub	%H1,%H5\n\tsbc	%H0,%H3"				\
+	   : "=r" ((unsigned int)(sh)),					\
+	     "=&r" ((unsigned int)(sl))					\
+	   : "0" ((unsigned int)(ah)),					\
+	     "r" ((unsigned int)(bh)),					\
+	     "1" ((unsigned int)(al)),					\
+	     "rQR" ((unsigned int)(bl)))
+#define umul_ppmm(xh, xl, m0, m1) \
+  do {									\
+    union {long int __ll;						\
+	   struct {unsigned int __h, __l;} __i;				\
+	  } __xx;							\
+    unsigned int __m0 = (m0), __m1 = (m1);				\
+    __asm__ ("mult	%S0,%H3"					\
+	     : "=r" (__xx.__i.__h),					\
+	       "=r" (__xx.__i.__l)					\
+	     : "%1" (__m0),						\
+	       "rQR" (__m1));						\
+    (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;				\
+    (xh) += ((((signed int) __m0 >> 15) & __m1)				\
+	     + (((signed int) __m1 >> 15) & __m0));			\
+  } while (0)
+#endif /* __z8000__ */
+
+#endif /* __GNUC__ */
+
+/* If this machine has no inline assembler, use C macros.  */
+
+#if !defined (add_ssaaaa)
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  do {									\
+    UWtype __x;								\
+    __x = (al) + (bl);							\
+    (sh) = (ah) + (bh) + (__x < (al));					\
+    (sl) = __x;								\
+  } while (0)
+#endif
+
+#if !defined (sub_ddmmss)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  do {									\
+    UWtype __x;								\
+    __x = (al) - (bl);							\
+    (sh) = (ah) - (bh) - (__x > (al));					\
+    (sl) = __x;								\
+  } while (0)
+#endif
+
+/* If we lack umul_ppmm but have smul_ppmm, define umul_ppmm in terms of
+   smul_ppmm.  */
+#if !defined (umul_ppmm) && defined (smul_ppmm)
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    UWtype __w1;							\
+    UWtype __xm0 = (u), __xm1 = (v);					\
+    smul_ppmm (__w1, w0, __xm0, __xm1);					\
+    (w1) = __w1 + (-(__xm0 >> (W_TYPE_SIZE - 1)) & __xm1)		\
+		+ (-(__xm1 >> (W_TYPE_SIZE - 1)) & __xm0);		\
+  } while (0)
+#endif
+
+/* If we still don't have umul_ppmm, define it using plain C.  */
+#if !defined (umul_ppmm)
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    UWtype __x0, __x1, __x2, __x3;					\
+    UHWtype __ul, __vl, __uh, __vh;					\
+									\
+    __ul = __ll_lowpart (u);						\
+    __uh = __ll_highpart (u);						\
+    __vl = __ll_lowpart (v);						\
+    __vh = __ll_highpart (v);						\
+									\
+    __x0 = (UWtype) __ul * __vl;					\
+    __x1 = (UWtype) __ul * __vh;					\
+    __x2 = (UWtype) __uh * __vl;					\
+    __x3 = (UWtype) __uh * __vh;					\
+									\
+    __x1 += __ll_highpart (__x0);/* this can't give carry */		\
+    __x1 += __x2;		/* but this indeed can */		\
+    if (__x1 < __x2)		/* did we get it? */			\
+      __x3 += __ll_B;		/* yes, add it in the proper pos.  */	\
+									\
+    (w1) = __x3 + __ll_highpart (__x1);					\
+    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);		\
+  } while (0)
+#endif
+
+#if !defined (__umulsidi3)
+#define __umulsidi3(u, v) \
+  ({DWunion __w;							\
+    umul_ppmm (__w.s.high, __w.s.low, u, v);				\
+    __w.ll; })
+#endif
+
+/* Define this unconditionally, so it can be used for debugging.  */
+#define __udiv_qrnnd_c(q, r, n1, n0, d) \
+  do {									\
+    UWtype __d1, __d0, __q1, __q0;					\
+    UWtype __r1, __r0, __m;						\
+    __d1 = __ll_highpart (d);						\
+    __d0 = __ll_lowpart (d);						\
+									\
+    __r1 = (n1) % __d1;							\
+    __q1 = (n1) / __d1;							\
+    __m = (UWtype) __q1 * __d0;						\
+    __r1 = __r1 * __ll_B | __ll_highpart (n0);				\
+    if (__r1 < __m)							\
+      {									\
+	__q1--, __r1 += (d);						\
+	if (__r1 >= (d)) /* i.e. we didn't get carry when adding to __r1 */\
+	  if (__r1 < __m)						\
+	    __q1--, __r1 += (d);					\
+      }									\
+    __r1 -= __m;							\
+									\
+    __r0 = __r1 % __d1;							\
+    __q0 = __r1 / __d1;							\
+    __m = (UWtype) __q0 * __d0;						\
+    __r0 = __r0 * __ll_B | __ll_lowpart (n0);				\
+    if (__r0 < __m)							\
+      {									\
+	__q0--, __r0 += (d);						\
+	if (__r0 >= (d))						\
+	  if (__r0 < __m)						\
+	    __q0--, __r0 += (d);					\
+      }									\
+    __r0 -= __m;							\
+									\
+    (q) = (UWtype) __q1 * __ll_B | __q0;				\
+    (r) = __r0;								\
+  } while (0)
+
+/* If the processor has no udiv_qrnnd but sdiv_qrnnd, go through
+   __udiv_w_sdiv (defined in libgcc or elsewhere).  */
+#if !defined (udiv_qrnnd) && defined (sdiv_qrnnd)
+#define udiv_qrnnd(q, r, nh, nl, d) \
+  do {									\
+    USItype __r;							\
+    (q) = __udiv_w_sdiv (&__r, nh, nl, d);				\
+    (r) = __r;								\
+  } while (0)
+#endif
+
+/* If udiv_qrnnd was not defined for this processor, use __udiv_qrnnd_c.  */
+#if !defined (udiv_qrnnd)
+#define UDIV_NEEDS_NORMALIZATION 1
+#define udiv_qrnnd __udiv_qrnnd_c
+#endif
+
+#if !defined (count_leading_zeros)
+#define count_leading_zeros(count, x) \
+  do {									\
+    UWtype __xr = (x);							\
+    UWtype __a;								\
+									\
+    if (W_TYPE_SIZE <= 32)						\
+      {									\
+	__a = __xr < ((UWtype)1<<2*__BITS4)				\
+	  ? (__xr < ((UWtype)1<<__BITS4) ? 0 : __BITS4)			\
+	  : (__xr < ((UWtype)1<<3*__BITS4) ?  2*__BITS4 : 3*__BITS4);	\
+      }									\
+    else								\
+      {									\
+	for (__a = W_TYPE_SIZE - 8; __a > 0; __a -= 8)			\
+	  if (((__xr >> __a) & 0xff) != 0)				\
+	    break;							\
+      }									\
+									\
+    (count) = W_TYPE_SIZE - (__clz_tab[__xr >> __a] + __a);		\
+  } while (0)
+#define COUNT_LEADING_ZEROS_0 W_TYPE_SIZE
+#endif
+
+#if !defined (count_trailing_zeros)
+/* Define count_trailing_zeros using count_leading_zeros.  The latter might be
+   defined in asm, but if it is not, the C version above is good enough.  */
+#define count_trailing_zeros(count, x) \
+  do {									\
+    UWtype __ctz_x = (x);						\
+    UWtype __ctz_c;							\
+    count_leading_zeros (__ctz_c, __ctz_x & -__ctz_x);			\
+    (count) = W_TYPE_SIZE - 1 - __ctz_c;				\
+  } while (0)
+#endif
+
+#ifndef UDIV_NEEDS_NORMALIZATION
+#define UDIV_NEEDS_NORMALIZATION 0
+#endif
diff --git a/parisc/clone.S b/parisc/clone.S
index 2846f3b..7a13996 100644
--- a/parisc/clone.S
+++ b/parisc/clone.S
@@ -37,4 +37,4 @@ __clone:
 	bl	_exit,%r2		/* exit thread */
 	copy	%r28,%r26		/* return -> arg0 */
 
-	iitlbp	%r0,(%r0)		/* DIE ! DIE ! */
+/*	iitlbp	%r0,(%r0) */		/* DIE ! DIE ! */
diff --git a/ppc64/__longjmp.S b/ppc64/__longjmp.S
index d4e4caa..f8f7472 100644
--- a/ppc64/__longjmp.S
+++ b/ppc64/__longjmp.S
@@ -1,5 +1,9 @@
 #include <setjmp.h>
 
+	.globl __longjmp
+	.section	".opd","aw"
+	.align 3
+__longjmp:
 		.quad	.__longjmp,.TOC.@tocbase,0
 		.text
 		.size	__longjmp,24
diff --git a/ppc64/setjmp.S b/ppc64/setjmp.S
index 724bcf2..948974e 100644
--- a/ppc64/setjmp.S
+++ b/ppc64/setjmp.S
@@ -6,6 +6,11 @@
 #define JUMPTARGET(name) .name
 #endif
 
+
+	.globl __sigsetjmp
+	.section	".opd","aw"
+	.align 3
+__sigsetjmp:
 		.quad	.__sigsetjmp,.TOC.@tocbase,0
 		.text
 		.size	__sigsetjmp,24
diff --git a/syscalls.s/fallocate.S b/syscalls.s/fallocate.S
new file mode 100644
index 0000000..ca64330
--- /dev/null
+++ b/syscalls.s/fallocate.S
@@ -0,0 +1,5 @@
+#include "syscalls.h"
+
+#ifdef __NR_fallocate
+syscall(fallocate,fallocate)
+#endif
diff --git a/t.c b/t.c
index 987e070..a48d25f 100644
--- a/t.c
+++ b/t.c
@@ -103,7 +103,7 @@ int compint(const void *a, const void *b) {
 extern char* strcpy2(char*a,char*b);
 
 #define rdtscl(low) \
-     __asm__ __volatile__ ("rdtsc" : "=a" (low) : : "edx")
+     __asm__ __volatile__ ("rdtscp" : "=a" (low) : : "ecx","edx")
 
 #define malloc(x) ({typeof(x) y=x; (y<0 || (size_t)(y)!=y ? 0 : malloc(y));})
 
diff --git a/test/regex.c b/test/regex.c
index 9be81e3..d932d22 100644
--- a/test/regex.c
+++ b/test/regex.c
@@ -109,7 +109,7 @@ int main() {
   assert(regexec(&r,"mail.b-net.com.ua",0,NULL,0)==0);
   regfree(&r);
 
-  assert(regcomp(&r,"(foo)bar\\1",0)==0);
+  assert(regcomp(&r,"\\(foo\\)bar\\1",0)==0);
   assert(regexec(&r,"foobarfoo",10,matches,0)==0);
   regfree(&r);
 
diff --git a/test/wcsrtombs.c b/test/wcsrtombs.c
new file mode 100644
index 0000000..c4f9b8f
--- /dev/null
+++ b/test/wcsrtombs.c
@@ -0,0 +1,22 @@
+#include <wchar.h>
+#include <stdio.h>
+#include <assert.h>
+#include <errno.h>
+#include <locale.h>
+#include <string.h>
+
+int main() {
+  wchar_t a[]=L"BÃ¶ses Encoding";
+  const wchar_t* b=a;
+  char buf[100];
+  static mbstate_t ps;
+  size_t l;
+  setlocale(LC_ALL,"de_DE");
+  l=wcsrtombs(buf,&b,sizeof(buf),&ps);
+  assert(l==14); assert(!strcmp(buf,"B\xf6ses Encoding"));
+  memset(buf,0,sizeof(buf));
+  setlocale(LC_ALL,"de_DE.UTF8");
+  b=a;
+  l=wcsrtombs(buf,&b,sizeof(buf),&ps);
+  assert(l==15); assert(!strcmp(buf,"BÃ¶ses Encoding"));
+}
diff --git a/x86_64/memchr.S b/x86_64/memchr.S
new file mode 100644
index 0000000..866a695
--- /dev/null
+++ b/x86_64/memchr.S
@@ -0,0 +1,40 @@
+.text
+.global memchr
+.type memchr,@function
+memchr:	/* rdi=ptr, esi=ch, rdx=len */
+  and $0xff,%esi
+  test %rdx,%rdx
+  jz .Lnull		/* if (!len) return 0 */
+  imul $0x1010101,%esi	/* esi = ch x 4 */
+
+  mov %rdi,%rcx
+  and $15,%ecx
+  movd %esi,%xmm0
+  lea (%rdi,%rdx),%rsi	/* rsi = max ptr */
+  and $~15,%rdi		/* 16-align rdi, diff in cl */
+  or $-1,%eax
+  shl %cl,%eax
+
+  pshufd $0,%xmm0,%xmm0	/* xmm0 = ch x 16 */
+1:
+  movdqa (%rdi),%xmm1
+  pcmpeqb %xmm0,%xmm1
+  pmovmskb %xmm1,%ecx
+  and %eax,%ecx
+  jnz .Lfound	/* found something */
+  lea 16(%rdi),%rdi
+  or $-1,%eax
+  cmp %rsi,%rdi
+  jb 1b
+  jmp .Lnull
+.Lfound:
+  bsf %ecx,%eax
+  add %rdi,%rax
+  cmp %rsi,%rax
+  ja .Lnull
+  ret
+.Lnull:
+  xor %eax,%eax
+  ret
+.Lhere:
+.size memchr,.Lhere-memchr
diff --git a/x86_64/strlen.S b/x86_64/strlen.S
new file mode 100644
index 0000000..5c13a8c
--- /dev/null
+++ b/x86_64/strlen.S
@@ -0,0 +1,32 @@
+.text
+.global strlen
+.type strlen,@function
+strlen:
+        mov %rdi,%rax
+        mov %edi,%ecx
+        pxor %xmm0,%xmm0
+        and $15,%ecx
+        and $-16,%rax
+        movdqa (%rax),%xmm1
+        pcmpeqb %xmm0,%xmm1
+        pmovmskb %xmm1,%edx
+        shr %cl,%edx
+        shl %cl,%edx
+        test %edx,%edx
+        jnz .L2
+.L1:
+        lea 16(%rax),%rax
+        movdqa (%rax),%xmm1
+        pcmpeqb %xmm0,%xmm1
+        pmovmskb %xmm1,%edx
+        test %edx,%edx
+        jz .L1
+.L2:
+        sub %rax,%rdi
+        bsf %edx,%eax
+        sub %rdi,%rax
+        ret
+
+.Lhere:
+        .size    strlen,.Lhere-strlen
+
diff --git a/x86_64/strnlen.S b/x86_64/strnlen.S
new file mode 100644
index 0000000..868dbaf
--- /dev/null
+++ b/x86_64/strnlen.S
@@ -0,0 +1,20 @@
+.text
+.global strnlen
+.type strnlen,@function
+strnlen:
+	/* incoming: rdi = ptr, rsi = len */
+	mov %rdi,%r8
+	mov %rsi,%r9
+	mov %rsi,%rdx
+	xor %esi,%esi
+	call memchr
+	test %rax,%rax
+	jz .Lnotfound
+	sub %r8,%rax
+	ret
+.Lnotfound:
+	mov %r9,%rax
+	ret
+
+.Lhere:
+	.size	 strnlen,.Lhere-strnlen
diff --git a/x86_64/syscalls.h b/x86_64/syscalls.h
index 23966cb..23e34ec 100644
--- a/x86_64/syscalls.h
+++ b/x86_64/syscalls.h
@@ -334,6 +334,17 @@
 #define __NR_fallocate		285
 #define __NR_timerfd_settime	286
 #define __NR_timerfd_gettime	287
+#define __NR_accept4		288
+#define __NR_signalfd4		289
+#define __NR_eventfd2		290
+#define __NR_epoll_create1	291
+#define __NR_dup3		292
+#define __NR_pipe2		293
+#define __NR_inotify_init1	294
+#define __NR_preadv		295
+#define __NR_pwritev		296
+#define __NR_rt_tgsigqueueinfo	297
+#define __NR_perf_event_open	298
 
 #ifdef __PIC__
 #define syscall_weak(name,wsym,sym) \
-- 
1.7.0.3

